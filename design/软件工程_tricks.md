
### 1  A Philosophy of Software Design

**软件设计**

一定要保持写代码，并且不断地进行 reiview 才能提高自己的水平，John Ousterhout 每年至少写 5000 行代码，一共写了 25 - 30 万行代码

设计一个好系统最重要的是拥有的良好的设计观念，设计方法论

**Working Code isn’t enough**

系统不仅仅是 working，还要有好的设计，深入考虑

要在系统设计上投入 10% - 20% 的时间

频繁的做小的系统重构

写新代码，需要小心的设计，良好的文档

一直发现可以改善的地方

不要只修改最少的代码，而是勇于修改，重构，优化

修改之后，修改的部分就像一开始就使用了好的设计一样

**Make continual small investments to improve system design**

通过持续的小投入来改进系统设计，一次搞定就是瀑布流的思想，逐步改进就是敏捷思想。

**Modules should be deep**

深度其实是对模块封装的度量，模块应该提供尽可能简单的接口和尽可能强大的功能

具有通用功能的模块更具深度，更通用功能的接口意味着更高层级的抽象，隐藏更多的实现细节。

接口设计应当使得最常用的路径越简单越好。

相比起实现上的简单，一个模块接口的简单更加重要。

**Seperate general-purpose and special-purpose code**

分离通用的代码和特定需求的代码，抽取公共函数或者公共类。

**Different layers should have different abstractions**

软件系统通常有不同的层次组成，每一层都通过和它之上和之下的层的接口来交互。每一层都具有自己不同的抽象

**Pull complexicity downward.**

把复杂性放在底层

**Design it twice**

这个更多是一种态度和工作方式。我们不要拘泥于初始想法，而是要考虑多个方案，从中选择或者整合最好的方案，并且应当在项目开发之后进行复盘。这肯定是提高软件设计质量的好方法，恐怕也是提升任何能力的好方法


### 2 代码整洁之道

**整洁代码**

衡量代码质量的唯一有效标准：WTF/min

1 整洁代码力求集中，每个函数、每个类和每个模块都全神贯注于一件事。

2 整洁代码简单直接，从不隐藏设计者的意图。

3 性能调至最优，省得引诱别人做没规矩的优化

4 整洁代码应当有单元测试和验收测试。它使用有意义的命名，代码通过其字面表达含义。

5 消除重复代码，提高代码表达力。

6 时时保持代码整洁。

7 尽量减少依赖关系，使之便于维护

**有意义的命名**

1 使用体现本意的命名能让人更容易理解和修改代码。

使用读得出来的名称，使用可搜索的名称

类名应该是名词或名词短语，不应是动词,方法名应当是动词或动词短语

尽量用术语（CS术语，算法，数学术语）命名

**函数**
 
1 短小

不该超过20行，每个代码块（if， else，while）应该只有一行，包含一个函数

2 一个函数应该只做一件事（高内聚），无副作用。如果能拆成几个函数，就不是只做一件事

3 每个函数一个抽象层次，自顶向下阅读代码，如同是在阅读报刊文章。

4 长而具有描述性的函数名称，好过描述性的长注释。

5 尽量避免多余2个参数

使用返回值而不是输出参数，如果一定需要多个参数，那么可能需要对参数进行封装

6 无副作用

尽量少做不是函数名称表明的事情

7 使用异常代替返回错误码

8 消除重复代码

9 在小函数中，偶尔出现return，continue，break没坏处，但不要用goto

10 先把函数写出来，再规范化。写代码很像是写文章。先想怎么写就怎么写，然后再打磨：分解函数、修改名称、消除重复。

11 编程其实是一门语言设计艺术，大师级程序员把程序系统当做故事来讲。使用准确、清晰、富有表达力的代码来帮助你讲故事。

**注释**

1 尽量减少注释量，用代码本身说明问题

创建一个和注释所言相同的函数来代替注释

2 好的注释

法律信息，解释程序员的意图，警示其他程序员某种后果

**格式**

1 垂直距离

（1）变量声明尽可能靠近使用位置，本地变量应在函数顶部出现，实体变量应在类的顶部声明

（2）相关函数放在一起，函数的排列顺序保持其相互调用的顺序，希望底层细节最后展现出来，不用沉溺于细节，所以调用者尽可能放在被调用者之上

2 水平位置

一行代码尽量短，不超过100-120字符，用空格将相关性弱的分开

**对象和数据结构**

1 对象把数据隐藏于抽象之后，只提供操作数据的函数。

对象:暴露行为(接口),隐藏数据(私有变量)

2 The Law of Demeter：模块不应去了解它所操作的对象内部细节。

**异常处理**

1 使用异常而非返回错误码.

错误码，调用者必须在函数返回时立刻处理错误，容易被我们忘记

2 try-catch-finally, log出错信息，记录失败的操作以及失败的类型.

3 不要返回null，不要传递null。

**单元测试**

1 TDD(Test-driven development)三定律

（1）在编写不能通过的单元测试前，不能编写生产代码

（2）只可编写刚好无法通过的单元测试，不能编译也不算通过

（3）只可编写刚好足以通过当前失败测试的生产代码

2 保持测试整洁，测试代码和生产代码一样重要 

3 每个测试一个断言，只测试一个概念

4  整洁的测试依赖于FIRST规则

fast: 测试代码应该能够快速运行，因为我们需要频繁运行它。

independent: 测试应该相互独立，某个测试不应该依赖上一个测试的结果，测试可以以任何顺序进行。

repeatable: 测试应可以在任何环境中通过

self-validating: 测试应该有bool值输出，不应通过查看日志来确认测试结果，不应手工对比两个文本文件确认测试结果。

timely: 及时编写测试代码。单元测试应该在生产代码之前编写，否则生产代码会变得难以测试。类

**类**

1 类的结构组织(顺序)

公共静态常量、私有静态变量、私有实体变量、公共函数、私有工具函数

2 类应该短小

类的名称应当描述其权责

单一权责原则: 类或者模块应该有一个权责

系统应该由许多短小的类而不是少量巨大的类组成

保持内聚性就会得到许多短小的类。内聚性越高说明类中的方法和变量互相依赖、互相结合形成一个逻辑整体。将大函数拆解成小函数往往是将类拆分为小类的时机。

3 为修改而组织

类应当对扩展开放，对修改封闭(开放闭合原则)

**emergent design**

四条规矩帮助你创建优良的设计

1.运行所有测试

2.消除重复

两个方法提取共性到新方法中，新方法分解到另外的类里，从而提升其可见性。

模板方法模式是消除重复的通用技巧
 
3.表达意图

作者把代码写的越清晰，其他人理解代码就越快。多少尊重一下我们的手艺，花一点点时间在每个函数和类上。

4.尽可能少的类和方法


