
# 第一部分：打好基础

## 第一章：欢迎进入软件构建的世界

首先要明确开发计算机软件是一个复杂的工程，并不比建设高楼大厦简单。这项活动和传统的土木工程类有相似的部分，也有迥然不同的地方。

主要有下面的几种活动（根据进程推动顺序）：

- 定义问题
- 需求分析
- 规划构建
- 软件架构/高层设计
- 详细设计
- 编码与调试
- 单元测试
- 集成测试
- 系统测试
- 部署/分发及保障维护
	
《代码大全》主要关注的是构建这部分：

软件构建是软件开发的核心活动；构建活动是每个项目中位移一项必不可少的工作

软件构建的主要活动包括：详细设计、编码、调试、集成、开发者测试（包括单元测试和集成测试）

构建也被称作“编码”和“编程”

构建活动的质量对软件的质量有着实质性的影响

最后，你对“如何进行构建”的理解程度，决定了你这名"程序员"的优秀程度


## 第二章：用隐喻来更充分地理解软件开发

	隐喻的价值绝不应该被低估。隐喻的优点在于其预期的效果：能被所有的人理解。不必要的沟通和误解也因此大为降低，学习与教授更为快速。实际上，隐喻是对概念进行内在化和抽象的一种途径，
	它让人在更高的层面上思考问题，从而避免低层次的错误。

隐喻是启示而不是算法，因此他们往往有一点随意。

隐喻把软件开发过程与其他你熟悉的活动联系在一起，帮助你更好地理解

有些隐喻比其他一些隐喻更贴切

通过把软件的构建过程比作是房屋的建设过程，我们可以发现，仔细的准备是必要的，而大型项目和小型项目之间也是有差异的

通过把软件开发中的实践比作是只会工具箱中的工具，我们发现，每位程序员都有许多工具，但并不存在任何一个能适用于所有工作的工具，因地制宜地选择正确工具是成为能有效编程的程序员的关键。

不同的隐喻彼此并不排斥，应当使用对你最有益处的某种隐喻组合。

隐喻是以一种类比的方法根据一种已知的“模型范式”去理解一种新的领域。这很符合人类认知新事物的思维习惯。但隐喻不是神话，更不是精确的真理，就像某个比喻一样只能在某一个局部进行双向的类比，未必就是全局最合适的。
（同时，注意比喻是有局部性的，不是全局可逆的）

## 第三章：三思而后行：前期准备

	问题定义只定义了问题是什么，而不涉及任何可能的解决方案。

	如果没有好的需求，你可能对问题有总体的把握，但却没有集中问题的特定方面。

	需求像水。如果冻结了，就容易在上面开展建设 ——无名氏 （经常性无法预期的需求变更会伤害项目的开发者，从而毁了项目）

	软件架构是软件设计的高层部分，适用于支撑更细节的设计的框架。

	离开了良好的软件架构，你可能瞄准了正确的问题，但却使用了错误的解决方案。也许完全不可能有成功的构建。

**架构的典型组成部分**

* 程序组织 （源代码层级）
* 主要的类 2/8原则 （基础占20%）
* 数据设计 （数据建模）
* 业务规则 （很有现实意义的重点）
* 用户界面设计 （用户使用的友好度）
* 资源管理
* 安全性（数据库连接、线程、句柄等） （甚至更广泛层面的权限管理）
* 性能
* 可伸缩性
* 互用性
* 国际化、本地化
* 输入输出
* 错误处理
* 容错性
* 架构的可行性
* 过渡工程
* 关于买和造的决策 （在现实情况下，买现成的方案也许是一种更优的选择，不可耻）
* 关于复用的决策
* 变更策略
* 架构的总体质量

**要点**

* 构建活动的准备工作的根本目标在于降低风险。要确认你的准备活动是在降低风险，而非增加风险
* 如果你想开发高质量的软件，软件开发过程必须由始至终关注质量。在项目初期关注质量，对产品质量的正面影响比在项目末期关注质量的一项要大
* 程序员的一部分工作是教育老板和合作者，告诉他们软件开发过程，包括在开始编程之前进行充分准备的重要性
* 你所从事的软件项目的类型对构建活动的前期准备有重大影响——许多项目应该是高度迭代的，某些应该是序列式的
* 如果没有明确的问题定义，那么你可能会在构建期间解决错误的问题
* 如果没有做完良好的需求分析工作，你可能没有察觉待解决的问题的重要细节。如果需求变更发生在构建之后的阶段，其代价是“在项目早期更改需求”的20-100倍。因此在开始编程之前，你要确认“需求“已经到位了
* 如果没有做完良好的架构设计，你可能会在构建期间用错误的方法解决正确的问题。架构变更的代价随着“为错误的架构编写的代码数量”增加而增加，因此，也要确认“”架构“”已经到位了。
* 理解项目的前期准备所采用的方法，并相应地选择构建方法。

**核对表**

架构核对表

针对各架构主题

* 程序的整体组织结构是否清晰？是否包含一个良好的架构全局观（及其理由）
* 是否确定了主要得到构造快（包括每个构造快的职责范围及与其他构造快的接口）
* 是否明确涵盖了“需求”中所列出的所有功能（每个功能对应的构造快不太多也不太少）
* 是否描述并论证了那些最关键的类
* 是否描述并论证了数据设计
* 是否详细定义了数据库的组织结构和内容
* 是否指出了所用关键的业务规则，并描述其对系统的影响？
* 是否描述了用户界面设计的策略‘
* 是否将用户界面模块化，使界面的变更不会影响程序其余部分
* 是否描述并论证了处理I/O的策略
* 是否估算了稀缺资源（如现成、数据库连接、句柄、网络带宽、存储及算力等）的使用量，是否描述并论证了资源管理的策略
* 是否描述了架构的安全需求
* 架构是否为每个类、每个子系统、每个模块功能域提出空间与时间预算
* 架构是否描述了如何达到可伸缩性
* 架构是否关注互操作性
* 是否描述了国际化本地化的策略 （这个要看具体的项目，比如一个团队内部使用的工具，完全没必要，但如果既往框架对此有支持而又没有明显的增加工作量也可以考虑其后续在这方面的扩展性）
* 是否提供了一套内聚的错误处理策略
* 是否规定了容错的方法
* 是否证实了系统各个部分的技术可行性
* 是否详细描述了过渡工程的方法
* 是否包含了必要的 买 vs. 造的决策
* 架构是否描述了如何加工复用的代码，使之符合其他架构目标？
* 是否将架构设计得能够适应和可能出现的变更
	
架构的总体质量

* 架构是否解决了全部的需求
* 有没有那个部分是过渡架构或欠架构？是否明确宣布了在这方面的预期指标
* 整个架构是否在概念上协调一致
* 顶层设计是否独立于用作实现它的机器和语言
* 是否说明了所有主要的决策和动机
* 你，作为一名实现该系统的程序员，是否对这个架构感觉良好？	

## 第四章：关键的“构建”决策

核对表：主要的构建实践

编码

* 你有没有确定多少设计工作将要预先进行，多少设计工作在键盘上进行（在编写代码的同事）？
* 你有没有规定诸如名称、注释、代码格式等“编码约定” （编码规范）
* 你有没有规定特定的由软件架构确定的编码实践，比如如何处理错误条件，如何处理安全性事项，对于类接口有哪些约定、可重用的代码遵循哪些标准，在编码实考虑多少性能因素
* 你有没有找到自己在技术浪潮中的位置，并相应调整自己的措施？如果必要，你是否知道如何“深入一种语言去编程”，而不受限于语言*（仅仅“在一种语言上编程”）

团队工作

* 你有没有定义一套集成工序——即，你有没有定义一套特定的步骤，规定程序员在把代码check in（签入）到主源码（代码库）中之前，必须履行这些步骤
* 程序员是结对编程、还是独自编程，或者这二者的某种组合

质量保证

* 程序员在编写代码之前，是否先为之编写测试用例 （测试驱动）
* 程序员会为自己的代码写单元测试吗？（无论先写还是后写）
* 程序员在check in 代码之前，会调用调试器但不追踪整个代码流程吗？
* 程序员在check in 代码之前，是否进行集成测试（integration-test）
* 程序员会复审（review）或检查别人的代码吗?	

工具

* 你是否选用了某种版本控制工具 （svn，git）
* 你是否选定了一种语言，以及语言的版本或编译器版本
* 你是否选择了某个编程框架（framework,如j2ee 、。net）,或者明确地决定不使用编程框架
* 你是否决定允许使用非标准的语言特性？（在使用非标准的情况下，要保证其整体迁移能力，比如hack了某一部分，要将其整体实现包括到项目内）
* 你是否选定并拥有了其他将要用到的工具——编辑器、重构工具、调试器、测试框架、语法检查器？

要点

-  每种编程语言都有其优点和弱点。要知道你使用的语言的明确优点和弱点
-  在开始编程之前，做好一些约定。“改变代码”使之符合这些“约定”是几乎不可能的
-  “构建的实践方法”的种类比任何单个项目能用到的要多。有意识地选择最适合你的项目的时间方法
-  问问你自己，你采用的编程实践是对你所用的编程语言的正确响应，还是受它的控制？清记得“深入一种语言去编程”，不要仅“在一种语言上编程”
-  你在技术浪潮中的位置决定了哪种方法是有效的——甚至是可能用到的。确定你在技术浪潮中的位置，并响应调整计划和预期目标



# 第二部分：创建高质量的代码

## 第五章：软件构建中的设计

无论是以何种方式来进行设计，小型项目也能和大型项目一样从精心的设计之中获益，而如果能认识到设计是一项明确的活动，你就更会获益匪浅。

设计过程充满了不确定性，因此设计技术也趋于探索性质

软件的首要技术使命：管理复杂度

**设计特征：**

* 最小复杂度
* 易于维护
* 松散耦合
* 可扩展性
* 可重用性
* 高扇入：大量的类使用某个给定的类
* 低扇出：一个类里少量/适量地使用其他的类
* 可移植性
* 精简性
* 层次性
* 标准技术：尽量少依赖外来的，尽量使用标准的、常用的
	
系统层设计图应该是无环图

抽象是一种能让你在关注某一概念的同时可以放心地忽略其中一些细节的能力——在不同的层次处理不同的细节。抽象的主要好处就在于它使得你能忽略无关的细节，抽象是我们用来得以处理现实世界中复杂度的一种重要手段

在设计一个类的时候，一项关键性的决策就是确定类的哪些特性应该对外可见，而哪些特性应该隐藏起来 （面向对象设计的原则）

信息隐藏中所说的秘密主要分为两大类：

* 隐藏复杂度，
* 隐藏变化源

把容易变化的地方隔离开来

* 业务规则
* 对硬件的依赖性
* 输入和输出
* 非标准的语言特性
* 困难的设计区域和构建区域
* 状态变量

**常用的设计模式**

* 抽象工厂(Absctruct Factory):通过制定对象组的种类而非对单个对象的类型来支持创建一组相关的对象
* 适配器（Adapter）:把一个类的接口转变成另一个接口
* 桥接（Bridge）：把接口和实现分离开来，使他们可以独立变化
* 组合（Composite）:创建一个包含其他同类对象的对象，使得客户端代码可以与最上层对象交互而无需考虑所有的细节对象
* 装饰器（Deractor）：给一个对象动态的添加职责，而无需为了每一种可能的职责配置情况去创建特定的子类（派生类）
* 外观（Facade）：为没有提供一致接口的代码提供一个一致的接口
* 工厂方法（Factory Method）：做特定基类的派生类的实例化时，除了在Factory Method内部之外均无需了解各派生对象的具体类型
* 观察者（Observer）:使一组相关对象相互同步，方法是让另一个对象负责：在这组对象中的任何一个发生改变时，由它把这种变化通知给这个组里的所有对象
* 单例模式(Singleton):为有且仅有一个实例的类提供一种全局访问的可能
* 策略(Strategy):定义一组算法或者行为，使得他们可以动态地相互替换
* 迭代方法（Iterator）：提供一个服务对象来顺序的访问一组元素中的各个元素
* 模板方法（Template Method）：定义一个操作的算法结构，但是把部分实现的细节留给子类（派生类）

设计模式的益处

* 设计模式通过提供抽象来减少复杂度
* 设计模式通过把常见解决方案的细节予以制度化来减少出错
* 设计模式通过提供多种设计方案而带来启发性价值
* 设计模式通过把设计对话提升到一个更高的层次上来简化交流


设计模式的陷阱

* 强迫让代码适用于某个模式
* 为了模式而模式


设计中启发式方法的总结：

* 寻找现实世界的对象
* 形成一致的抽象
* 封装实现细节
* 在可能的情况下继承
* 信息隐藏
* 找出容易改变的区域
* 保持松散的耦合
* 探寻通用的设计模式
* 高内聚性
* 构造分层结构
* 严格描述这类契约
* 分配职责
* 为测试而设计
* 避免失误
* 有意识地选择绑定时间
* 创建中央控制点
* 考虑蛮力
* 画一个图
* 保持设计模块化

**解决问题的方法**

	1 理解问题
	2 设计一个计划，找出现有数据和未知量之间的关系
	3 执行计划
	4.回顾

迭代、分而治之、自上而下（分解）、自下而上（合成）

**记录你的设计成果**

* 把设计文档插入到代码
* 用wiki来记录设计讨论和决策
* 写总结邮件
* 使用数码相机
* 保留设计挂图
* 使用CRC卡片
* 在适当的细节层创建UML图
	
**核对表：软件构造中的设计**

设计实践

* 你已经做过多少次迭代，并且从众多尝试结果中选择最佳的一种，而不是简单选择第一次尝试的结果吗
* 你尝试用多种方案来分解系统，以确定最佳方案吗？
* 你同时用自上而下和自下而上的方法来解决涉及到的问题吗？
* 为了解决某些特定的问题，你对系统中的风险部分或者不熟悉的部分创建过原型、写出数量最少的可抛弃的代码吗？
* 你的设计方案被其他人检查了吗（无论正确与否）？
* 你一直在展开设计，直到实施细节跃然纸上了吗？
* 你用某种适当的技术——比如说wiki、电子邮件、挂图、数码照片、UML、CRC卡片或者在代码里写注释——来保留设计成果吗？

**设计目标**

* 你的设计是否充分地处理了由系统架构层定义出并且推迟确定的事项？
* 你的设计被划分为层次吗？
* 你对把这一程序分解成为子程序、包、类的方式感到满意吗？
* 类与类之间的交互关系是否已经设计为最小化了？
* 类和子程序是否被设计为能够在其他的系统中重用？
* 程序是不是易于维护
* 设计是否精简？设计出来的每一部分都是绝对必要的吗？
* 设计中是否采用了标准的技术？是否避免了使用怪异且难以理解的元素？
* 整体而言，你的设计是否有助于最小化偶然性的和本质性的复杂度吗?

**要点**

* 软件的首要技术使命就是管理复杂度。以简单作为努力目标的设计方案对此最有帮助
* 简单性可以通过两种方式获取：一是减少在同一时间所关注的本质性复杂度的量；而是避免生成不必要的偶然的复杂度
* 设计是一种启发式的过程。固执于某一种单一方法会损害创新能力，从而损害你的程序
* 好的设计都是迭代的。你尝试设计的可能性越多，你的最终分设计方案就会变得越好、
* 信息隐藏是个非常有价值的概念。通过询问“我应该隐藏什么？”能够解决很多困难的设计问题	


