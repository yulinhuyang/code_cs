# 目录

## 0x00 基本算法

#### 0x01位运算

- AcWing 89  a^b 
- AcWing 90  64位整数乘法 
- AcWing 91  最短Hamilton路径 
- AcWing 998  起床困难综合症 

#### 0x02递推与递归

- AcWing 92  递归实现指数型枚举 
- AcWing 93  递归实现组合型枚举 
- AcWing 94  递归实现排列型枚举 
- AcWing 95  费解的开关 
- AcWing 96  奇怪的汉诺塔 
- AcWing 97  约数之和 
- AcWing 98  分形之城 

#### 0x03 前缀和与差分

- AcWing 99  激光炸弹 
- AcWing 100  IncDec序列 
- AcWing 101  最高的牛 

#### 0x04  二分和三分

- AcWing 102  最佳牛围栏 
- AcWing 113  特殊排序 

#### 0x05 双指针与排序

- AcWing 103  电影 
- AcWing 104  货仓选址 
- AcWing 105  七夕祭 
- AcWing 106  动态中位数 
- AcWing 107  超快速排序 
- AcWing 108  奇数码问题 

#### 0x06 倍增

- AcWing 109  天才ACM 

#### 0x07 贪心

- AcWing 110  防晒 
- AcWing 111  畜栏预定 
- AcWing 112  雷达设备 
- AcWing 114  国王游戏 
- AcWing 115  给树染色 

#### 0x08 总结与练习

- AcWing 116  飞行员兄弟：枚举/位运算 
- AcWing 117  占卜DIY：模拟 
- AcWing 118  分形：递归/分形
- AcWing 119  袭击：分治/平面最近点时 
- AcWing 120  防线：二分 
- AcWing 121  赶牛入圈：二分/离散化/前缀和 
- AcWing 122  糖果传递：排序/中位数/环形均分纸牌 
- AcWing 123  士兵：排序/中位数/货仓选址问题扩展 
- AcWing 124  数的进制转换：高精度运算/进制转换 
- AcWing 125  耍杂技的牛：贪心/邻项交换 
- AcWing 126  最大的和：贪心 
- AcWing 127  任务：贪心


## 0x10 基本数据结构

包括栈、队列、链表与邻接表、Hash、字符串、Trie、二叉堆等内容。

#### 0x11 栈/单调栈

- AcWing 41  包含min函数的栈 
- AcWing 128  编辑器 
- AcWing 129  火车进栈 
- AcWing 130  火车进出栈问题 
- AcWing 131  直方图中最大的矩形 

#### 0x12 队列/单调队列

- AcWing 132  小组队列 
- AcWing 133  蚯蚓 
- AcWing 134  双端队列 
- AcWing 135  最大子序和 

#### 0x13 链表与邻接表

- AcWing 136  邻值查找 

#### 0x14  hash表(字符串hash)

- AcWing 137  雪花雪花雪花 
- AcWing 138  兔子与兔子 
- AcWing 139  回文子串的最大长度 
- AcWing 140  后缀数组 

#### 0x15 字符串(KMP与最小表示法）

- AcWing 141  周期 

#### 0x16  Trie树（字典树）

- AcWing 142  前缀统计 
- AcWing 143  最大异或对 
- AcWing 144  最长异或值路径 

#### 0x17  二叉堆

- AcWing 145  超市 
- AcWing 146  序列 
- AcWing 147  数据备份 
- AcWing 148  合并果子 
- AcWing 149  荷马史诗 

#### 0x18 总结与练习

- AcWing 150  括号画家：栈 
- AcWing 151  表达式计算：栈/中缀表达式计算 
- AcWing 152  城市游戏：单调栈 
- AcWing 153  双栈排序：栈 
- AcWing 154  滑动窗口：单调队列 
- AcWing 155  内存分配：链表/二叉堆 
- AcWing 156  矩阵：字符串hash 
- AcWing 157  树形地铁系统：hash/树的最小表示 
- AcWing 158  项链：字符串/最小表示法 
- AcWing 159  奶牛矩阵：字符串/kmp模式匹配 
- AcWing 160  匹配统计：字符串hash或kmp模式匹配 
- AcWing 161  电话列表：Trie 
- AcWing 162  黑盒子：二叉堆/对顶堆 
- AcWing 163  生日礼物：等价于数据备份，二叉堆+链表+贪心 
 
## 0x20 搜索

包括树与图的遍历、深度优先搜索、剪枝、迭代加深、广度优先搜索、广搜变形、A*、IDA*等内容。

#### 0x21 树与图的遍历

- AcWing 164  可达性统计 

#### 0x22 深度优先搜索

- AcWing 165  小猫爬山 
- AcWing 166  数独 

#### 0x23 剪枝

- AcWing 167  木棒 
- AcWing 168  生日蛋糕 
- AcWing 169  数独 

#### 0x24 迭代加深

- AcWing 170  加成序列 
- AcWing 171  送礼物 

#### 0x25 广度优先搜索

- AcWing 172  立体推箱子 
- AcWing 173  矩阵距离 
- AcWing 174  推箱子 

#### 0x26 广搜变形

- AcWing 175  电路维修 
- AcWing 176  装满的油箱 
- AcWing 177  噩梦 

#### 0x27 A*

- AcWing 178  第K短路 
- AcWing 179  八数码 

#### 0x28 IDA*

- AcWing 180  排书 
- AcWing 181  回转游戏 
- AcWing 182  破坏正方形
 
#### 0x29 总结与练习

- AcWing 183  靶形数独：DFS/剪枝/位运算优化 
- AcWing 184  虫食算：DFS/剪枝 
- AcWing 185  玛雅游戏：DFS 
- AcWing 186  巴士：DFS/迭代加深 
- AcWing 187  导弹防御系统：DFS/迭代加深 
- AcWing 188  武士风度的牛：走日遍历，dist[x][y]+1 
- AcWing 189  乳草的入侵：BFS 
- AcWing 190  字串变换：BFS/双向广搜 
- AcWing 191  天气预报：BFS 
- AcWing 192  立体推箱子：BFS/分情况讨论。 
- AcWing 193  算乘方的牛：A* 
- AcWing 194  涂满它！：IDA* 
- AcWing 195  骑士精神：IDA*

## 0x30 数学知识 

包括质数、约数、同余、矩阵乘法、高斯消元与线性空间、组合计数、容斥原理与Mobius函数、概率与数学期望、0/1分数规划、博弈论之SG函数等内容。

#### 0x31 质数

- AcWing 196  质数距离 
- AcWing 197  阶乘分解
 
#### 0x32 约数

- AcWing 198  反素数 
- AcWing 199  余数之和 
- AcWing 200  Hankson的趣味题 
- AcWing 201  可见的点 

#### 0x33 同余

- AcWing 202  最幸运的数字 
- AcWing 203  同余方程 
- AcWing 204  表达整数的奇怪方式 

#### 0x34 矩阵乘法

- AcWing 205  斐波那契 
- AcWing 206  石头游戏 

#### 0x35 高斯消元与线性空间

- AcWing 207  球形空间产生器 
- AcWing 208  开关问题 
- AcWing 209  装备购买 
- AcWing 210  异或运算 

#### 0x36 组合计数

- AcWing 211  计算系数 
- AcWing 212  计数交换 
- AcWing 213  古代猪文 

#### 0x37 容斥原理与Mobius函数

- AcWing 214  Devu和鲜花 
- AcWing 215  破译密码 

#### 0x38 概率与数学期望

- AcWing 216  Rainbow的信号 
- AcWing 217  绿豆蛙的归宿 
- AcWing 218  扑克牌 

#### 0x39 0/1分数规划

#### 0x3A 博弈论之SG函数

- AcWing 219  剪纸游戏 

#### 0x3B 总结与练习

- AcWing 220  最大公约数：线性筛法/最大公约数/欧拉函数递推
- AcWing 221  龙哥的问题：最大公约数/欧拉函数/积性函数 
- AcWing 222  青蛙的约会：扩展欧几里得算法 
- AcWing 223  阿九大战朱最学：中国剩余定理 
- AcWing 224  计算器：线性同余方程/高次同余方程 
- AcWing 225  矩阵幂求和：矩阵乘法/分治 
- AcWing 226  233矩阵：矩阵乘法/递推 
- AcWing 227  小部件厂：高斯消元/同余 
- AcWing 228  异或：线性空间/高斯消元/生成树
- AcWing 229  新NIM游戏：线性空间/高斯消元/博弈论 
- AcWing 230  排列计数：组合/错排问题 
- AcWing 231  天码：容斥原理 
- AcWing 232  守卫者的挑战：概率/动态规划 
- AcWing 233  换教室：数学期望/动态规划
- AcWing 234  放弃测试：0/1分数规划 
- AcWing 235  魔法珠：博弈论/SG函数 
- AcWing 236  格鲁吉亚和鲍勃：博弈论 
 
## 0x40 数据结构进阶

包括并查集、树状数组、线段树、分块、点分治、二叉查找树与平衡树初步、离线分治算法、可持久化数据结构等内容。
 
#### 0x41 并查集

- AcWing 237  程序自动分析  
- AcWing 238  银河英雄传说 
- AcWing 239  奇偶游戏 
- AcWing 240  食物链
 
#### 0x42 树状数组

- AcWing 241  楼兰图腾 
- AcWing 242  一个简单的整数问题 
- AcWing 243  一个简单的整数问题 
- AcWing 244  谜一样的牛 

#### 0x43 线段树

- AcWing 245  你能回答这些问题吗 
- AcWing 246  区间最大公约数 
- AcWing 247  亚特兰蒂斯 
- AcWing 248  窗内的星星
 
#### 0x44 分块

- AcWing 249  蒲公英 
- AcWing 250  磁力块 
- AcWing 251  小Z的袜子
 
#### 0x45 点分治

- AcWing 252  树 

#### 0x46 二叉查找树与平衡树初步

- AcWing 253  普通平衡树 

#### 0x47 离线分治算法

- AcWing 254  天使玩偶 
- AcWing 255  第K个数 

#### 0x48 可持久化数据结构

- AcWing 256  最大异或和
 
#### 0x49 总结与练习

- AcWing 257  关押罪犯：并查集/扩展域或边带权 
- AcWing 258  石头剪子布：并查集/扩展域或边带权  
- AcWing 259  真正的骗子：并查集+背包 
- AcWing 260  买票：树形数组 
- AcWing 261  旅馆：线段树/延迟标记 
- AcWing 262  海报：扫描线 
- AcWing 263  作诗：分块 
- AcWing 264  权值：点分块 
- AcWing 265  营业额统计：平衡树/Treap 
- AcWing 266  超级备忘录：平衡树/Splay 
- AcWing 267  莫基亚：基于时间的分治算法 
- AcWing 268  流星：基于值域的整体分治算法 
- AcWing 269  Fotile模拟赛L：分块+可持久化Trie
- AcWing 270  可持久化并查集加强版：可持久化线段树+并查集按秩排序 

## 0x50 动态规划

包括线性DP、背包、区间DP、树形DP、环形与后效性处理、状态压缩DP、倍增优化DP、数据结构优化DP、单调队列优化DP、斜率优化、四边形不等式、计数类 DP、数位统计DP等内容。

#### 0x51 线性DP

- AcWing 271  杨老师的照相排列 
- AcWing 272  最长公共上升子序列 
- AcWing 273  分级 
- AcWing 274  移动服务 
- AcWing 275  传纸条 
- AcWing 276  I-区域 
- AcWing 277  饼干 

#### 0x52 背包

- AcWing 278  数字组合 
- AcWing 279  自然数拆分 
- AcWing 280  陪审团 
- AcWing 281  硬币 

#### 0x53 区间DP

- AcWing 282  石子合并 
- AcWing 283  多边形 
- AcWing 284  金字塔
 
#### 0x54 树形DP

- AcWing 285  没有上司的舞会 
- AcWing 286  选课 
- AcWing 287  积蓄程度 

#### 0x55 环形与后效性处理

- AcWing 288  休息时间 
- AcWing 289  环路运输 
- AcWing 290  坏掉的机器人 

#### 0x56 状态压缩DP

- AcWing 291  蒙德里安的梦想 
- AcWing 292  炮兵阵地 
- AcWing 529  宝藏 

#### 0x57 倍增优化DP

- AcWing 293  开车旅行 
- AcWing 294  计算重复 

#### 0x58 数据结构优化DP

- AcWing 295  清理班次 
- AcWing 296  清理班次 
- AcWing 297  赤壁之战
 
#### 0x59 单调队列优化DP

- AcWing 298  围栏 
- AcWing 299  裁剪序列 

#### 0x5A 斜率优化

- AcWing 300  任务安排1 
- AcWing 301  任务安排2 
- AcWing 302  任务安排3 
- AcWing 303  运输小猫1 

#### 0x5B 四边形不等式

- AcWing 304  诗人小G 
- AcWing 2889  再探石子合并 
- AcWing 305  一个古老的石头游戏 

#### 0x5C 计数类DP

- AcWing 306  杰拉尔德和巨型象棋 
- AcWing 307  连通图 
- AcWing 308  它们中的多少个 
- AcWing 309  装饰围栏 

#### 0x5D 数位统计DP

- AcWing 310  启示录 
- AcWing 311  月之谜 

#### 0x5E 总结与练习

- AcWing 312  乌龟棋：线性DP 
- AcWing 313  花店橱窗：线性DP/输出方案 
- AcWing 314  低买：线性DP/统计LIS方案数 
- AcWing 315  旅行：线性DP/统计LCS方案数并输出 
- AcWing 316  减操作：线性DP 
- AcWing 317  陨石的秘密： 
- AcWing 318  划分大理石：背包/多重背包 
- AcWing 319  折叠序列：区间DP 
- AcWing 320  能量项链：区间DP/环拆链并复制一份 
- AcWing 321  棋盘分割：区间DP/二维平面上的区间DP 
- AcWing 322  消木块：区间DP 
- AcWing 323  战略游戏：树形DP 
- AcWing 324  贿赂FIPA：树形DP/背包类树形DP 
- AcWing 325  计算机：树形DP/二次扫描与换根法 
- AcWing 326  XOR和路径：有后效性/高斯消元/数学期望 
- AcWing 1194  岛和桥：状态压缩DP 
- AcWing 327  玉米田：状态压缩DP/填充网格图形 
- AcWing 328  芯片：状态压缩DP/填充网格图形 
- AcWing 329  围栏障碍训练场：线段树优化DP 
- AcWing 330  估算：堆优化DP/中位数 
- AcWing 331  干草堆：单调队列优化DP/贪心 
- AcWing 332  股票交易：单调队列优化DP 
- AcWing 333  最大子矩阵：单调队列优化DP 
- AcWing 334  K匿名序列：斜率优化 
- AcWing 335  特别行动队：斜率优化 
- AcWing 336  邮局：四边形不等式 
- AcWing 337  扑克牌：计数类DP 
- AcWing 338  计数问题：数位统计DP 
- AcWing 339  圆形数字：数位统计DP

## 0x60 图论

包括最短路、最小生成树、树的直径与最近公共祖先、基环树、负环与差分约束、Tarjan算法与无向图连通性、Tarjan算法与有向图连通性、二分图的匹配、二分图的覆盖与独立集、网络流初步

#### 0x61 最短路

- AcWing 340  通信线路 
- AcWing 341  最优贸易 
- AcWing 342  道路与航线 
- AcWing 343  排序 
- AcWing 344  观光之旅 
- AcWing 345  牛站 

#### 0x62 最小生成树

- AcWing 346  走廊泼水节 
- AcWing 347  野餐规划 
- AcWing 348  沙漠之王 
- AcWing 349  黑暗城堡 

#### 0x63 树的直径与最近公共祖先

- AcWing 350  巡逻 
- AcWing 351  树网的核 
- AcWing 352  闇の連鎖 
- AcWing 353  雨天的尾巴 
- AcWing 354  天天爱跑步 
- AcWing 355  异象石 
- AcWing 356  次小生成树 
- AcWing 357  疫情控制 

#### 0x64 基环树

- AcWing 358  岛屿 
- AcWing 359  创世纪 
- AcWing 360  Freda的传呼机 

#### 0x65  负环与差分约束

- AcWing 361  观光奶牛 
- AcWing 362  区间 

#### 0x66 Tarjan算法与无向图连通性

- AcWing 363  B城 
- AcWing 364  网络 
- AcWing 365  圆桌骑士 
- AcWing 366  看牛 

#### 0x67 Tarjan算法与有向图连通性

- AcWing 367  学校网络2 
- AcWing 368  银河 
- AcWing 369  北大ACM队的远足 
- AcWing 370  卡图难题 
- AcWing 371  牧师约翰最忙碌的一天
 
#### 0x68 二分图的匹配

- AcWing 372  棋盘覆盖 
- AcWing 373  車的放置 
- AcWing 374  导弹防御塔 
- AcWing 375  蚂蚁 

#### 0x69 二分图的覆盖与独立集

- AcWing 376  机器任务 
- AcWing 377  泥泞的区域 
- AcWing 378  骑士放置 
- AcWing 379  捉迷藏 

#### 0x6A 网络流初步

- AcWing 380  舞动的夜晚 
- AcWing 381  有线电视网络 
- AcWing 382  K取方格数
 
#### 0x6B 总结与练习

- AcWing 383  观光：最短路/单源次短路及其条数 
- AcWing 384  升降梯上：最短路/节点扩展到二维
- AcWing 385  GF和猫咪的玩具：最短路/任意两点间最短路
- AcWing 386  社交网络：最短路/任意两点间最短路及其条数 
- AcWing 387  北极网络：最小生成树
- AcWing 388  四叶草魔杖：最小生成树/状态压缩动态规划 
- AcWing 389  直径：树的直径的必须边 
- AcWing 390  逃学的小孩：数的直径 
- AcWing 391  聚会：最近公共祖先 
- AcWing 392  会合：基环树/最近公共祖先 
- AcWing 393  雇佣收银员：差分约束 
- AcWing 394  最优高铁环：负环判定/01分数规划 
- AcWing 395  冗余路径：Tarjan算法/桥 
- AcWing 396  矿场搭建：Tarjan算法/割点 
- AcWing 397  逃不掉的路：边双连通分量/缩点/无向图必经边 
- AcWing 398  交通实时查询系统：点双连通分量/缩点/无向图必经点 
- AcWing 399  约翰的旅行：欧拉路 
- AcWing 400  太鼓达人：欧拉路 
- AcWing 401  从u到v还是从v到u？：强连通分量/缩点 
- AcWing 402  杀人游戏：强连通分量/缩点  
- AcWing 403  平面：2-SAT 
- AcWing 404  婚礼：2-SAT/输出方案 
- AcWing 405  将他们分好队：二分图判定/动态规划 
- AcWing 406  放置机器人：二分图最大匹配 
- AcWing 407  稳定的牛分配：二分图多重匹配 
- AcWing 408  回家：二分图带权匹配 
- AcWing 409  空袭：二分图最小路径点覆盖 
- AcWing 410  排版幻灯片：二分图最大匹配的必须边 
- AcWing 411  国王的任务：二分图最大匹配的可行边 
- AcWing 412  排水沟：最大流 



# 0x00 基本算法(40)

包括位运算、递推、递归、二分、排序、倍增、贪心等算法。

## 0x01位运算
 
##### AcWing89   a^b

```cpp
#include <iostream>
using namespace std;

int main()
{
    int a, b, p;
    cin >> a >> b >> p;

    int res = 1 % p;
    while (b)
    {
        if (b & 1) res = (long long)res * a % p;
        a = (long long)a * a % p;
        b >>= 1;
    }

    cout << res << endl;
    return 0;
}
```
##### AcWing90   64位整数乘法

```cpp
#include <iostream>
using namespace std;

typedef unsigned long long ULL;

int main() {
    ULL a, b, p;
    cin >> a >> b >> p;
    ULL res = 0;
    while (a) {
        if (a & 1) res = (res + b) % p;
        b = (b + b) % p;
        a >>= 1;
    }
    cout << res << endl;
    return 0;
}
```

##### AcWing91   最短Hamilton路径
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 20, M = 1 << 20;

int n;
int f[M][N], weight[N][N];

int main() {
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            cin >> weight[i][j];

    memset(f, 0x3f, sizeof f);
    f[1][0] = 0;
    for (int i = 0; i < 1 << n; i ++ )
        for (int j = 0; j < n; j ++ )
            if (i >> j & 1) {
                for (int k = 0; k < n; k ++ )
                    if (i - (1 << j) >> k & 1) {
                        f[i][j] = min(f[i][j], f[i - (1 << j)][k] + weight[k][j]);
                    }
            }

    cout << f[(1 << n) - 1][n - 1] << endl;
    return 0;
}
```

##### AcWing998   起床困难综合症  

## 0x02递推与递归

**递归回溯**

[[递归与回溯的理解]](https://cloud.tencent.com/developer/article/1434886)  

[[手把手教怎么写递归和回溯]](https://leetcode-cn.com/circle/article/GV6eQ2/)  

递归回溯一般模板：
```cpp
'''
backtracking：使用dfs的模板，基本跟dfs的模板一模一样
'''
class Backtracking(object):

    def backtracking(self, input):

        self.res = []

        def dfs(input, temp, [index]):
            # 边界
            if 非法数据：
                return

            # 终止条件
            if len(input) == len(temp)：
                self.res.append(temp[:])
                return

            # for循环
            for i range(len(input)):
                ##1. 修改path
                temp.append(input[i])
                ##2. backtracking
                dfs(input, temp, [index])
                ##3. 退回原来状态，恢复path
                temp.pop()
        # 执行
        dfs(input, [], 0)
        return self.res
```

##### AcWing92   递归实现指数型枚举

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
int n;
vector<int> chosen; // 被选择的数
void calc(int x) {
	if (x == n + 1) { // 问题边界
		for (int i = 0; i < chosen.size(); i++)
			printf("%d ", chosen[i]);
		puts("");
		return;
	}
    //"不选x"分支
	calc(x + 1); // 求解子问题
	//"选x"分支
	chosen.push_back(x); // 记录x已被选择
	calc(x + 1); // 求解子问题 
	chosen.pop_back(); // 准备回溯到上一问题之前，还原现场
}
int main() {
	cin >> n;
	calc(1);  // 主函数中的调用入口
}
```

yxc

```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

int n;

void dfs(int u, int state)
{
    if (u == n)
    {
        for (int i = 0; i < n; i ++ )
            if (state >> i & 1)
                cout << i + 1 << ' ';
        cout << endl;
        return;
    }

    dfs(u + 1, state);
    dfs(u + 1, state + (1 << u));
}

int main()
{
    cin >> n;
    dfs(0, 0);
    return 0;
}
```

##### AcWing93   递归实现组合型枚举

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
int n, m;
vector<int> chosen; 
void calc(int x) {
	if (chosen.size() > m || chosen.size() + (n - x + 1) < m) return;
	if (x == n + 1) {
		for (int i = 0; i < chosen.size(); i++)
			printf("%d ", chosen[i]);
		puts("");
		return;
	}
	chosen.push_back(x);
	calc(x + 1);
	chosen.pop_back();
	calc(x + 1);
}
int main() {
	cin >> n >> m;
	calc(1);
}
```

yxc
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

int n, m;

void dfs(int u, int s, int state)
{
    if (s == m)
    {
        for (int i = 0; i < n; i ++ )
            if (state >> i & 1)
                cout << i + 1 << ' ';
        cout << endl;
        return;
    }
    if (u == n) return;

    for (int i = u; i < n; i ++ )
    {
        dfs(i + 1, s + 1, state + (1 << i));
    }
}

int main()
{
    cin >> n >> m;
    dfs(0, 0, 0);
    return 0;
}
```

##### AcWing94   递归实现排列型枚举

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
int n;
int order[20]; // 按顺序依次记录被选择的整数
bool chosen[20]; // 标记被选择的整数
void calc(int k) {
	if (k == n + 1) { // 问题边界
		for (int i = 1; i <= n; i++)
			printf("%d ", order[i]);
		puts("");
		return;
	}
	for (int i = 1; i <= n; i++) { 
		if (chosen[i]) continue;
		order[k] = i;
		chosen[i] = 1;
		calc(k + 1); 
		chosen[i] = 0;
		order[k] = 0; // 这一行可以省略
	}
}
int main() { 
	cin >> n;
	calc(1);  // 主函数中的调用入口
}

```
yxc

```cpp
#include <cstring>
#include <vector>
#include <iostream>
#include <algorithm>

using namespace std;

int n;
vector<int> path;

void dfs(int u, int state)
{
    if (u == n)
    {
        for (auto x : path) cout << x << ' ';
        cout << endl;
        return;
    }

    for (int i = 0; i < n; i ++ )
        if (!(state >> i & 1))
        {
            path.push_back(i + 1);
            dfs(u + 1, state + (1 << i));
            path.pop_back();
        }
}

int main()
{
    cin >> n;
    dfs(0, 0);
    return 0;
}
```

##### AcWing95   费解的开关 
```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int INF = 100000;

char g[10][10];
int dx[5] = {0, -1, 0, 1, 0}, dy[5] = {0, 0, 1, 0, -1};

void turn(int x, int y)
{
    for (int i = 0; i < 5; i ++ )
    {
        int a = x + dx[i], b = y + dy[i];
        if (a >= 0 && a < 5 && b >= 0 && b < 5)
        {
            g[a][b] = '0' + !(g[a][b] - '0');
        }
    }
}

int work()
{
    int ans = INF;
    for (int k = 0; k < 1 << 5; k ++ )
    {
        int res = 0;
        char backup[10][10];
        memcpy(backup, g, sizeof g);

        for (int j = 0; j < 5; j ++ )
        {
            if (k >> j & 1)
            {
                res ++ ;
                turn(0, j);
            }
        }

        for (int i = 0; i < 4; i ++ )
            for (int j = 0; j < 5; j ++ )
                if (g[i][j] == '0')
                {
                    res ++ ;
                    turn(i + 1, j);
                }

        bool is_successful = true;
        for (int j = 0; j < 5; j ++ )
            if (g[4][j] == '0')
            {
                is_successful = false;
                break;
            }

        if (is_successful) ans = min(ans, res);

        memcpy(g, backup, sizeof g);
    }

    if (ans > 6) return -1;
    return ans;
}

int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        for (int i = 0; i < 5; i ++ ) cin >> g[i];
        cout << work() << endl;
    }
    return 0;
}
```
##### AcWing96   奇怪的汉诺塔

POJ1958 Strange Towers of Hanoi

```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 15;

int main()
{
    int d[N], f[N];

    memset(f, 0x3f, sizeof f);
    f[0] = 0;

    for (int i = 1; i <= 12; i ++ ) d[i] = (1 << i) - 1;

    for (int i = 1; i <= 12; i ++ )
        for (int j = 0; j < i; j ++ )
            f[i] = min(f[i], f[j] * 2 + d[i - j]);

    for (int i = 1; i <= 12; i ++ ) cout << f[i] << endl;
    return 0;
}
```
##### AcWing97   约数之和
```cpp
#include <iostream>

using namespace std;

const int mod = 9901;

int qmi(int a, int k)
{
    a %= mod;
    int res = 1;
    while (k)
    {
        if (k & 1) res = res * a % mod;
        a = a * a % mod;
        k >>= 1;
    }
    return res;
}

int sum(int p, int k)
{
    if (k == 0) return 1;
    if (k % 2 == 0) return (p % mod * sum(p, k - 1) % mod + 1) % mod;
    return sum(p, k / 2) % mod * (1 + qmi(p, k / 2 + 1)) % mod;
}

int main()
{
    int A, B;
    cin >> A >> B;

    int res = 1;
    for (int i = 2; i <= A; i ++ )
    {
        int s = 0;
        while (A % i == 0)
        {
            s ++ ;
            A /= i;
        }

        if (s) res = res * sum(i, s * B) % mod;
    }

    if (!A) res = 0;
    cout << res << endl;
    return 0;
}
```
##### AcWing98   分形之城

POJ3889
  
```cpp
#include <iostream>
#include <cmath>

using namespace std;

typedef long long LL;
typedef pair<LL, LL> PLL;


PLL calc(LL n, LL m)
{
    if (!n) return {0, 0};
    LL len = 1ll << (n - 1), cnt = 1ll << (2 * n - 2);
    auto pos = calc(n - 1, m % cnt);
    auto x = pos.first, y = pos.second;
    auto z = m / cnt;
    if (z == 0) return {y, x};
    if (z == 1) return {x, y + len};
    if (z == 2) return {x + len, y + len};
    return {len * 2 - 1 - y, len - x - 1};
}


int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        LL N, A, B;
        cin >> N >> A >> B;
        auto ac = calc(N, A - 1);
        auto bc = calc(N, B - 1);
        double x = ac.first - bc.first, y = ac.second - bc.second;
        printf("%.0lf\n", sqrt(x * x + y * y) * 10);
    }
    return 0;
}
```
## 0x03 前缀和与差分

##### AcWing99   激光炸弹
BZOJ1218 

```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 5010;

int n, m;
int s[N][N];

int main()
{
    int cnt, R;
    cin >> cnt >> R;
    R = min(5001, R);

    n = m = 5001;
    while (cnt -- )
    {
        int x, y, w;
        cin >> x >> y >> w;
        x ++, y ++ ;
        s[x][y] += w;
    }

    // 预处理前缀和
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];

    int res = 0;

    // 枚举所有边长是R的矩形，枚举(i, j)为右下角
    for (int i = R; i <= n; i ++ )
        for (int j = R; j <= m; j ++ )
            res = max(res, s[i][j] - s[i - R][j] - s[i][j - R] + s[i - R][j - R]);

    cout << res << endl;

    return 0;
}
```
 
##### AcWing100   IncDec序列
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 500010;

int n;
int a[N];

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++ ) cin >> a[i];
    for (int i = n; i; i -- ) a[i] -= a[i - 1];

    LL pos = 0, neg = 0;
    for (int i = 2; i <= n; i ++ )
        if (a[i] > 0) pos += a[i];
        else neg -= a[i];

    cout << min(pos, neg) + abs(pos - neg) << endl;
    cout << abs(pos - neg) + 1 << endl;

    return 0;
}
```
   
##### AcWing101   最高的牛
```cpp
#include <iostream>
#include <algorithm>
#include <set>

using namespace std;

const int N = 10010;

int d[N];

int main()
{
    int n, p, h, m;
    set<pair<int, int>> existed;
    cin >> n >> p >> h >> m;
    d[1] = h;
    for (int i = 0, a, b; i < m; i ++ )
    {
        cin >> a >> b;
        if (a > b) swap(a, b);
        if (!existed.count({a, b}))
        {
            existed.insert({a, b});
            d[a + 1] --, d[b] ++ ;
        }
    }

    for (int i = 1; i <= n; i ++ )
    {
        d[i] += d[i - 1];
        cout << d[i] << endl;
    }
    return 0;
}
```
## 0x04  二分和三分
 
##### AcWing102   最佳牛围栏

```cpp
#include <iostream>

using namespace std;

const int N = 100010;

int n, m;
int cows[N];
double sum[N];

bool check(double avg)
{
    for (int i = 1; i <= n; i ++ )
        sum[i] = sum[i - 1] + cows[i] - avg;

    double mins = 0;
    for (int i = m, j = 0; i <= n; i ++, j ++ )
    {
        mins = min(mins, sum[j]);
        if (sum[i] - mins >= 0) return true;
    }

    return false;
}

int main()
{
    cin >> n >> m;
    double l = 0, r = 0;
    for (int i = 1; i <= n; i ++ )
    {
        cin >> cows[i];
        r = max(r, (double)cows[i]);
    }

    while (r - l > 1e-5)
    {
        double mid = (l + r) / 2;
        if (check(mid)) l = mid;
        else r = mid;
    }

    printf("%d\n", (int)(r * 1000));

    return 0;
}
```
   
##### AcWing113   特殊排序
```cpp
// Forward declaration of compare API.
// bool compare(int a, int b);
// return bool means whether a is less than b.

class Solution {
public:
    vector<int> specialSort(int n) {
        vector<int> res;
        res.push_back(1);
        for (int i = 2; i <= n; i ++ )
        {
            int l = 0, r = res.size() - 1;
            while (l < r)
            {
                int mid = l + r + 1 >> 1;
                if (compare(res[mid], i)) l = mid;
                else r = mid - 1;
            }
            res.push_back(i);
            for (int j = res.size() - 2; j > r; j -- ) swap (res[j], res[j + 1]);
            if (!compare(res[r], i)) swap(res[r], res[r + 1]);
        }
        return res;
    }
};
```
 

## 0x05 双指针与排序


##### AcWing103   电影

CF670C Cinema

```cpp
//Author:XuHt
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 200006;
int n, m, a[N], x[N], y[N], cinema[N*3], tot = 0, k, ans[N*3];

int find(int f) {
	return lower_bound(cinema + 1, cinema + k + 1, f) - cinema;
}

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
		cinema[++tot] = a[i];
	}
	cin >> m;
	for (int i = 1; i <= m; i++) {
		scanf("%d", &x[i]);
		cinema[++tot] = x[i];
	}
	for (int i = 1; i <= m; i++) {
		scanf("%d", &y[i]);
		cinema[++tot] = y[i];
	}
	sort(cinema + 1, cinema + tot + 1);
	k = unique(cinema + 1, cinema + tot + 1) - (cinema + 1);
	memset(ans, 0, sizeof(ans));
	for (int i = 1; i <= n; i++) ans[find(a[i])]++;
	int ans0 = 1, ans1 = 0, ans2 = 0;
	for (int i = 1; i <= m; i++) {
		int ansx = ans[find(x[i])], ansy = ans[find(y[i])];
		if (ansx > ans1 || (ansx == ans1 && ansy > ans2)) {
			ans0 = i;
			ans1 = ansx;
			ans2 = ansy;
		}
	}
	cout << ans0 << endl;
	return 0;
}

```
 
##### AcWing104   货仓选址

CH0501 货仓选址

```cpp
//Author:XuHt
#include <cstdio>
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;
const int N = 100006;
int n, a[N];

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	sort(a + 1, a + n + 1);
	ll ans = 0;
	for (int i = 1; i <= n / 2; i++)
		ans += a[n-i+1] - a[i];
	cout << ans << endl;
	return 0;
}
```
   
##### AcWing105   七夕祭

BZOJ3032／CH0502 七夕祭

```cpp
//Author:XuHt
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;
const int N = 100006;
int n, m, t, x[N], y[N], a[N], s[N];

int main() {
	cin >> n >> m >> t;
	for (int i = 1; i <= t; i++) scanf("%d %d", &x[i], &y[i]);
	bool row = !(t % n), column = !(t % m);
	if (row) {
		if (column) cout << "both ";
		else cout << "row ";
	} else {
		if (column) cout << "column ";
		else {
			cout << "impossible" << endl;
			return 0;
		}
	}
	ll ans = 0;
	if (row) {
		int num = t / n;
		memset(a, 0, sizeof(a));
		for (int i = 1; i <= t; i++) a[x[i]]++;
		for (int i = 1; i <= n; i++) a[i] -= num;
		s[0] = 0;
		for (int i = 1; i <= n; i++) s[i] = s[i-1] + a[i];
		sort(s + 1, s + n + 1);
		for (int i = 1; i <= n / 2; i++) ans += s[n-i+1] - s[i];
	}
	if (column) {
		int num = t / m;
		memset(a, 0, sizeof(a));
		for (int i = 1; i <= t; i++) a[y[i]]++;
		for (int i = 1; i <= m; i++) a[i] -= num;
		s[0] = 0;
		for (int i = 1; i <= m; i++) s[i] = s[i-1] + a[i];
		sort(s + 1, s + m + 1);
		for (int i = 1; i <= m / 2; i++) ans += s[m-i+1] - s[i];
	}
	cout << ans << endl;
	return 0;
}
```
  
##### AcWing106   动态中位数
```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
#include <cstring>

using namespace std;

typedef pair<int,int> PII;

const int N = 10010;

int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        int m, n;
        cin >> m >> n;
        priority_queue<int> max_heap;
        priority_queue<int, vector<int>, greater<int>> min_heap;

        printf("%d %d\n", m, (n + 1) / 2);
        int cnt = 0;
        for (int i = 0; i < n; i ++ )
        {
            int t;
            scanf("%d", &t);
            max_heap.push(t);
            if (min_heap.size() && min_heap.top() < max_heap.top())
            {
                auto a = min_heap.top(), b = max_heap.top();
                min_heap.pop(), max_heap.pop();
                min_heap.push(b), max_heap.push(a);
            }

            if (max_heap.size() > min_heap.size() + 1)
            {
                min_heap.push(max_heap.top());
                max_heap.pop();
            }

            if (!(i & 1))
            {
                printf("%d ", max_heap.top());
                if ( ++ cnt % 10 == 0) puts("");
            }
        }

        if (cnt % 10) puts("");
    }

    return 0;
}
```
   
##### AcWing107   超快速排序
```cpp
//Author:XuHt
#include <cstdio>
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;
const int N = 500006;
int n, a[N], b[N];
ll ans;

void merge(int l, int mid, int r) {
	if (l == r) return;
	if (l + 1 == r) {
		if (a[l] > a[r]) {
			ans++;
			swap(a[l], a[r]);
		}
		return;
	}
	merge(l, (l + mid) >> 1, mid);
	merge(mid + 1, (mid + 1 + r) >> 1, r);
	int i = l, j = mid + 1;
	for (int k = l; k <= r; k++)
		if (j > r || (i <= mid && a[i] <= a[j])) b[k] = a[i++];
		else {
			b[k] = a[j++];
			ans += mid - i + 1;
		}
	for (int k = l; k <= r; k++) a[k] = b[k];
}

void Ultra_QuickSort() {
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	ans = 0;
	merge(1, (1 + n) >> 1, n);
	cout << ans << endl;
}

int main() {
	while (cin >> n && n) Ultra_QuickSort();
	return 0;
}

```
   
##### AcWing108   奇数码问题
```cpp
using namespace std;
int n, c[1000010];
vector<int> a,b;

int ask(int x)
{
	int y=0;
	for(;x;x-=x&-x) y+=c[x];
	return y;
}

void add(int x)
{
	for(;x<=n*n-1;x+=x&-x) c[x]++;
}

long long calc(vector<int> a)
{
	long long ans=0;
	memset(c,0,sizeof(c));
	for(int i=a.size()-1;i>=0;i--)
	{
		ans+=ask(a[i]);
		add(a[i]);
	}
	return ans;
}

int main()
{
	freopen("data.in","r",stdin);
	freopen("data.out","w",stdout); 
	while(cin>>n)
	{
		a.clear();
		b.clear();
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
			{
				int x;
				scanf("%d",&x);
				if(x) a.push_back(x);
			}
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
			{
				int x;
				scanf("%d",&x);
				if(x) b.push_back(x);
			}
		puts(calc(a)-calc(b)&1 ? "NIE" : "TAK");
	}
}

```

std2

```cpp
#include<algorithm>
#include<vector>
using namespace std;
int n;
long long ans;
vector<int> a[2];
int c[250010];

void merge(int k, int l, int mid, int r)
{
	int x = l, y = mid + 1;
	for (int i = l; i <= r; i++)
	{
		if (y>r || x <= mid&&a[k][x]<a[k][y])
			c[i] = a[k][x++];
		else ans += mid - x + 1, c[i] = a[k][y++];
	}
	for (int i = l; i <= r; i++) a[k][i] = c[i];
}

void mergesort(int k, int l, int r)
{
	if (l == r) return;
	int mid = (l + r) / 2;
	mergesort(k, l, mid);
	mergesort(k, mid + 1, r);
	merge(k, l, mid, r);
}

long long calc(int k)
{
	ans = 0;
	mergesort(k, 0, n*n - 1);
	return ans;
}

int main()
{
	while (cin >> n)
	{
		a[0].clear();
		a[1].clear();
		for (int i = 1; i <= n; i++)for (int j = 1; j <= n; j++)
		{
			int x; scanf("%d", &x); if (x) a[0].push_back(x);
		}
		for (int i = 1; i <= n; i++)for (int j = 1; j <= n; j++)
		{
			int x; scanf("%d", &x); if (x) a[1].push_back(x);
		}
		puts(a[0].size()&&(calc(1) - calc(0) & 1) ? "NIE" : "TAK");
	}
}

```

## 0x06 倍增

##### AcWing109   天才ACM

CH0601 Genius ACM


```cpp
//Author:XuHt
#include <cstdio>
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;
const int N = 500006;
int n, m, w;
ll k, a[N], b[N], c[N];

void gb(int l, int mid, int r) {
	int i = l, j = mid + 1;
	for (int k = l; k <= r; k++)
		if (j > r || (i <= mid && b[i] <= b[j])) c[k] = b[i++];
		else c[k] = b[j++];
}

ll f(int l, int r) {
	if (r > n) r = n;
	int t = min(m, (r - l + 1) >> 1);
	for (int i = w + 1; i <= r; i++) b[i] = a[i];
	sort(b + w + 1, b + r + 1);
	gb(l, w, r);
	ll ans = 0;
	for (int i = 0; i < t; i++)
		ans += (c[r-i] - c[l+i]) * (c[r-i] - c[l+i]);
	return ans;
}

void Genius_ACM() {
	cin >> n >> m;
	cin >> k;
	for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
	int ans = 0, l = 1, r = 1;
	w = 1;
	b[1] = a[1];
	while (l <= n) {
		int p = 1;
		while (p) {
			ll num = f(l, r + p);
			if (num <= k) {
				w = r = min(r + p, n);
				for (int i = l; i <= r; i++) b[i] = c[i];
				if (r == n) break;
				p <<= 1;
			} else p >>= 1;
		}
		ans++;
		l = r + 1;
	}
	cout << ans << endl;
}

int main() {
	int t;
	cin >> t;
	while (t--) Genius_ACM();
	return 0;
}

```
  

## 0x07 贪心

     
##### AcWing110   防晒

POJ3614 Sunscreen

匈牙利算法（简单易懂）：https://blog.csdn.net/sunny_hun/article/details/80627351

```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <map>

using namespace std;

typedef pair<int,int> PII;
const int N = 2510;

int n, m;
PII cows[N];

int main()
{
    cin >> n >> m;
    map<int, int> spfs;
    for (int i = 0; i < n; i ++ ) cin >> cows[i].first >> cows[i].second;
    for (int i = 0; i < m; i ++ )
    {
        int spf, cover;
        cin >> spf >> cover;
        spfs[spf] += cover;
    }
    sort(cows, cows + n);
    int res = 0;
    spfs[0] = spfs[1001] = n;
    for (int i = n - 1; i >= 0; i -- )
    {
        auto spf = spfs.upper_bound(cows[i].second);
        spf --;
        if (spf->first >= cows[i].first && spf->first <= cows[i].second)
        {
            res ++ ;
            if (--spf->second == 0)
                spfs.erase(spf);
        }
    }
    cout << res << endl;
    return 0;
}
```
   
##### AcWing111   畜栏预定
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>

using namespace std;

typedef pair<int,int> PII;
const int N = 50010;

int n;
int id[N];
pair<PII, int> cows[N];

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
    {
        cin >> cows[i].first.first >> cows[i].first.second;
        cows[i].second = i;
    }

    sort(cows, cows + n);

    priority_queue<PII, vector<PII>, greater<PII>> heap;
    for (int i = 0; i < n; i ++ )
    {
        if (heap.empty() || heap.top().first >= cows[i].first.first)
        {
            PII stall = {cows[i].first.second, heap.size()};
            id[cows[i].second] = stall.second;
            heap.push(stall);
        }
        else
        {
            auto stall = heap.top();
            heap.pop();
            stall.first = cows[i].first.second;
            id[cows[i].second] = stall.second;
            heap.push(stall);
        }
    }

    cout << heap.size() << endl;
    for (int i = 0; i < n; i ++ ) cout << id[i] + 1 << endl;
    return 0;
}
```
   
##### AcWing112   雷达设备
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

typedef pair<double, double> PDD;
const int N = 1010;
const double eps = 1e-6, INF = 1e10;

int n, d;
PDD seg[N];

int main()
{
    cin >> n >> d;

    bool success = true;

    for (int i = 0; i < n; i ++ )
    {
        int x, y;
        cin >> x >> y;
        if (y > d)
        {
            success = false;
            break;
        }
        auto len = sqrt(d * d - y * y);
        seg[i] = {x + len, x - len};
    }

    if (!success) puts("-1");
    else
    {
        sort(seg, seg + n);
        int res = 0;
        double last = -INF;
        for (int i = 0; i < n; i ++ )
        {
            if (seg[i].second > last + eps)
            {
                res ++ ;
                last = seg[i].first;
            }
        }
        cout << res << endl;
    }
    return 0;
}
```
   
##### AcWing114   国王游戏
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

typedef pair<int, int> PII;
const int N = 1010;

int n;
PII p[N];

vector<int> mul(vector<int>a, int b)
{
    vector<int> c;
    int t = 0;
    for (int i = 0; i < a.size(); i ++ )
    {
        t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }
    while (t)
    {
        c.push_back(t % 10);
        t /= 10;
    }
    return c;
}

vector<int> div(vector<int>a, int b)
{
    vector<int> c;
    bool is_first = true;
    for (int i = a.size() - 1, t = 0; i >= 0; i -- )
    {
        t = t * 10 + a[i];
        int x = t / b;
        if (!is_first || x)
        {
            is_first = false;
            c.push_back(x);
        }
        t %= b;
    }
    reverse(c.begin(), c.end());
    return c;
}

vector<int> max_vec(vector<int> a, vector<int> b)
{
    if (a.size() > b.size()) return a;
    if (a.size() < b.size()) return b;
    if (vector<int>(a.rbegin(), a.rend()) > vector<int>(b.rbegin(), b.rend())) return a;
    return b;
}

int main()
{
    cin >> n;
    for (int i = 0; i <= n; i ++ )
    {
        int a, b;
        cin >> a >> b;
        p[i] = {a * b, a};
    }
    sort(p + 1, p + n + 1);

    vector<int> product(1, 1);

    vector<int> res(1, 0);
    for (int i = 0; i <= n; i ++ )
    {
        if (i) res = max_vec(res, div(product, p[i].first / p[i].second));
        product = mul(product, p[i].second);
    }

    for (int i = res.size() - 1; i >= 0; i -- ) cout << res[i];
    cout << endl;

    return 0;
}
```
   
##### AcWing115   给树染色
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace  std;

const int N = 1010;

int n, root;
struct Node
{
    int p, s, v;
    double avg;
}nodes[N];

int find()
{
    double avg = 0;
    int res = -1;
    for (int i = 1; i <= n; i ++ )
        if (i != root && nodes[i].avg > avg)
        {
            avg = nodes[i].avg;
            res = i;
        }
    return res;
}

int main()
{
    cin >> n >> root;
    int ans = 0;
    for (int i = 1; i <= n; i ++ )
    {
        cin >> nodes[i].v;
        nodes[i].avg = nodes[i].v;
        nodes[i].s = 1;
        ans += nodes[i].v;
    }
    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b;
        cin >> a >> b;
        nodes[b].p = a;
    }

    for (int i = 0; i < n - 1; i ++ )
    {
        int p = find();
        int father = nodes[p].p;
        ans += nodes[p].v * nodes[father].s;
        nodes[p].avg = -1;
        for (int j = 1; j <= n; j ++ )
            if (nodes[j].p == p)
                nodes[j].p = father;
        nodes[father].v += nodes[p].v;
        nodes[father].s += nodes[p].s;
        nodes[father].avg = (double)nodes[father].v / nodes[father].s;
    }

    cout << ans << endl;
    return 0;
}
```

## 0x08 总结与练习

##### AcWing116   飞行员兄弟
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

typedef pair<int,int> PII;
const int N = 4, INF = 100;

int change[N][N];

int get(int x, int y)
{
    return x * N + y;
}

int main()
{
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
        {
            for (int k = 0; k < N; k ++ ) change[i][j] += (1 << get(i, k)) + (1 << get(k, j));
            change[i][j] -= 1 << get(i, j);
        }

    int state = 0;
    for (int i = 0; i < N; i ++ )
    {
        string line;
        cin >> line;
        for (int j = 0; j < N; j ++ )
            if (line[j] == '+')
                state += 1 << get(i, j);
    }

    vector<PII> path, temp;
    for (int i = 0; i < 1 << 16; i ++ )
    {
        int now = state;
        temp.clear();
        for (int j = 0; j < 16; j ++ )
            if (i >> j & 1)
            {
                int x = j / 4, y = j % 4;
                now ^= change[x][y];
                temp.push_back({x, y});
            }
        if (!now && (path.empty() || path.size() > temp.size())) path = temp;
    }

    cout << path.size() << endl;
    for (auto &p : path)
        cout << p.first + 1 << ' ' << p.second + 1 << endl;

    return 0;
}
```
##### AcWing117   占卜DIY
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

vector<int> closed[14];
int open[14];

int main()
{
    for (int i = 1; i <= 13; i ++ )
    {
        for (int j = 0; j < 4; j ++ )
        {
            int x;
            char s[2];
            cin >> s;
            if (*s >= '2' && *s <= '9') x = *s - '0';
            else if (*s == '0') x = 10;
            else if (*s == 'A') x = 1;
            else if (*s == 'J') x = 11;
            else if (*s == 'Q') x = 12;
            else x = 13;
            closed[i].push_back(x);
        }
    }

    for (int i = 0; i < 4; i ++ )
    {
        int t = closed[13][i];
        while (t != 13)
        {
            open[t] ++ ;
            int r = t;
            t = closed[r].back();
            closed[r].pop_back();
        }
    }

    int res = 0;
    for (int i = 1; i <= 12; i ++ ) res += open[i] >= 4;
    cout << res << endl;

    return 0;
}
```  
##### AcWing118   分形
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

char g[N][N];

void dfs(int n)
{
    if (n == 1)
    {
        g[0][0] = 'X';
        return;
    }

    dfs(n - 1);

    int len = 1;
    for (int i = 0; i < n - 2; i ++ ) len *= 3;
    int sx[4] = {0, 1, 2, 2}, sy[4] = {2, 1, 0, 2};
    for (int k = 0; k < 4; k ++ )
        for (int i = 0; i < len; i ++ )
            for (int j = 0; j < len; j ++ )
                g[sx[k] * len + i][sy[k] * len + j] = g[i][j];
}

int main()
{
    dfs(7);
    int n;
    while (cin >> n, n != -1)
    {
        int k = 1;
        while ( -- n) k *= 3;

        for (int i = 0; i < k; i ++ )
        {
            for (int j = 0; j < k; j ++ )
                if (g[i][j]) cout << g[i][j];
                else cout << ' ';
            cout << endl;
        }
        cout << '-' << endl;
    }
    return 0;
}
```  
##### AcWing119   袭击
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <cmath>

using namespace std;

const int N = 200010, INF = 1e10;

struct Point
{
    double x, y;
    bool type;

    bool operator< (const Point &W)const
    {
        return x < W.x;
    }
};

Point points[N], temp[N];

double dist(Point a, Point b)
{
    if (a.type == b.type) return INF;
    double dx = a.x - b.x, dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
}

double dfs(int l, int r)
{
    if (l >= r) return INF;

    int mid = l + r >> 1;
    double mid_x = points[mid].x;
    double res = min(dfs(l, mid), dfs(mid + 1, r));

    {
        int k = 0, i = l, j = mid + 1;
        while (i <= mid && j <= r)
            if (points[i].y < points[j].y) temp[k ++ ] = points[i ++ ];
            else temp[k ++ ] = points[j ++ ];
        while (i <= mid) temp[k ++ ] = points[i ++ ];
        while (j <= r) temp[k ++ ] = points[j ++ ];

        for (i = 0, j = l; i < k; i ++, j ++ ) points[j] = temp[i];
    }

    int k = 0;
    for (int i = l; i <= r; i ++ )
        if (points[i].x >= mid_x - res && points[i].x <= mid_x + res)
            temp[k ++ ] = points[i];

    for (int i = 0; i < k; i ++ )
        for (int j = i - 1; j >= 0 && temp[i].y - temp[j].y < res; j -- )
            res = min(res, dist(temp[i], temp[j]));

    return res;
}

int main()
{
    int T, n;
    cin >> T;

    while (T -- )
    {
        scanf("%d", &n);
        for (int i = 0; i < n; i ++ )
        {
            scanf("%lf%lf", &points[i].x, &points[i].y);
            points[i].type = 0;
        }
        for (int i = n; i < 2 * n; i ++ )
        {
            scanf("%lf%lf", &points[i].x, &points[i].y);
            points[i].type = 1;
        }

        sort(points, points + n * 2);

        printf("%.3lf\n", dfs(0, n * 2 - 1));
    }

    return 0;
}
```  
##### AcWing120   防线
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;
const int N = 200010;

struct Seq
{
    int s, e, d;
}seqs[N];

int n;

LL get_sum(int x)
{
    LL res = 0;
    for (int i = 0; i < n; i ++ )
        if (seqs[i].s <= x)
            res += (min(seqs[i].e, x) - seqs[i].s) / seqs[i].d + 1;
    return res;
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        int l = 0, r = 0;
        scanf("%d", &n);
        for (int i = 0; i < n; i ++ )
        {
            int s, e, d;
            scanf("%d%d%d", &s, &e, &d);
            seqs[i] = {s, e, d};
            r = max(r, e);
        }

        while (l < r)
        {
            int mid = (LL)l + r >> 1;
            if (get_sum(mid) & 1) r = mid;
            else l = mid + 1;
        }

        auto sum = get_sum(r) - get_sum(r - 1);
        if (sum % 2) printf("%d %lld\n", r, sum);
        else puts("There's no weakness.");
    }

    return 0;
}
```  
##### AcWing121   赶牛入圈
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

typedef pair<int,int> PII;
const int N = 1010;

int n, m;
PII points[N];
int sum[N][N];
vector<int> numbers;

bool check(int len)
{
    for (int x1 = 0, x2 = 1; x2 < numbers.size(); x2 ++ )
    {
        while (numbers[x2] - numbers[x1 + 1] + 1 > len) x1 ++ ;
        for (int y1 = 0, y2 = 1; y2 < numbers.size(); y2 ++ )
        {
            while (numbers[y2] - numbers[y1 + 1] + 1 > len) y1 ++ ;
            if (sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1] >= m)
                return true;
        }
    }
    return false;
}

int get(int x)
{
    int l = 0, r = numbers.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (numbers[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r;
}

int main()
{
    cin >> m >> n;
    numbers.push_back(0);
    for (int i = 0; i < n; i ++ )
    {
        int x, y;
        cin >> x >> y;
        numbers.push_back(x);
        numbers.push_back(y);
        points[i] = {x, y};
    }
    sort(numbers.begin(), numbers.end());
    numbers.erase(unique(numbers.begin(), numbers.end()), numbers.end());

    for (int i = 0; i < n; i ++ )
    {
        int x = get(points[i].first), y = get(points[i].second);
        sum[x][y] ++ ;
    }

    for (int i = 1; i < numbers.size(); i ++ )
        for (int j = 1; j < numbers.size(); j ++ )
            sum[i][j] += sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];

    int l = 1, r = 10000;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    cout << r << endl;

    return 0;
}
```  
##### AcWing122   糖果传递
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;
const int N = 1000010;

int n;
LL a[N];

int main()
{
    scanf("%d", &n);
    LL sum = 0;
    for (int i = 1; i <= n; i ++ )
    {
        scanf("%lld", &a[i]);
        sum += a[i];
    }
    sum /= n;
    for (int i = n; i > 1; i -- )
    {
        a[i] = a[i] - sum + a[i + 1];
    }
    a[1] = 0;
    sort(a + 1, a + n + 1);

    LL res = 0;
    for (int i = 1; i <= n; i ++ ) res += abs(a[i] - a[(n + 1) / 2]);
    cout << res << endl;

    return 0;
}
```  
##### AcWing123   士兵
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10010;

int n;
int x[N], y[N];

int work(int *q)
{
    sort(q, q + n);
    int res = 0;
    for (int i = 0; i < n; i ++ ) res += abs(q[i] - q[n / 2]);
    return res;
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ ) cin >> x[i] >> y[i];
    sort (x, x + n);
    for (int i = 0; i < n; i ++ ) x[i] -= i;

    cout << work(x) + work(y) << endl;

    return 0;
}
```  
##### AcWing124   数的进制转换
```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        int a, b;
        string line;
        cin >> a >> b >> line;
        vector<int> number;
        for (auto c : line)
        {
            if (c <= '9') number.push_back(c - '0');
            else if (c <= 'Z') number.push_back(c - 'A' + 10);
            else number.push_back(c - 'a' + 36);
        }
        reverse(number.begin(), number.end());
        vector<int> res;
        while (number.size())
        {
            int t = 0;
            for (int i = number.size() - 1; i >= 0; i -- )
            {
                number[i] += t * a;
                t = number[i] % b;
                number[i] /= b;
            }
            res.push_back(t);
            while (number.size() && !number.back()) number.pop_back();
        }
        reverse(res.begin(), res.end());
        string b_line;
        for (auto x : res)
        {
            if (x <= 9) b_line += char('0' + x);
            else if (x <= 35) b_line += char('A' + x - 10);
            else b_line += char('a' + x - 36);
        }
        cout << a << ' ' << line << endl;
        cout << b << ' ' << b_line << endl;
        cout << endl;
    }
    return 0;
}
```  
##### AcWing125   耍杂技的牛
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;
typedef pair<LL, LL> PLL;

const int N = 50010;

int n;
PLL cows[N];

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
    {
        int w, s;
        cin >> w >> s;
        cows[i] = {w + s, w};
    }
    sort(cows, cows + n);

    LL sum = 0, res = -1e18;
    for (int i = 0; i < n; i ++ )
    {
        res = max(res, sum - (cows[i].first - cows[i].second));
        sum += cows[i].second;
    }
    cout << res << endl;
    return 0;
}
```  
##### AcWing126   最大的和
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 110;

int n;
int g[N][N];

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
        {
            cin >> g[i][j];
            g[i][j] += g[i - 1][j];
        }

    int res = INT_MIN;
    for (int i = 1; i <= n; i ++ )
        for (int j = i; j <= n; j ++ )
        {
            int last = 0;
            for (int k = 1; k <= n; k ++ )
            {
                last = max(last, 0) + g[j][k] - g[i - 1][k];
                res = max(res, last);
            }
        }

    cout << res << endl;
    return 0;
}
```  
##### AcWing127   任务
```cpp
#include <iostream>
#include <algorithm>
#include <set>

using namespace std;

typedef long long LL;
typedef pair<int, int> PII;

const int N = 100010;

int n, m;
PII mchs[N], tasks[N];

int main()
{
    while (cin >> n >> m)
    {
        for (int i = 0; i < n; i ++ ) cin >> mchs[i].first >> mchs[i].second;
        for (int i = 0; i < m; i ++ ) cin >> tasks[i].first >> tasks[i].second;
        sort(mchs, mchs + n);
        sort(tasks, tasks + m);
        multiset<int> ys;
        LL cnt = 0, res = 0;
        for (int i = m - 1, j = n - 1; i >= 0; i -- )
        {
            while (j >= 0 && mchs[j].first >= tasks[i].first) ys.insert(mchs[j -- ].second);
            auto it = ys.lower_bound(tasks[i].second);
            if (it != ys.end())
            {
                cnt ++ ;
                res += 500 * tasks[i].first + 2 * tasks[i].second;
                ys.erase(it);
            }
        }
        cout << cnt << ' ' << res << endl;
    }
    return 0;
}
```  


# 0x10 基本数据结构完成情况(37)

包括栈、队列、链表与邻接表、Hash、字符串、Trie、二叉堆等内容。

## 0x11 栈/单调栈

##### AcWing41   包含min函数的栈
```cpp
class MinStack {
public:
    /** initialize your data structure here. */

    stack<int> stk, stk_min;

    MinStack() {

    }

    void push(int x) {
        stk.push(x);
        if (stk_min.size()) x = min(x, stk_min.top());
        stk_min.push(x);
    }

    void pop() {
        stk.pop();
        stk_min.pop();
    }

    int top() {
        return stk.top();
    }

    int getMin() {
        return stk_min.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```
##### AcWing128   编辑器
```cpp
#include <iostream>
#include <limits.h>

using namespace std;

const int N = 1000010;

int stkl[N], stkr[N], topl, topr;
int f[N], sum[N];

void add(int x)
{
    stkl[ ++ topl] = x;
    sum[topl] = sum[topl - 1] + x;
    f[topl] = max(f[topl - 1], sum[topl]);
}

int main()
{
    int n;
    scanf("%d", &n);
    char ops[2];
    f[0] = INT_MIN;
    while (n -- )
    {
        int x;
        scanf("%s", ops);
        if (*ops == 'I')
        {
            scanf("%d", &x);
            add(x);
        }
        else if (*ops == 'D')
        {
            if (topl) topl -- ;
        }
        else if (*ops == 'L')
        {
            if (topl) stkr[ ++ topr] = stkl[topl -- ];
        }
        else if (*ops == 'R')
        {
            if (topr) add(stkr[topr -- ]);
        }
        else
        {
            scanf("%d", &x);
            printf("%d\n", f[x]);
        }
    }
    return 0;
}
```  
##### AcWing129   火车进栈
```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <stack>

using namespace std;

int n, remain = 20;
vector<int> path;
stack<int> stk;

void dfs(int u)
{
    if (!remain) return;
    if (path.size() == n)
    {
        remain -- ;
        for (auto x : path) cout << x;
        cout << endl;
        return;
    }
    if (stk.size())
    {
        path.push_back(stk.top());
        stk.pop();
        dfs(u);
        stk.push(path.back());
        path.pop_back();
    }
    if (u <= n)
    {
        stk.push(u);
        dfs(u + 1);
        stk.pop();
    }
}

int main()
{
    cin >> n;
    dfs(1);
    return 0;
}

```  
##### AcWing130   火车进出栈问题
```cpp
#include <iostream>
#include <vector>

using namespace std;

typedef long long LL;
const int N = 6000010, M = 120010;


LL res[N], tt;
int q[M];
bool st[M];

void multi(int b)
{
    LL t = 0;
    for (int i = 0; i <= tt; i ++ )
    {
        res[i] = res[i] * b + t;
        t = res[i] / 1000000000;
        res[i] %= 1000000000;
    }
    while (t)
    {
        res[++tt] = t % 1000000000;
        t /= 1000000000;
    }
}

void out()
{
    printf("%lld", res[tt]);
    for (int i = tt - 1; i >= 0; i -- ) printf("%09lld", res[i]);
    cout << endl;
}

int get(int n, int p)
{
    int s = 0;
    while (n) s += n / p, n /= p;
    return s;
}

int main()
{
    int n;
    cin >> n;
    for (int i = 2; i <= 2 * n; i ++ )
        for (int j = i + i; j <= 2 * n; j += i)
            st[j] = true;

    for (int i = 2; i <= n * 2; i ++ )
        if (!st[i])
        {
            q[i] = get(n * 2, i) - get(n * 2 - n, i) * 2;
        }

    int k = n + 1;
    for (int i = 2; i <= k; i ++ )
        while (k % i == 0)
        {
            k /= i;
            q[i] -- ;
        }

    res[0] = 1;

    for (int i = 2; i <= n * 2; i ++ )
        while (q[i] -- )
            multi(i);

    out();

    return 0;
}
```  
##### AcWing131   直方图中最大的矩形
```cpp
#include <iostream>
#include <algorithm>
#include <stack>
#include <limits.h>

using namespace std;

typedef long long LL;
const int N = 100010;

int n;
int h[N], l[N], r[N];

void get(int *last)
{
    stack<int> stk;
    h[0] = -1;
    stk.push(0);
    for (int i = 1; i <= n; i ++ )
    {
        while (h[stk.top()] >= h[i]) stk.pop();
        last[i] = stk.top() + 1;
        stk.push(i);
    }
}

int main()
{
    while (cin >> n, n)
    {
        for (int i = 1; i <= n; i ++ ) scanf("%d", &h[i]);

        get(l);
        reverse(h + 1, h + 1 + n);
        get(r);

        LL res = 0;
        for (int i = 1, j = n; i <= n; i ++, j -- )
            res = max(res, (LL)h[i] * (n - l[j] + 1 - r[i] + 1));
        printf("%lld\n", res);
    }
    return 0;
}
```  

## 0x12 队列/单调队列

##### AcWing132   小组队列 
```cpp
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 1010, M = 1000010;

int teamid[M];

int main()
{
    int n, C = 1;
    while (cin >> n, n)
    {
        queue<int> team;
        queue<int> person[N];
        printf("Scenario #%d\n", C ++ );
        for (int i = 0; i < n; i ++ )
        {
            int cnt;
            cin >> cnt;
            while (cnt -- )
            {
                int x;
                cin >> x;
                teamid[x] = i;
            }
        }

        string command;
        while (cin >> command, command != "STOP")
        {
            if (command == "ENQUEUE")
            {
                int x;
                cin >> x;
                int tid = teamid[x];
                if (person[tid].empty()) team.push(tid);
                person[tid].push(x);
            }
            else
            {
                int tid = team.front();
                auto &q = person[tid];
                cout << q.front() << endl;
                q.pop();
                if (q.empty()) team.pop();
            }
        }
        cout << endl;
    }

    return 0;
}
``` 
##### AcWing133   蚯蚓
```cpp
#include <iostream>
#include <algorithm>
#include <limits.h>

using namespace std;

const int N = 100010, M = 7000010;

int n, m, q, u, v, t;
int q1[N], q2[M], q3[M];
int delta;
int hh1, hh2, hh3, tt1, tt2 = -1, tt3 = -1;

int get_max()
{
    int x = INT_MIN;
    if (hh1 <= tt1) x = max(x, q1[hh1]);
    if (hh2 <= tt2) x = max(x, q2[hh2]);
    if (hh3 <= tt3) x = max(x, q3[hh3]);
    if (hh1 <= tt1 && x == q1[hh1]) hh1 ++ ;
    else if (hh2 <= tt2 && x == q2[hh2]) hh2 ++ ;
    else hh3 ++ ;
    return x;
}

int main()
{
    scanf("%d%d%d%d%d%d", &n, &m, &q, &u, &v, &t);
    for (int i = 0; i < n; i ++ ) scanf("%d", &q1[i]);
    sort(q1, q1 + n);
    reverse(q1, q1 + n);
    tt1 = n - 1;
    for (int i = 1; i <= m; i ++ )
    {
        int x = get_max();
        x += delta;
        if (i % t == 0) printf("%d ", x);
        int left = x * 1ll * u / v;
        int right = x - left;
        delta += q;
        left -= delta, right -= delta;
        q2[ ++ tt2] = left, q3[ ++ tt3] = right;
    }
    puts("");

    for (int i = 1; i <= n + m; i ++ )
    {
        int x = get_max();
        if (i % t== 0) printf("%d ", x + delta);
    }
    puts("");
    return 0;
}
``` 
##### AcWing134   双端队列
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

typedef pair<int, int> PII;
const int N = 200010;

int n;
PII a[N];

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
    {
        cin >> a[i].first;
        a[i].second = i;
    }
    sort(a, a + n);
    int res = 1;
    for (int i = 0, last = n + 1, dir = -1; i < n; )
    {
        int j = i;
        while (j < n && a[j].first == a[i].first) j ++ ;
        int minx = a[i].second, maxx = a[j - 1].second;
        if (dir == -1)
        {
            if (last > maxx) last = minx;
            else dir = 1, last = maxx;
        }
        else
        {
            if (last < minx) last = maxx;
            else
            {
                res ++ ;
                last = minx;
                dir = -1;
            }
        }
        i = j;
    }

    cout << res << endl;

    return 0;
}
```  
##### AcWing135   最大子序和
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 300010, INF = 0x3f3f3f3f;

int n, m;
int s[N], q[N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ )
    {
        scanf("%d", &s[i]);
        s[i] += s[i - 1];
    }

    int res = -INF;
    int hh = 0, tt = 0;
    for (int i = 1; i <= n; i ++ )
    {
        if (q[hh] < i - m) hh ++ ;
        res = max(res, s[i] - s[q[hh]]);
        while (hh <= tt && s[q[tt]] >= s[i]) tt -- ;
        q[ ++ tt] = i;
    }

    printf("%d\n", res);

    return 0;
}
```  

## 0x13 链表与邻接表

##### AcWing136   邻值查找
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;
typedef pair<LL, int> PII;
const int N = 100010;

int n;
int l[N], r[N];
int p[N];
PII a[N], ans[N];

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++ )
    {
        cin >> a[i].first;
        a[i].second = i;
    }
    sort(a + 1, a + 1 + n);

    a[0].first = -3e9, a[n + 1].first = 3e9;
    for (int i = 1; i <= n; i ++ )
    {
        l[i] = i - 1, r[i] = i + 1;
        p[a[i].second] = i;
    }

    for (int i = n; i > 1; i -- )
    {
        int j = p[i], left = l[j], right = r[j];
        LL left_value = abs(a[left].first - a[j].first);
        LL right_value = abs(a[right].first - a[j].first);
        if (left_value <= right_value) ans[i] = {left_value, a[left].second};
        else ans[i] = {right_value, a[right].second};
        l[right] = left, r[left] = right;
    }

    for (int i = 2; i <= n; i ++ ) cout << ans[i].first << ' ' << ans[i].second << endl;

    return 0;
}
```  

## 0x14  hash表(字符串hash)

##### AcWing137   雪花雪花雪花
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
int snows[N][6], idx[N];

void get_min(int *b)
{
    static int a[12];
    for (int i = 0; i < 12; i ++ ) a[i] = b[i % 6];

    int i = 0, j = 1, k;
    while (i < 6 && j < 6)
    {
        for (k = 0; k < 6 && a[i + k] == a[j + k]; k ++ );
        if (k == 6) break;

        if (a[i + k] > a[j + k])
        {
            i += k + 1;
            if (i == j) i ++ ;
        }
        else
        {
            j += k + 1;
            if (i == j) j ++ ;
        }
    }

    k = min(i, j);

    for (i = 0; i < 6; i ++ ) b[i] = a[i + k];
}

bool cmp(int a, int b)
{
    for (int i = 0; i < 6; i ++ )
        if (snows[a][i] < snows[b][i])
            return true;
        else if (snows[a][i] > snows[b][i])
            return false;
    return false;
}

bool cmp2(int a[], int b[])
{
    for (int i = 0; i < 6; i ++ )
        if (a[i] < b[i])
            return true;
        else if (a[i] > b[i])
            return false;
    return false;
}

int main()
{
    scanf("%d", &n);
    int snow[6], isnow[6];
    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0, k = 5; j < 6; j ++, k -- )
        {
            scanf("%d", &snow[j]);
            isnow[k] = snow[j];
        }
        get_min(snow);
        get_min(isnow);
        if (cmp2(snow, isnow)) memcpy(snows[i], snow, sizeof snow);
        else memcpy(snows[i], isnow, sizeof isnow);

        idx[i] = i;
    }

    sort(idx, idx + n, cmp);

    for (int i = 1; i < n; i ++ )
    {
        if (!cmp(idx[i], idx[i - 1]) && !cmp(idx[i - 1], idx[i]))
        {
            puts("Twin snowflakes found.");
            return 0;
        }
    }

    puts("No two snowflakes are alike.");
    return 0;
}
```  
##### AcWing138   兔子与兔子
```cpp
#include <iostream>
#include <string.h>

using namespace std;

typedef unsigned long long ULL;
const int N = 1000010, p = 131;

char str[N];
ULL h[N], power[N];

ULL get(int l, int r)
{
    return h[r] - h[l - 1] * power[r - l + 1];
}

int main()
{
    scanf("%s", str + 1);
    int n = strlen(str + 1);
    power[0] = 1;
    for (int i = 1; i <= n; i ++ )
    {
        h[i] = h[i - 1] * p + str[i] - 'a' + 1;
        power[i] = power[i - 1] * p;
    }

    int m;
    scanf("%d", &m);
    while (m -- )
    {
        int l1, r1, l2, r2;
        scanf("%d%d%d%d", &l1, &r1, &l2, &r2);
        if (get(l1, r1) == get(l2, r2)) puts("Yes");
        else puts("No");
    }

    return 0;
}
```  
##### AcWing139   回文子串的最大长度

POJ3974 Palindrome

中心展开法

```cpp
#include <iostream>
#include <string.h>

using namespace std;

typedef unsigned long long ULL;
const int N = 2000010, base = 131;

char str[N];
ULL hl[N], hr[N], p[N];

ULL get(ULL h[], int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

int main()
{
    int T = 1;
    while (scanf("%s", str + 1), strcmp(str + 1, "END"))
    {
        int n = strlen(str + 1);
        for (int i = n * 2; i; i -= 2)
        {
            str[i] = str[i / 2];
            str[i - 1] = 'a' + 26;
        }
        n *= 2;
        p[0] = 1;
        for (int i = 1, j = n; i <= n; i ++, j -- )
        {
            hl[i] = hl[i - 1] * base + str[i] - 'a' + 1; 
            hr[i] = hr[i - 1] * base + str[j] - 'a' + 1;
            p[i] = p[i - 1] * base;
        }

        int res = 0;
        for (int i = 1; i <= n; i ++ )
        {
            int l = 0, r = min(i - 1, n - i);
            while (l < r)
            {
                int mid = l + r + 1 >> 1;
                if (get(hl, i - mid, i - 1) != get(hr, n - (i + mid) + 1, n - (i + 1) + 1)) r = mid - 1;
                else l = mid;
            }

            if (str[i - l] <= 'z') res = max(res, l + 1);
            else res = max(res, l);
        }

        printf("Case %d: %d\n", T ++ , res);
    }

    return 0;
}
```  
##### AcWing140   后缀数组

https://oi-wiki.org/string/sa/

后缀数组（Suffix Array）主要是两个数组： sa和rk。

sa表示将所有后缀排序后第i小的后缀的编号。rk[i]表示后缀i的排名

```cpp
#include <iostream>
#include <algorithm>
#include <string.h>
#include <limits.h>

using namespace std;

typedef unsigned long long ULL;
const int N = 300010, base = 131;

int n;
char str[N];
ULL h[N], p[N];
int sa[N];

ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

int get_max_common_prefix(int a, int b)
{
    int l = 0, r = min(n - a + 1, n - b + 1);
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (get(a, a + mid - 1) != get(b, b + mid - 1)) r = mid - 1;
        else l = mid;
    }
    return l;
}

bool cmp(int a, int b)
{
    int l = get_max_common_prefix(a, b);
    int av = a + l > n ? INT_MIN : str[a + l];
    int bv = b + l > n ? INT_MIN : str[b + l];
    return av < bv;
}

int main()
{
    scanf("%s", str + 1);
    n = strlen(str + 1);

    p[0] = 1;
    for (int i = 1; i <= n; i ++ )
    {
        h[i] = h[i - 1] * base + str[i] - 'a' + 1;
        p[i] = p[i - 1] * base;
        sa[i] = i;
    }

    sort(sa + 1, sa + 1 + n, cmp);

    for (int i = 1; i <= n; i ++ ) printf("%d ", sa[i] - 1);
    puts("");
    for (int i = 1; i <= n; i ++ )
        if (i == 1) printf("0 ");
        else printf("%d ", get_max_common_prefix(sa[i - 1], sa[i]));
    puts("");

    return 0;
}
```  

## 0x15 字符串(KMP与最小表示法）

##### AcWing141   周期
```cpp
#include <iostream>

using namespace std;

const int N = 1000010;

int n;
char str[N];
int nxt[N];

void get_next()
{
    for (int i = 2, j = 0; i <= n; i ++ )
    {
        while (j && str[i] != str[j + 1]) j = nxt[j];
        if (str[i] == str[j + 1]) j ++ ;
        nxt[i] = j;
    }
}

int main()
{
    int T = 1;
    while (scanf("%d", &n), n)
    {
        scanf("%s", str + 1);

        get_next();

        printf("Test case #%d\n", T ++ );
        for (int i = 2; i <= n; i ++ )
        {
            int t = i - nxt[i];
            if (i > t && i % t == 0) printf("%d %d\n", i, i / t);
        }
        puts("");
    }

    return 0;
}
``` 

## 0x16  Trie树（字典树）

  
##### AcWing142   前缀统计
```cpp
#include <iostream>

using namespace std;

const int N = 500000, M = 1000010;

int n, m;
int son[N][26], cnt[N], idx;
char str[M];

void insert()
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int s = str[i] - 'a';
        if (!son[p][s]) son[p][s] = ++ idx;
        p = son[p][s];
    }
    cnt[p] ++ ;
}

int search()
{
    int p = 0, res = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int s = str[i] - 'a';
        if (!son[p][s]) break;
        p = son[p][s];
        res += cnt[p];
    }
    return res;
}

int main()
{
    scanf("%d%d", &n, &m);
    while (n -- )
    {
        scanf("%s", str);
        insert();
    }

    while (m -- )
    {
        scanf("%s", str);
        printf("%d\n", search());
    }

    return 0;
}
```  
##### AcWing143   最大异或对
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, M = 3100010;

int n;
int a[N], son[M][2], idx;

void insert(int x)
{
    int p = 0;
    for (int i = 30; i >= 0; i -- )
    {
        int &s = son[p][x >> i & 1];
        if (!s) s = ++ idx;
        p = s;
    }
}

int search(int x)
{
    int p = 0, res = 0;
    for (int i = 30; i >= 0; i -- )
    {
        int s = x >> i & 1;
        if (son[p][!s])
        {
            res += 1 << i;
            p = son[p][!s];
        }
        else p = son[p][s];
    }
    return res;
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
    {
        cin >> a[i];
        insert(a[i]);
    }

    int res = 0;
    for (int i = 0; i < n; i ++ ) res = max(res, search(a[i]));

    cout << res << endl;

    return 0;
}
```  
##### AcWing144   最长异或值路径
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, M = 200010;

int n;
int h[N], e[M], c[M], ne[M], cnt;
int a[N], son[3000000][2], idx;

void add(int u, int v, int w)
{
    e[cnt] = v, c[cnt] = w, ne[cnt] = h[u], h[u] = cnt ++ ;
}

void dfs(int u, int father, int sum)
{
    a[u] = sum;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (j != father) dfs(j, u, sum ^ c[i]);
    }
}

void insert(int x)
{
    int p = 0;
    for (int i = 30; i >= 0; i -- )
    {
        int &s = son[p][x >> i & 1];
        if (!s) s = ++ idx;
        p = s;
    }
}

int search(int x)
{
    int p = 0, res = 0;
    for (int i = 30; i >= 0; i -- )
    {
        int s = x >> i & 1;
        if (son[p][!s])
        {
            res += 1 << i;
            p = son[p][!s];
        }
        else p = son[p][s];
    }
    return res;
}

int main()
{
    memset(h, -1, sizeof h);

    cin >> n;
    for (int i = 0; i < n - 1; i ++ )
    {
        int u, v, w;
        cin >> u >> v >> w;
        add(u, v, w);
        add(v, u, w);
    }

    dfs(0, -1, 0);

    for (int i = 0; i < n; i ++ ) insert(a[i]);

    int res = 0;
    for (int i = 0; i < n; i ++ ) res = max(res, search(a[i]));

    cout << res << endl;

    return 0;
}
```  

## 0x17  二叉堆

##### AcWing145   超市
```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>

using namespace std;

const int N = 10010;

int main()
{
    int n;
    while (cin >> n)
    {
        vector<pair<int, int>> products(n);
        for (int i = 0; i < n; i ++ ) cin >> products[i].second >> products[i].first;
        sort(products.begin(), products.end());
        priority_queue<int, vector<int>, greater<int>> heap;
        for (auto p : products)
        {
            heap.push(p.second);
            if (heap.size() > p.first) heap.pop();
        }
        int res = 0;
        while (heap.size())
        {
            res += heap.top();
            heap.pop();
        }
        cout << res << endl;
    }
    return 0;
}
```
##### AcWing146   序列
```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
#include <cstring>

using namespace std;

typedef pair<int,int> PII;

const int N = 2010;

int n, m;
int a[N], b[N], c[N];

void work()
{
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    for (int i = 0; i < n; i ++ ) heap.push({a[0] + b[i], 0});

    for (int i = 0; i < n; i ++ )
    {
        auto t = heap.top();
        heap.pop();
        c[i] = t.first;
        heap.push({t.first + a[t.second + 1] - a[t.second], t.second + 1});
    }

    memcpy(a, c, 4 * n);
}

int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        cin >> m >> n;
        for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);
        sort(a, a + n);
        for (int i = 1; i < m; i ++ )
        {
            for (int j = 0; j < n; j ++ ) scanf("%d", &b[j]);
            sort(b, b + n);
            work();
        }

        for (int i = 0; i < n; i ++ ) printf("%d ", a[i]);
        puts("");
    }

    return 0;
}
```  
##### AcWing147   数据备份
```cpp
#include <iostream>
#include <set>

using namespace std;

typedef long long LL;
typedef pair<LL, int> PLI;

const int N = 100010;

int n, k;
int l[N], r[N];
LL d[N];

void delete_node(int p)
{
    r[l[p]] = r[p];
    l[r[p]] = l[p];
}

int main()
{
    cin >> n >> k;

    for (int i = 0; i < n; i ++ ) cin >> d[i];
    for (int i = n - 1; i; i -- ) d[i] -= d[i - 1];

    set<PLI> S;
    d[0] = d[n] = 1e15;
    for (int i = 0; i <= n; i ++ )
    {
        l[i] = i - 1;
        r[i] = i + 1;
        S.insert({d[i], i});
    }

    LL res = 0;
    while (k -- )
    {
        auto it = S.begin();
        LL v = it->first;
        int p = it->second, left = l[p], right = r[p];

        S.erase(it);
        S.erase({d[left], left}), S.erase({d[right], right});
        delete_node(left), delete_node(right);
        res += v;

        d[p] = d[left] + d[right] - d[p];
        S.insert({d[p], p});
    }

    cout << res << endl;

    return 0;
}
```  
##### AcWing148   合并果子
```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>

using namespace std;

const int N = 10010;

int main()
{
    int n;
    cin >> n;
    priority_queue<int, vector<int>, greater<int>> heap;

    while (n -- )
    {
        int v;
        cin >> v;
        heap.push(v);
    }

    int res = 0;
    while (heap.size() > 1)
    {
        auto a = heap.top();
        heap.pop();
        auto b = heap.top();
        heap.pop();
        res += a + b;
        heap.push(a + b);
    }

    cout << res << endl;
    return 0;
}
```  
##### AcWing149   荷马史诗
```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>

using namespace std;

typedef long long LL;
typedef pair<LL, int> PLI;

const int N = 100010;

int main()
{
    int n, m;
    cin >> n >> m;

    priority_queue<PLI, vector<PLI>, greater<PLI>> heap;
    for (int i = 0; i < n; i ++ )
    {
        LL w;
        cin >> w;
        heap.push({w, 0});
    }

    while ((n - 1) % (m - 1))
    {
        heap.push({0ll, 0});
        n ++ ;
    }

    LL res = 0;
    while (heap.size() > 1)
    {
        LL sum = 0;
        int depth = 0;
        for (int i = 0; i < m; i ++ )
        {
            sum += heap.top().first;
            depth = max(depth, heap.top().second);
            heap.pop();
        }
        res += sum;
        heap.push({sum, depth + 1});
    }

    cout << res << endl << heap.top().second << endl;

    return 0;
}
```  

## 0x18 总结与练习

##### AcWing150   括号画家
```cpp
#include <iostream>
#include <stack>

using namespace std;

const int N = 100010;

int main()
{
    string str;
    cin >> str;
    stack<int> stk;

    int res = 0;
    for (int i = 0; i < str.size(); i ++ )
    {
        char c = str[i];
        if (c == ')' && stk.size() && str[stk.top()] == '(') stk.pop();
        else if (c == ']' && stk.size() && str[stk.top()] == '[') stk.pop();
        else if (c == '}' && stk.size() && str[stk.top()] == '{') stk.pop();
        else stk.push(i);

        if (stk.size()) res = max(res, i - stk.top());
        else res = max(res, i + 1);
    }

    cout << res << endl;
    return 0;
}
```
##### AcWing151   表达式计算
```cpp
#include <iostream>
#include <stack>

using namespace std;

stack<int> nums;
stack<char> ops;

int qmi(int a, int k)
{
    int res = 1;
    while (k -- ) res *= a;
    return res;
}

void cal()
{
    int a = nums.top(); nums.pop();
    int b = nums.top(); nums.pop();
    char c = ops.top(); ops.pop();
    int d;

    if (c == '+') d = b + a;
    else if (c == '-') d = b - a;
    else if (c == '*') d = b * a;
    else if (c == '/') d = b / a;
    else d = qmi(b, a);

    nums.push(d);
}

int main()
{
    string str;
    cin >> str;

    if (str[0] == '-') str = '0' + str;
    string left;
    for (int i = 0; i < str.size(); i ++ ) left += '(';
    str = left + str + ')';

    for (int i = 0; i < str.size(); i ++ )
    {
        if (str[i] >= '0' && str[i] <= '9')
        {
            int j = i, t = 0;
            while (str[j] >= '0' && str[j] <= '9')
            {
                t = t * 10 + str[j] - '0';
                j ++ ;
            }
            nums.push(t);
            i = j - 1;
        }
        else
        {
            char c = str[i];
            if (c == '(') ops.push(c);
            else if (c == '+' || c == '-')
            {
                if (c == '-' && i && !(str[i - 1] >= '0' && str[i - 1] <= '9') && str[i - 1] != ')')
                {
                    if (str[i + 1] == '(')  // 将-(...)变成-1 * (...)
                    {
                        nums.push(-1);
                        ops.push('*');
                    }
                    else
                    {
                        int j = i + 1, t = 0;
                        while (str[j] >= '0' && str[j] <= '9')
                        {
                            t = t * 10 + str[j] - '0';
                            j ++ ;
                        }
                        nums.push(-t);
                        i = j - 1;
                    }
                }
                else
                {
                    while (ops.top() != '(') cal();
                    ops.push(c);
                }
            }
            else if (c == '*' || c == '/')
            {
                while (ops.top() == '*' || ops.top() == '/' || ops.top() == '^') cal();
                ops.push(c);
            }
            else if (c == '^')
            {
                while (ops.top() == '^') cal();
                ops.push(c);
            }
            else if (c == ')')
            {
                while (ops.top() != '(') cal();
                ops.pop();
            }
            else cout << "invalid operator!" << endl;
        }
    }

    cout << nums.top() << endl;
    return 0;
}
```

##### AcWing152   城市游戏
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;
char g[N][N];
int h[N][N];
int q[N], l[N], r[N];

void cal(int a[], int l[])
{
    int hh = 0, tt = 0;
    a[0] = -1;
    for (int i = 1; i <= m; i ++ )
    {
        while (a[q[tt]] >= a[i]) tt -- ;
        l[i] = q[tt] + 1;
        q[ ++ tt] = i;
    }
}

int work(int a[])
{
    cal(a, l);
    reverse(a + 1, a + 1 + m);
    cal(a, r);
    reverse(a + 1, a + 1 + m);

    int res = 0;
    for (int i = 1; i <= m; i ++ )
    {
        int left = l[i];
        int right = m + 1 - r[m + 1 - i];
        res = max(res, a[i] * (right - left + 1));
    }

    return res;
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            cin >> g[i][j];
            if (g[i][j] == 'F') h[i][j] = h[i - 1][j] + 1;
            else h[i][j] = 0;
        }

    int res = 0;
    for (int i = 1; i <= n; i ++ ) res = max(res, work(h[i]));

    cout << res * 3 << endl;
    return 0;
}
```

##### AcWing153   双栈排序
```cpp
#include <iostream>
#include <algorithm>
#include <stack>
#include <cstring>

using namespace std;

const int N = 1010;

int n;
int a[N], f[N];
int color[N];
bool g[N][N];

bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = 1; i <= n; i++)
        if (g[u][i])
        {
            if (color[i] == c) return false;
            if (color[i] == -1 && !dfs(i, !c)) return false;
        }

    return true;
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    f[n + 1] = n + 1;
    memset(g, false, sizeof g);
    for (int i = n; i; i--) f[i] = min(f[i + 1], a[i]);

    for (int i = 1; i <= n; i++)
        for (int j = i + 1; j <= n; j++)
            if (a[i] < a[j] && f[j + 1] < a[i])
                g[i][j] = g[j][i] = true;

    memset(color, -1, sizeof color);

    bool flag = true;
    for (int i = 1; i <= n; i++)
        if (color[i] == -1 && !dfs(i, 0))
        {
            flag = false;
            break;
        }

    if (!flag)
    {
        cout << 0 << endl;
        return 0;
    }

    stack<int> stk1, stk2;

    int now = 1;
    for (int i = 1; i <= n; i++)
    {
        if (color[i] == 0)
        {
            // 要入第一个栈了，第一个栈该出的现在必须要出掉
            // 为了使字典序最小，第二个栈可以再等等
            while (stk1.size() && stk1.top() == now)
            {
                stk1.pop();
                cout << "b ";
                now++;
            }
            stk1.push(a[i]);
            cout << "a ";
        }
        else
        {
            // 要入第二个栈了，第二个栈该出的现在必须要出掉
            // 然而由于b比c字典序小，第一个栈可以出的也应该出掉
            while (true)
                if (stk1.size() && stk1.top() == now)
                {
                    stk1.pop();
                    cout << "b ";
                    now++;
                }
                else if (stk2.size() && stk2.top() == now)
                {
                    stk2.pop();
                    cout << "d ";
                    now++;
                }
                else break;
            stk2.push(a[i]);
            cout << "c ";
        }

    }
    // 最后出栈剩余的
    while (true)
        if (stk1.size() && stk1.top() == now)
        {
            stk1.pop();
            cout << "b ";
            now++;
        }
        else if (stk2.size() && stk2.top() == now)
        {
            stk2.pop();
            cout << "d ";
            now++;
        }
        else break;
    cout << endl;

    return 0;
}
```
 
##### AcWing154   滑动窗口
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1000010;

int n, m;
int a[N];
int q[N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);

    int hh = 0, tt = -1;
    for (int i = 0; i < n; i ++ )
    {
        if (hh <= tt && q[hh] <= i - m) hh ++ ;
        while (hh <= tt && a[q[tt]] >= a[i]) tt -- ;
        q[ ++ tt] = i;
        if (i >= m - 1) printf("%d ", a[q[hh]]);
    }
    puts("");

    hh = 0, tt = -1;
    for (int i = 0; i < n; i ++ )
    {
        if (hh <= tt && q[hh] <= i - m) hh ++ ;
        while (hh <= tt && a[q[tt]] <= a[i]) tt -- ;
        q[ ++ tt] = i;
        if (i >= m - 1) printf("%d ", a[q[hh]]);
    }
    puts("");

    return 0;
}
```

##### AcWing155   内存分配
```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#include <set>
#include <vector>

using namespace std;

typedef pair<int, int> PII;

int n;
queue<PII> waits;       // (first: 内存长度，second: 占用时间)
set<PII> runs;        // (first: 起始下标，sercond：长度)
priority_queue<PII, vector<PII>, greater<PII>> endts;       // (first: 释放时间，second: 起始下标)
int tm, cnt;

bool give(int t, int m, int p)
{
    for (auto it = runs.begin(); it != runs.end(); it ++ )
    {
        auto jt = it;
        jt ++ ;
        if (jt != runs.end())
        {
            if (m <= jt->first - (it->first + it->second - 1) - 1)
            {
                int start = it->first + it->second;
                runs.insert({start, m});
                endts.push({t + p, start});
                return true;
            }
        }
    }

    return false;
}

void finish(int t)
{
    while (endts.size() && endts.top().first <= t)
    {
        int f = endts.top().first;
        while (endts.size() && endts.top().first == f)
        {
            auto top = endts.top();
            endts.pop();
            auto it = runs.lower_bound({top.second, 0});
            runs.erase(it);
        }

        tm = f;
        while (waits.size())
        {
            auto front = waits.front();
            if (give(f, front.first, front.second))
            {
                waits.pop();
            }
            else break;
        }
    }
}

int main()
{
    cin >> n;
    int t, m, p;

    runs.insert({-1, 1}), runs.insert({n, 1});

    while (cin >> t >> m >> p, t || m || p)
    {
        finish(t);
        if (!give(t, m, p))
        {
            waits.push({m, p});
            cnt ++ ;
        }
    }

    finish(2e9);

    cout << tm << endl << cnt << endl;

    return 0;
}
```  
##### AcWing156   矩阵
```cpp
#include <iostream>
#include <algorithm>
#include <unordered_set>

using namespace std;

typedef unsigned long long ULL;

const int N = 1010, M = N * N, P = 131;

int n, m, a, b;
ULL hashv[N][N], p[M];
char str[N];

ULL calc(ULL f[], int l, int r)
{
    return f[r] - f[l - 1] * p[r - l + 1];
}

int main()
{
    scanf("%d%d%d%d", &n, &m, &a, &b);

    p[0] = 1;
    for (int i = 1; i <= n * m; i ++ ) p[i] = p[i - 1] * P;

    for (int i = 1; i <= n; i ++ )
    {
        scanf("%s", str + 1);
        for (int j = 1; j <= m; j ++ ) hashv[i][j] = hashv[i][j - 1] * P + str[j] - '0';
    }

    unordered_set<ULL> S;
    for (int i = b; i <= m; i ++ )
    {
        ULL s = 0;
        int l = i - b + 1, r = i;
        for (int j = 1; j <= n; j ++ )
        {
            s = s * p[b] + calc(hashv[j], l, r);
            if (j - a > 0) s -= calc(hashv[j - a], l, r) * p[a * b];
            if (j >= a) S.insert(s);
        }
    }

    int Q;
    scanf("%d", &Q);
    while (Q -- )
    {
        ULL s = 0;
        for (int i = 0; i < a; i ++ )
        {
            scanf("%s", str);
            for (int j = 0; j < b; j ++ ) s = s * P + str[j] - '0';
        }
        if (S.count(s)) puts("1");
        else puts("0");
    }

    return 0;
}
```   
##### AcWing157   树形地铁系统

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

string dfs(string &seq, int &u)
{
    u ++ ;
    vector<string> seqs;
    while (seq[u] == '0') seqs.push_back(dfs(seq, u));
    u ++ ;
    sort(seqs.begin(), seqs.end());
    string res = "0";
    for (auto &s : seqs) res += s;
    res += '1';
    return res;
}

int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        string a, b;
        cin >> a >> b;
        a = '0' + a + '1';
        b = '0' + b + '1';
        int ua = 0, ub = 0;
        auto ra = dfs(a, ua), rb = dfs(b, ub);
        if (ra == rb) puts("same");
        else puts("different");
    }
    return 0;
}
```   
##### AcWing158   项链
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <string.h>

using namespace std;

const int N = 2000000;

int n;
char a[N], b[N];

int get_min(char str[])
{
    int i = 0, j = 1;
    while (i < n && j < n)
    {
        int k = 0;
        while (k < n && str[i + k] == str[j + k]) k ++ ;
        if (k == n) break;
        if (str[i + k] > str[j + k]) i += k + 1;
        else j += k + 1;
        if (i == j) i ++ ;
    }
    int res = min(i, j);
    str[res + n] = 0;
    return res;
}

int main()
{
    scanf("%s%s", a, b);
    n = strlen(a);

    memcpy(a + n, a, n);
    memcpy(b + n, b, n);

    int ia = get_min(a), ib = get_min(b);

    if (strcmp(a + ia, b + ib)) puts("No");
    else
    {
        puts("Yes");
        puts(a + ia);
    }

    return 0;
}
```  
##### AcWing159   奶牛矩阵
```cpp
#include <iostream>
#include <algorithm>
#include <string.h>

using namespace std;

const int N = 10010, M = 80;

int n, m;
char str[N][M];
bool st[M];
int ne[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ )
    {
        cin >> str[i];
        for (int j = 1; j <= m; j ++ )
        {
            bool is_match = true;
            for (int k = j; k < m; k += j)
            {
                for (int u = 0; u < j && k + u < m; u ++ )
                    if (str[i][u] != str[i][k + u])
                    {
                        is_match = false;
                        break;
                    }
                if (!is_match) break;
            }
            if (!is_match) st[j] = true;
        }
    }

    int width;
    for (int i = 1; i <= m; i ++ )
        if (!st[i])
        {
            width = i;
            break;
        }

    for (int i = 1; i <= n; i ++ ) str[i][width] = 0;

    for (int j = 0, i = 2; i <= n; i ++ )
    {
        while (j && strcmp(str[j + 1], str[i])) j = ne[j];
        if (!strcmp(str[j + 1], str[i])) j ++ ;
        ne[i] = j;
    }

    int height = n - ne[n];

    cout << width * height << endl;

    return 0;
}

``` 
##### AcWing160   匹配统计
```cpp
#include <iostream>

using namespace std;

const int N = 200010;

int n, m, q;
char a[N], b[N];
int nxt[N];
int f[N];

int main()
{
    cin >> n >> m >> q;
    scanf("%s%s", a + 1, b + 1);

    for (int i = 2, j = 0; i <= m; i ++ )
    {
        while (j && b[i] != b[j + 1]) j = nxt[j];
        if (b[i] == b[j + 1]) j ++ ;
        nxt[i] = j;
    }

    for (int i = 1, j = 0; i <= n; i ++ )
    {
        while (j && a[i] != b[j + 1]) j = nxt[j];
        if (a[i] == b[j + 1]) j ++ ;
        f[j] ++ ;
    }

    for (int i = m; i; i -- ) f[nxt[i]] += f[i];

    while (q -- )
    {
        int x;
        cin >> x;
        cout << f[x] - f[x + 1] << endl;
    }

    return 0;
}
```   
##### AcWing161   电话列表
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
int son[N][10], idx;
bool f[N];

bool insert(char *str)
{
    int p = 0;
    bool has_new = false;
    bool has_found = false;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - '0';
        if (!son[p][u])
        {
            son[p][u] = ++ idx;
            has_new = true;
        }
        p = son[p][u];
        if (f[p]) has_found = true;
    }

    f[p] = true;

    return has_new && !has_found;
}

int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        cin >> n;
        memset(son, 0, sizeof son);
        memset(f, false, sizeof f);
        idx = 0;

        bool res = true;

        char str[20];
        for (int i = 0; i < n; i ++ )
        {
            cin >> str;
            if (!insert(str)) res = false;
        }

        if (res) puts("YES");
        else puts("NO");
    }

    return 0;
}
```   
##### AcWing162   黑盒子
```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>

using namespace std;

const int N = 30010;

int n, m;
int a[N], b[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ) cin >> a[i];
    for (int i = 1; i <= m; i ++ ) cin >> b[i];

    priority_queue<int> down;
    priority_queue<int, vector<int>, greater<int>> up;

    int k = 0;
    for (int i = 1, j = 1; i <= m; i ++ )
    {
        while (j <= b[i])
        {
            if (down.empty() || a[j] >= down.top()) up.push(a[j]);
            else
            {
                up.push(down.top());
                down.pop();
                down.push(a[j]);
            }
            j ++ ;
        }

        down.push(up.top());
        up.pop();
        cout << down.top() << endl;
    }

    return 0;
}
```   
##### AcWing163   生日礼物
```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>

using namespace std;

typedef pair<int, int> PII;

const int N = 100010;

int n, m;
int a[N], l[N], r[N];
bool st[N];

void remove(int p)
{
    // 从链表中删去

    l[r[p]] = l[p];
    r[l[p]] = r[p];

    // 从heap里删去
    st[p] = true;
}

int main()
{
    cin >> n >> m;

    int k = 1;
    for (int i = 0; i < n; i ++ )
    {
        int x;
        cin >> x;
        if ((long long)a[k] * x < 0) a[ ++ k] = x;
        else a[k] += x;
    }

    n = k;

    int cnt = 0, res = 0;
    for (int i = 1; i <= n; i ++ )
        if (a[i] > 0)
        {
            cnt ++ ;
            res += a[i];
        }

    priority_queue<PII, vector<PII>, greater<PII>> heap;

    for (int i = 1; i <= n; i ++ )
    {
        l[i] = i - 1;
        r[i] = i + 1;

        heap.push({abs(a[i]), i});
    }

    while (cnt > m)
    {
        while (st[heap.top().second]) heap.pop();

        auto t = heap.top();
        heap.pop();

        int v = t.first, p = t.second;

        if (l[p] != 0 && r[p] != n + 1 || a[p] > 0)
        {
            cnt -- ;
            res -= v;

            int left = l[p], right = r[p];
            a[p] += a[left] + a[right];

            heap.push({abs(a[p]), p});
            remove(left);
            remove(right);
        }
    }

    cout << res << endl;

    return 0;
}
```   


# 0x20 搜索(32)

包括树与图的遍历、深度优先搜索、剪枝、迭代加深、广度优先搜索、广搜变形、A*、IDA*等内容。


## 0x21 树与图的遍历

##### AcWing164   可达性统计
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <bitset>
#include <queue>

using namespace std;

const int N = 30010;

int n, m;
int h[N], e[N], ne[N], idx;
int d[N], seq[N];
bitset<N> f[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void topsort()
{
    queue<int> q;

    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q.push(i);

    int k = 0;
    while (q.size())
    {
        int t = q.front();
        q.pop();
        seq[k ++ ] = t;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q.push(j);
        }
    }
}

int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof h);

    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        cin >> a >> b;
        add(a, b);
        d[b] ++ ;
    }

    topsort();

    for (int i = n - 1; i >= 0; i -- )
    {
        int j = seq[i];
        f[j][j] = 1;
        for (int k = h[j]; ~k; k = ne[k])
            f[j] |= f[e[k]];
    }

    for (int i = 1; i <= n; i ++ ) cout << f[i].count() << endl;

    return 0;
}
```

## 0x22 深度优先搜索

**DFS描述**  

DFS的算法具体描述为选择一个起点v作为当前节点，执行如下操作：  
a. 访问当前节点，并且标记当前节点已被访问过，然后跳转到b；  
b. 如果存在一个和**当前节点**相邻并且尚未被访问的节点u，则将节点u设为当前节点，继续执行a；  
c. 如果不存在这样的u，则进行回溯，回溯的过程就是回退**当前节点**；
  
上述**当前节点**需要用一个栈来维护，每次访问到得到节点入栈，回溯的时候出栈（也可以用递归来实现，更佳直观和方便）。    

- DFS实现  
```python
def DFS(v):
    vistited[v]=true
    dosomething()
    for u in adjcent_list[v]:
        if visited[v] is false:
            DFS(u) 
//其中dosomething 表示访问时具体要干的事，根据情况而定，并DFS是可以有返回值的；
```

**DFS高级应用** 
   
- 枚举    
数据较小的排列、组合的穷举；  
- 容斥原理  
利用深搜计算一个公式，本质上还是枚举；  	
- 基于状态压缩的动态规划    
一般解决棋盘摆放问题，k进制表示状态，然后利用深搜进行状态转移；  
- 记忆化搜索  
某个状态被计算过了，就将它cache住，下次要用到的时候就不需要再一次计算；  
- 有向图的强连通分量   
经典的Tarjan算法；  
求解2-sat问题的基础；   
- 无向图割边割点和双连通分量  
经典的Tarjan算法；  
- LCA   
最近公共祖先递归求解；  
- 博弈  
利用深搜计算SG值；   
- 二分图最大匹配  
经典的匈牙利算法；  
最小顶点覆盖，最大独立集，最小值支配集向二分图的转化；  
- 欧拉回路  
经典的圈套圈算法；  
- K短路   
依赖数据，数据不卡的话可以采用二分答案+深搜或者广搜+A*;  
- 线段树   
二分经典思想，配合枚举深搜左右子树；  
- 最大团  
极大完全子图的优化算法；  
- 最大流   
EK算法求任意路径中有涉及；  
- 树形DP   
即树形动态规划；父节点的值由各子节点计算得出；  


**ACM DFS**:
    
 [Red and Black](http://poj.org/problem?id=1979)        ★☆☆☆☆   FloodFill

 [The Game](http://poj.org/problem?id=1970)          ★☆☆☆☆   FloodFill

 [Frogger](http://poj.org/problem?id=2253)           ★☆☆☆☆   二分枚举答案 + FloodFill  

 [Nearest Common Ancestors](http://poj.org/problem?id=1330)  ★☆☆☆☆   最近公共祖先 

 [Robot Motion](http://poj.org/problem?id=1573)        ★☆☆☆☆   递归模拟

 [Dessert](http://poj.org/problem?id=1950)           ★☆☆☆☆   枚举

 [Matrix](http://poj.org/problem?id=2078)           ★☆☆☆☆   枚举

 [Frame Stacking](http://poj.org/problem?id=1128)       ★☆☆☆☆   枚举

 [Transportation](http://poj.org/problem?id=1040)       ★☆☆☆☆   枚举

 [Pairs of Integers](http://poj.org/problem?id=1117)          ★★☆☆☆   枚举

 [Addition Chains](http://poj.org/problem?id=2248)            ★★☆☆☆   

 [DNA sequence](http://acm.hdu.edu.cn/showproblem.php?pid=1560)        ★★☆☆☆   

 [Booksort](http://poj.org/problem?id=3460)                   ★★★☆☆  

 [The Rotation Game](http://acm.hdu.edu.cn/showproblem.php?pid=1667)  

##### AcWing165   小猫爬山
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 20;

int n, m;
int sum[N], cat[N];
int ans = N;

void dfs(int u, int k)
{
    if (k > ans) return;

    if (u == n)
    {
        ans = k;
        return;
    }

    for (int i = 0; i < k; i ++ )
        if (sum[i] + cat[u] <= m)
        {
            sum[i] += cat[u];
            dfs(u + 1, k);
            sum[i] -= cat[u];
        }

    sum[k] = cat[u];
    dfs(u + 1, k + 1);
    sum[k] = 0;
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ ) cin >> cat[i];

    sort(cat, cat + n);
    reverse(cat, cat + n);

    dfs(0, 0);

    cout << ans << endl;

    return 0;
}
```
##### AcWing166   数独  
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 9;

int ones[1 << N], map[1 << N];
int row[N], col[N], cell[3][3];
char str[100];

inline int lowbit(int x)
{
    return x & -x;
}

void init()
{
    for (int i = 0; i < N; i ++ ) row[i] = col[i] = (1 << N) - 1;
    for (int i = 0; i < 3; i ++ )
        for (int j = 0; j < 3; j ++ )
            cell[i][j] = (1 << N) - 1;
}

// 求可选方案的交集
inline int get(int x, int y)
{
    return row[x] & col[y] & cell[x / 3][y / 3];
}

bool dfs(int cnt)
{
    if (!cnt) return true;

    // 找出可选方案数最少的空格
    int minv = 10;
    int x, y;
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
            if (str[i * 9 + j] == '.')
            {
                int t = ones[get(i, j)];
                if (t < minv)
                {
                    minv = t;
                    x = i, y = j;
                }
            }

    for (int i = get(x, y); i; i -= lowbit(i))
    {
        int t = map[lowbit(i)];

        // 修改状态
        row[x] -= 1 << t;
        col[y] -= 1 << t;
        cell[x / 3][y / 3] -= 1 << t;
        str[x * 9 + y] = '1' + t;

        if (dfs(cnt - 1)) return true;

        // 恢复现场
        row[x] += 1 << t;
        col[y] += 1 << t;
        cell[x / 3][y / 3] += 1 << t;
        str[x * 9 + y] = '.';
    }

    return false;
}

int main()
{
    for (int i = 0; i < N; i ++ ) map[1 << i] = i;
    for (int i = 0; i < 1 << N; i ++ )
    {
        int s = 0;
        for (int j = i; j; j -= lowbit(j)) s ++ ;
        ones[i] = s; // i的二进制表示中有s个1
    }

    while (cin >> str, str[0] != 'e')
    {
        init();

        int cnt = 0;
        for (int i = 0, k = 0; i < N; i ++ )
            for (int j = 0; j < N; j ++ , k ++ )
                if (str[k] != '.')
                {
                    int t = str[k] - '1';
                    row[i] -= 1 << t;
                    col[j] -= 1 << t;
                    cell[i / 3][j / 3] -= 1 << t;
                }
                else cnt ++ ;

        dfs(cnt);

        cout << str << endl;
    }

    return 0;
}
```

## 0x23 剪枝

可行性剪枝: 可行性剪枝一般是处理可行解的问题，如一个迷宫，问能否从起点到达目标点之类的。

最优化剪枝: 不断优化解空间的过程

##### AcWing167   木棒
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 70;

int n;
int sum, length;
int sticks[N];
bool st[N];

bool dfs(int u, int cur, int start)
{
    if (u * length == sum) return true;
    if (cur == length) return dfs(u + 1, 0, 0);

    for (int i = start; i < n; i ++ )
    {
        if (st[i]) continue;
        int l = sticks[i];
        if (cur + l <= length)
        {
            st[i] = true;
            if (dfs(u, cur + l, i + 1)) return true;
            st[i] = false;

            // 剪枝3 如果是第一个木棒失败，则一定失败
            if (!cur) return false;

            // 剪枝4 如果是最后一个木棒失败，则一定失败
            if (cur + l == length) return false;

            // 剪枝2 跳过相同木棒
            int j = i;
            while (j < n && sticks[j] == l) j ++ ;
            i = j - 1;
        }
    }


    return false;
}

int main()
{
    while (cin >> n, n)
    {
        sum = 0, length = 0;
        memset(st, false, sizeof st);

        for (int i = 0; i < n; i ++ )
        {
            cin >> sticks[i];
            if (sticks[i] > 50) continue;
            sum += sticks[i];
            length = max(length, sticks[i]);
        }

        // 剪枝：优化搜索顺序
        sort(sticks, sticks + n);
        reverse(sticks, sticks + n);

        for (int i = 0; i < n; i ++ )
            if (sticks[i] > 50)
                st[i] = true;

        while (true)
        {
            if (sum % length == 0 && dfs(0, 0, 0))
            {
                cout << length << endl;
                break;
            }
            length ++ ;
        }
    }

    return 0;
}
``` 
##### AcWing168   生日蛋糕  
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 25, INF = 1e9;

int n, m;
int minv[N], mins[N];
int R[N], H[N];
int ans = INF;

void dfs(int u, int v, int s)
{
    if (v + minv[u] > n) return;
    if (s + mins[u] >= ans) return;
    if (s + 2 * (n - v) / R[u + 1] >= ans) return;

    if (!u)
    {
        if (v == n) ans = s;
        return;
    }

    for (int r = min(R[u + 1] - 1, (int)sqrt(n - v)); r >= u; r -- )
        for (int h = min(H[u + 1] - 1, (n - v) / r / r); h >= u; h -- )
        {
            int t = 0;
            if (u == m) t = r * r;
            R[u] = r, H[u] = h;
            dfs(u - 1, v + r * r * h, s + 2 * r * h + t);
        }
}

int main()
{
    cin >> n >> m;

    for (int i = 1; i <= m; i ++ )
    {
        minv[i] = minv[i - 1] + i * i * i;
        mins[i] = mins[i - 1] + 2 * i * i;
    }

    R[m + 1] = H[m + 1] = INF;

    dfs(m, 0, 0);

    if (ans == INF) ans = 0;
    cout << ans << endl;

    return 0;
}
```
##### AcWing169   数独2  
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 16;


int map[1 << N], ones[1 << N];
int state[N][N];
char str[N][N + 1];

int bstate[N * N + 1][N][N], bstate2[N * N + 1][N][N];
char bstr[N * N + 1][N][N + 1];


inline int lowbit(int x)
{
    return x & -x;
}

void draw(int x, int y, int c)
{
    str[x][y] = 'A' + c;

    for (int i = 0; i < N; i ++ )
    {
        state[x][i] &= ~(1 << c);
        state[i][y] &= ~(1 << c);
    }

    int sx = x / 4 * 4, sy = y / 4 * 4;
    for (int i = 0; i < 4; i ++ )
        for (int j = 0; j < 4; j ++ )
                state[sx + i][sy + j] &= ~(1 << c);

    state[x][y] = 1 << c;
}


bool dfs(int cnt)
{
    if (!cnt) return true;

    int kcnt = cnt;
    memcpy(bstate[kcnt], state, sizeof state);
    memcpy(bstr[kcnt], str, sizeof str);

    // 每个空格，如果不能填则返回false；如果只有一个选项，则直接填上
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
            if (str[i][j] == '-')
            {
                if (!state[i][j])
                {
                    memcpy(state, bstate[kcnt], sizeof state);
                    memcpy(str, bstr[kcnt], sizeof str);
                    return false;
                }

                if (ones[state[i][j]] == 1)
                {
                    draw(i, j, map[state[i][j]]);
                    cnt -- ;
                }
            }

    // 每一行，如果某个字母不能填，则返回false；如果某个字母只有一种填法，则直接填
    for (int i = 0; i < N; i ++ )
    {
        int sor = 0, sand = (1 << N) - 1;
        int drawn = 0;
        for (int j = 0; j < N; j ++ )
        {
            int s = state[i][j];
            sand &= ~(sor & s);
            sor |= s;

            if (str[i][j] != '-') drawn |= state[i][j];
        }

        if (sor != (1 << N) - 1)
        {
            memcpy(state, bstate[kcnt], sizeof state);
            memcpy(str, bstr[kcnt], sizeof str);
            return false;
        }

        for (int j = sand; j; j -= lowbit(j))
        {
            int t = lowbit(j);
            if (!(drawn & t))
            {
                for (int k = 0; k < N; k ++ )
                    if (state[i][k] & t)
                    {
                        draw(i, k, map[t]);
                        cnt -- ;
                        break;
                    }
            }
        }
    }

    // 每一列，如果某个字母不能填，则返回false；如果某个字母只有一种填法，则直接填
    for (int i = 0; i < N; i ++ )
    {
        int sor = 0, sand = (1 << N) - 1;
        int drawn = 0;
        for (int j = 0; j < N; j ++ )
        {
            int s = state[j][i];
            sand &= ~(sor & s);
            sor |= s;

            if (str[j][i] != '-') drawn |= state[j][i];
        }

        if (sor != (1 << N) - 1)
        {
            memcpy(state, bstate[kcnt], sizeof state);
            memcpy(str, bstr[kcnt], sizeof str);
            return false;
        }

        for (int j = sand; j; j -= lowbit(j))
        {
            int t = lowbit(j);
            if (!(drawn & t))
            {
                for (int k = 0; k < N; k ++ )
                    if (state[k][i] & t)
                    {
                        draw(k, i, map[t]);
                        cnt -- ;
                        break;
                    }
            }
        }
    }

    // 每个16宫格，如果某个字母不能填，则返回false；如果某个字母只有一种填法，则直接填
    for (int i = 0; i < N; i ++ )
    {
        int sor = 0, sand = (1 << N) - 1;
        int drawn = 0;
        for (int j = 0; j < N; j ++ )
        {
            int sx = i / 4 * 4, sy = i % 4 * 4;
            int dx = j / 4, dy = j % 4;
            int s = state[sx + dx][sy + dy];
            sand &= ~(sor & s);
            sor |= s;

            if (str[sx + dx][sy + dy] != '-') drawn |= state[sx + dx][sy + dy];
        }

        if (sor != (1 << N) - 1)
        {
            memcpy(state, bstate[kcnt], sizeof state);
            memcpy(str, bstr[kcnt], sizeof str);
            return false;
        }
        for (int j = sand; j; j -= lowbit(j))
        {
            int t = lowbit(j);
            if (!(drawn & t))
            {
                for (int k = 0; k < N; k ++ )
                {
                    int sx = i / 4 * 4, sy = i % 4 * 4;
                    int dx = k / 4, dy = k % 4;
                    if (state[sx + dx][sy + dy] & t)
                    {
                        draw(sx + dx, sy + dy, map[t]);
                        cnt -- ;
                        break;
                    }
                }
            }
        }
    }

    if (!cnt) return true;

    int x, y, s = 100;
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
            if (str[i][j] == '-' && ones[state[i][j]] < s)
            {
                s = ones[state[i][j]];
                x = i, y = j;
            }

    memcpy(bstate2[kcnt], state, sizeof state);
    for (int i = state[x][y]; i; i -= lowbit(i))
    {
        memcpy(state, bstate2[kcnt], sizeof state);
        draw(x, y, map[lowbit(i)]);
        if (dfs(cnt - 1)) return true;
    }

    memcpy(state, bstate[kcnt], sizeof state);
    memcpy(str, bstr[kcnt], sizeof str);
    return false;
}


int main()
{
    for (int i = 0; i < N; i ++ ) map[1 << i] = i;
    for (int i = 0; i < 1 << N; i ++ )
    {
        for (int j = i; j; j -= lowbit(j))
            ones[i] ++ ;
    }

    while (cin >> str[0])
    {
        for (int i = 1; i < N; i ++ ) cin >> str[i];

        for (int i = 0; i < N; i ++ )
            for (int j = 0; j < N; j ++ )
                state[i][j] = (1 << N) - 1;

        int cnt = 0;
        for (int i = 0; i < N; i ++ )
            for (int j = 0; j < N; j ++ )
                if (str[i][j] != '-')
                    draw(i, j, str[i][j] - 'A');
                else cnt ++ ;

        dfs(cnt);

        for (int i = 0; i < N; i ++ ) cout << str[i] << endl;
        cout << endl;
    }

    return 0;
}
```

## 0x24 迭代加深

##### AcWing170   加成序列
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n;
int path[N];


bool dfs(int u, int k)
{
    if (u == k) return path[u - 1] == n;

    bool st[N] = {0};
    for (int i = u - 1; i >= 0; i -- )
        for (int j = i; j >= 0; j -- )
        {
            int s = path[i] + path[j];
            if (s > n || s <= path[u - 1] || st[s]) continue;
            st[s] = true;

            path[u] = s;
            if (dfs(u + 1, k)) return true;
        }

    return false;
}


int main()
{
    path[0] = 1;
    while (cin >> n, n)
    {
        int k = 1;
        while (!dfs(1, k)) k ++ ;
        for (int i = 0; i < k; i ++ ) cout << path[i] << ' ';
        cout << endl;
    }

    return 0;
}
```
##### AcWing171   送礼物
```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

typedef long long LL;

const int N = 1 << 24;

int n, m, k;
int g[50], weights[N];
int cnt = 0;
int ans;


void dfs(int u, int s)
{
    if (u == k)
    {
        weights[cnt ++ ] = s;
        return;
    }

    if ((LL)s + g[u] <= m) dfs(u + 1, s + g[u]);
    dfs(u + 1, s);
}


void dfs2(int u, int s)
{
    if (u == n)
    {
        int l = 0, r = cnt - 1;
        while (l < r)
        {
            int mid = l + r + 1 >> 1;
            if (weights[mid] + (LL)s <= m) l = mid;
            else r = mid - 1;
        }
        if (weights[l] + (LL)s <= m) ans = max(ans, weights[l] + s);

        return;
    }

    if ((LL)s + g[u] <= m) dfs2(u + 1, s + g[u]);
    dfs2(u + 1, s);
}


int main()
{
    cin >> m >> n;
    for (int i = 0; i < n; i ++ ) cin >> g[i];

    sort(g, g + n);
    reverse(g, g + n);

    k = n / 2 + 2;
    dfs(0, 0);

    sort(weights, weights + cnt);
    int t = 1;
    for (int i = 1; i < cnt; i ++ )
        if (weights[i] != weights[i - 1])
            weights[t ++ ] = weights[i];
    cnt = t;

    dfs2(k, 0);

    cout << ans << endl;

    return 0;
}
```  

## 0x25 广度优先搜索

**BFS描述**  

BFS的具体算法描述为选择一个起始点v放入一个先进先出的队列中，执行如下操作：    
a. 如果队列不为空，弹出一个队列首元素，记为当前结点，执行b；否则算法结束；  
b. 将与 当前结点 相邻并且尚未被访问的结点的信息进行更新，并且全部放入队列中，继续执行a；  
维护广搜的数据结构是队列和HASH，队列就是官方所说的open-close表，HASH主要是用来标记状态的，比如某个状态并不是一个整数，可能是一个字符串，就需要用字符串映射到一个整数，可以自己写个散列HASH表，不建议用STL的map，效率奇低。   


**算法实现**  
广搜一般用队列维护状态，写成伪代码如下：  
```python
def BFS(v):
    resetArray(visited,false)
    visited[v] = true
    queue.push(v)
    while not queue.empty():
        v = queue.getfront_and_pop()
        for u in adjcent_list[v]:
            if visited[u] is false:
                dosomething(u)
                queue.push(u)
```

**基础应用**    
-  最短路：bellman-ford最短路的优化算法SPFA，主体是利用BFS实现的。    
绝大部分四向、八向迷宫的最短路问题。     
- 拓扑排序：  
首先找入度为0的点入队，弹出元素执行“减度”操作，继续将减完度后入度为0的点入队，循环操作，直到队列为空，经典BFS操作；   
- FloodFill： 
经典洪水灌溉算法；  

**高级应用**  
- 差分约束：   
数形结合的经典算法，利用SPFA来求解不等式组。  
- 稳定婚姻：   
二分图的稳定匹配问题，试问没有稳定的婚姻，如何有心思学习算法，所以一定要学好BFS啊；                
- AC自动机：   
字典树 + KMP + BFS，在设定失败指针的时候需要用到BFS。     
详细算法参见：http://www.cppblog.com/menjitianya/archive/2014/07/10/207604.html  
- 矩阵二分：   
矩阵乘法的状态转移图的构建可以采用BFS；   
- 基于k进制的状态压缩搜索：   
这里的k一般为2的幂，状态压缩就是将原本多维的状态压缩到一个k进制的整数中，便于存储在一个一维数组中，往往可以大大地节省空间，又由于k为2的幂，所以状态转移可以采用位运算进行加速，HDU1813和HDU3278以及HDU3900都是很好的例子； 

**双向广搜**  

适用于起始状态都给定的问题，一般一眼就能看出来，固定套路，很难有好的剪枝 

初始状态 和 目标状态 都知道，求初始状态到目标状态的最短距离; 
   
利用两个队列，初始化时初始状态在1号队列里，目标状态在2号队列里，并且记录这两个状态的层次都为0，然后分别执行如下操作：   
a.若1号队列已空，则结束搜索，否则从1号队列逐个弹出层次为K(K >= 0)的状态；    
i.  如果该状态在2号队列扩展状态时已经扩展到过，那么最短距离为两个队列扩展状态的层次加和，结束搜索；   
ii. 否则和BFS一样扩展状态，放入1号队列，直到队列首元素的层次为K+1时执行b；   
b.若2号队列已空，则结束搜索，否则从2号队列逐个弹出层次为K(K >= 0)的状态；   
i.  如果该状态在1号队列扩展状态时已经扩展到过，那么最短距离为两个队列扩展状态的层次加和，结束搜索；   
ii. 否则和BFS一样扩展状态，放入2号队列，直到队列首元素的层次为K+1时执行a；      



[Pushing Boxes](http://poj.org/problem?id=1475)        ★☆☆☆☆   经典广搜 - 推箱子

[Jugs](http://poj.org/problem?id=1606)            ★☆☆☆☆   经典广搜 - 倒水问题

[Space Station Shielding](http://poj.org/problem?id=1096)  ★☆☆☆☆   FloodFill

[Knight Moves](http://poj.org/problem?id=1915)        ★☆☆☆☆   棋盘搜索

[Knight Moves](http://poj.org/problem?id=2243)        ★☆☆☆☆   棋盘搜索    

[Eight](http://poj.org/problem?id=1077)            ★★☆☆☆   经典八数码

[Currency Exchange](http://poj.org/problem?id=1860)      ★★☆☆☆   SPFA

[Brackets Sequence](http://poj.org/problem?id=1141)      ★★★☆☆          经典记忆化

[FatMouse and Chees](http://acm.hdu.edu.cn/showproblem.php?pid=1078)   ★☆☆☆☆          经典迷宫问题

##### AcWing172   立体推箱子

```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 510;


struct State
{
    int x, y, lie;
};


int n, m;
char g[N][N];
int dist[N][N][3];


bool check(int x, int y)
{
    if (x < 0 || x >= n || y < 0 || y >= m) return false;
    return g[x][y] != '#';
}


int bfs(State start, State end)
{
    queue<State> q;
    memset(dist, -1, sizeof dist);
    dist[start.x][start.y][start.lie] = 0;
    q.push(start);

    int d[3][4][3] = {
        {{-2, 0, 2}, {0, 1, 1}, {1, 0, 2}, {0, -2, 1}},
        {{-1, 0, 1}, {0, 2, 0}, {1, 0, 1}, {0, -1, 0}},
        {{-1, 0, 0}, {0, 1, 2}, {2, 0, 0}, {0, -1, 2}}
    };

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        for (int i = 0; i < 4; i ++ )
        {
            State next = {t.x + d[t.lie][i][0], t.y + d[t.lie][i][1], d[t.lie][i][2]};

            int x = next.x, y = next.y;
            if (!check(x, y)) continue;
            if (next.lie == 0)
            {
                if (g[x][y] == 'E') continue;
            }
            else if (next.lie == 1)
            {
                if (!check(x, y + 1)) continue;
            }
            else
            {
                if (!check(x + 1, y)) continue;
            }

            if (dist[next.x][next.y][next.lie] == -1)
            {
                dist[next.x][next.y][next.lie] = dist[t.x][t.y][t.lie] + 1;
                q.push(next);
            }
        }
    }

    return dist[end.x][end.y][end.lie];
}


int main()
{
    while (scanf("%d%d", &n, &m), n || m)
    {
        for (int i = 0; i < n; i ++ ) scanf("%s", g[i]);

        State start = {-1}, end;
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < m; j ++ )
                if (g[i][j] == 'X' && start.x == -1)
                {
                    if (g[i + 1][j] == 'X') start = {i, j, 2};
                    else if (g[i][j + 1] == 'X') start = {i, j, 1};
                    else start = {i, j, 0};
                }
                else if (g[i][j] == 'O') end = {i, j, 0};

        int res = bfs(start, end);
        if (res == -1) puts("Impossible");
        else printf("%d\n", res);
    }

    return 0;
}
```
##### AcWing173   矩阵距离
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef pair<int, int> PII;

const int N = 1010;

int n, m;
int d[N][N];
char g[N][N];
PII q[N * N];

void bfs()
{
    int hh = 0, tt = -1;

    memset(d, -1, sizeof d);
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            if (g[i][j] == '1')
            {
                d[i][j] = 0;
                q[ ++ tt] = {i, j};
            }

    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
    while (hh <= tt)
    {
        auto t = q[hh ++ ];
        int x = t.first, y = t.second;

        for (int i = 0; i < 4; i ++ )
        {
            int a = x + dx[i], b = y + dy[i];
            if (!a || a > n || !b || b > m || d[a][b] != -1) continue;

            d[a][b] = d[x][y] + 1;
            q[ ++ tt] = {a, b};
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);

    for (int i = 1; i <= n; i ++ ) scanf("%s", g[i] + 1);

    bfs();

    for (int i = 1; i <= n; i ++ )
    {
        for (int j = 1; j <= m; j ++ )
            printf("%d ", max(d[i][j], 0));
        puts("");
    }

    return 0;
}
```  
##### AcWing174   推箱子
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 25;

struct Node
{
    int x, y, dir;
};

int n, m;
char g[N][N];   // 存储游戏地图
Node pre[N][N][4];  // 表示箱子在(x, y)，上一个格子在i方向上的状态，即上一个状态是(x + dx[i], y + dy[i])
vector<int> path[N][N][4];  // path[j][k][i] 表示人从推(j,k,i)的上一个状态的位置，走到推(j,k,i)这个状态的位置的行走路径
bool st[N][N][4], used[N][N];   // BFS的判重数组，为了防止BFS遍历相同状态
PII dist[N][N][4];  // dist[j][k][i]是表示从初始状态到达j,k,i状态所需要的箱子最短路程和人行走最短路程
int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};  // 依次表示下、上、右、左四个方向
int pre_man[N][N];  // pre_man[x][y]表示人从哪个方向走到(x, y)，如果pre_man[x][y] = i, 那么上一个状态是(x - dx[i], y - dy[i])

bool check(int x, int y)    // 判断(x, y)是否在地图内，且是空地
{
    return x >= 0 && x < n && y >= 0 && y < m && g[x][y] != '#';
}

void output(Node end, PII box)
{
    char ops[] = "nswe";
    string res;
    while (end.dir != -1)
    {
        res += ops[end.dir] - 32;
        for (auto dir : path[end.x][end.y][end.dir]) res += ops[dir];
        end = pre[end.x][end.y][end.dir];
        printf("(%d,%d,%d) ", end.x, end.y, end.dir);
    }
    reverse(res.begin(), res.end());
    cout << res << endl;
}

// 求人从start走到end，中间不经过box的最短路径，行走序列保存在seq中
int bfs_man(PII start, PII end, PII box, vector<int> &seq)
{
    memset(used, false, sizeof used);
    memset(pre_man, -1, sizeof pre_man);

    queue<PII> q;
    q.push(start);
    used[start.first][start.second] = true;
    used[box.first][box.second] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        if (t == end)
        {
            seq.clear();
            int x = t.first, y = t.second;
            while (pre_man[x][y] != -1)
            {
                int dir = pre_man[x][y] ^ 1;
                seq.push_back(dir);
                x += dx[dir], y += dy[dir];
            }

            return seq.size();
        }

        for (int ii = 0; ii < 4; ii ++ )
        {
            int i = ii ^ 1;
            int x = t.first, y = t.second;
            int a = x + dx[i], b = y + dy[i];
            if (check(a, b) && !used[a][b])
            {
                used[a][b] = true;
                pre_man[a][b] = i;
                q.push({a, b});
            }
        }
    }

    return -1;
}

bool bfs_box(PII man, PII box, Node &end) 
{
    memset(st, false, sizeof st);

    queue<Node> q;
    for (int i = 0; i < 4; i ++ )
    {
        int x = box.first, y = box.second;
        int a = x + dx[i], b = y + dy[i];
        int j = x - dx[i], k = y - dy[i];
        vector<int> seq;

        if (check(a, b) && check(j, k) && bfs_man(man, {a, b}, box, seq) != -1)
        {
            st[j][k][i] = true;
            q.push({j, k, i});
            dist[j][k][i] = {1, seq.size()};
            path[j][k][i] = seq;
            pre[j][k][i] = {x, y, -1};
        }
    }

    bool success = false;
    PII man_d = {1e9, 1e9};

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        if (g[t.x][t.y] == 'T')
        {
            success = true;

            if (dist[t.x][t.y][t.dir] < man_d)
            {
                man_d = dist[t.x][t.y][t.dir];
                end = t;
            }
        }

        for (int i = 0; i < 4; i ++ )
        {
            int a = t.x + dx[i], b = t.y + dy[i];
            int j = t.x - dx[i], k = t.y - dy[i];
            if (check(a, b) && check(j, k))
            {
                vector<int> seq;
                auto &p = dist[j][k][i];
                int distance = bfs_man({t.x + dx[t.dir], t.y + dy[t.dir]}, {a, b}, {t.x, t.y}, seq);
                if (distance != -1)
                {
                    PII td = {dist[t.x][t.y][t.dir].first + 1, dist[t.x][t.y][t.dir].second + distance};
                    if (!st[j][k][i])
                    {
                        st[j][k][i] = true;
                        q.push({j, k, i});
                        path[j][k][i] = seq;
                        pre[j][k][i] = t;
                        p = td;
                    }
                    else if (p > td)
                    {
                        p = td;
                        path[j][k][i] = seq;
                        pre[j][k][i] = t;
                    }
                }
            }
        }
    }

    return success;
}

int main()
{
    int T = 1;
    while (cin >> n >> m, n || m)
    {
        for (int i = 0; i < n; i ++ ) cin >> g[i];

        printf("Maze #%d\n", T ++ );

        PII man, box;
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < m; j ++ )
                if (g[i][j] == 'S') man = {i, j};
                else if (g[i][j] == 'B') box = {i, j};

        Node end;

        if (!bfs_box(man, box, end)) puts("Impossible.");
        else
        {
            char ops[] = "nswe";
            string res;
            while (end.dir != -1)
            {
                res += ops[end.dir] - 32;
                for (auto dir : path[end.x][end.y][end.dir]) res += ops[dir];
                end = pre[end.x][end.y][end.dir];
            }
            reverse(res.begin(), res.end());
            cout << res << endl;
        }

        puts("");
    }

    return 0;
}

```  

## 0x26 广搜变形

##### AcWing175   电路维修
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <deque>

using namespace std;

typedef pair<int, int> PII;

const int N = 510;

int n, m;
char g[N][N];
int d[N][N];
bool st[N][N];

int bfs()
{
    memset(st, 0, sizeof st);
    memset(d, 0x3f, sizeof d);

    deque<PII> q;
    q.push_back({0, 0});
    d[0][0] = 0;

    int dx[4] = {-1, -1, 1, 1}, dy[4] = {-1, 1, 1, -1};
    int ix[4] = {-1, -1, 0, 0}, iy[4] = {-1, 0, 0, -1};
    char cs[] = "\\/\\/";

    while (q.size())
    {
        auto t = q.front();
        q.pop_front();

        int x = t.first, y = t.second;
        if (st[x][y]) continue;
        st[x][y] = true;

        for (int i = 0; i < 4; i ++ )
        {
            int a = x + dx[i], b = y + dy[i];
            int j = x + ix[i], k = y + iy[i];
            if (a >= 0 && a <= n && b >= 0 && b <= m)
            {
                int w = 0;
                if (g[j][k] != cs[i]) w = 1;
                if (d[a][b] > d[x][y] + w)
                {
                    d[a][b] = d[x][y] + w;
                    if (w) q.push_back({a, b});
                    else q.push_front({a, b});
                }
            }
        }
    }

    if (d[n][m] == 0x3f3f3f3f) return -1;
    return d[n][m];
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        scanf("%d%d", &n, &m);
        for (int i = 0; i < n; i ++ ) scanf("%s", g[i]);

        int t = bfs();

        if (t == -1) puts("NO SOLUTION");
        else printf("%d\n", t);
    }

    return 0;
}
```
##### AcWing176   装满的油箱
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

typedef pair<int, int> PII;

const int N = 1010, C = 110, M = 20010;

int n, m;
int h[N], e[M], w[M], ne[M], idx;
int price[N];
int dist[N][C];
bool st[N][C];

struct Ver
{
    int d, u, c;
    bool operator< (const Ver &W)const
    {
        return d > W.d;
    }
};

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int dijkstra(int start, int end, int cap)
{
    memset(dist, 0x3f, sizeof dist);
    memset(st, false, sizeof st);
    priority_queue<Ver> heap;
    heap.push({0, start, 0});
    dist[start][0] = 0;

    while (heap.size())
    {
        auto t = heap.top(); heap.pop();

        if (t.u == end) return t.d;

        if (st[t.u][t.c]) continue;
        st[t.u][t.c] = true;

        if (t.c < cap)
        {
            if (dist[t.u][t.c + 1] > t.d + price[t.u])
            {
                dist[t.u][t.c + 1] = t.d + price[t.u];
                heap.push({dist[t.u][t.c + 1], t.u, t.c + 1});
            }
        }

        for (int i = h[t.u]; ~i; i = ne[i])
        {
            int j = e[i];
            if (t.c >= w[i])
            {
                if (dist[j][t.c - w[i]] > t.d)
                {
                    dist[j][t.c - w[i]] = t.d;
                    heap.push({dist[j][t.c - w[i]], j, t.c - w[i]});
                }
            }
        }
    }

    return -1;
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    for (int i = 0; i < n; i ++ ) scanf("%d", &price[i]);
    for (int i = 0; i < m; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c), add(b, a, c);
    }

    int query;
    scanf("%d", &query);
    while (query -- )
    {
        int a, b, c;
        scanf("%d%d%d", &c, &a, &b);
        int t = dijkstra(a, b, c);
        if (t == -1) puts("impossible");
        else printf("%d\n", t);
    }

    return 0;
}

```

##### AcWing177   噩梦
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

typedef pair<int, int> PII;

const int N = 810;

int n, m;
char g[N][N];
int st[N][N];
PII ghost[2];

bool check(int x, int y, int step)
{
    if (x < 0 || x >= n || y < 0 || y >= m || g[x][y] == 'X') return false;

    for (int i = 0; i < 2; i ++ )
        if (abs(x - ghost[i].first) + abs(y - ghost[i].second) <= step * 2)
            return false;

    return true;
}

int bfs()
{
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    memset(st, 0, sizeof st);

    int cnt = 0;
    PII boy, girl;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            if (g[i][j] == 'M') boy = {i, j};
            else if (g[i][j] == 'G') girl = {i, j};
            else if (g[i][j] == 'Z') ghost[cnt ++ ] = {i, j};

    queue<PII> qb, qg;
    qb.push(boy);
    qg.push(girl);

    int step = 0;
    while (qb.size() || qg.size())
    {
        step ++ ;
        for (int i = 0; i < 3; i ++ )
            for (int j = 0, len = qb.size(); j < len; j ++ )
            {
                auto t = qb.front();
                qb.pop();
                int x = t.first, y = t.second;
                if (!check(x, y, step)) continue;
                for (int k = 0; k < 4; k ++ )
                {
                    int a = x + dx[k], b = y + dy[k];
                    if (check(a, b, step))
                    {
                        if (st[a][b] == 2)
                        {
                            return step;
                        }
                        if (!st[a][b])
                        {
                            st[a][b] = 1;
                            qb.push({a, b});
                        }
                    }
                }
            }

        for (int i = 0; i < 1; i ++ )
            for (int j = 0, len = qg.size(); j < len; j ++ )
            {
                auto t = qg.front();
                qg.pop();

                int x = t.first, y = t.second;
                if (!check(x, y, step)) continue;
                for (int k = 0; k < 4; k ++ )
                {
                    int a = x + dx[k], b = y + dy[k];
                    if (check(a, b, step))
                    {
                        if (st[a][b] == 1)
                        {
                            return step;
                        }
                        if (!st[a][b])
                        {
                            st[a][b] = 2;
                            qg.push({a, b});
                        }
                    }
                }
            }
    }

    return -1;
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        scanf("%d%d", &n, &m);
        for (int i = 0; i < n; i ++ ) scanf("%s", g[i]);

        printf("%d\n", bfs());
    }

    return 0;
}
```

## 0x27 A*

##### AcWing178   第K短路
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;
typedef pair<int, PII> PIII;

const int N = 1010, M = 200010;

int n, m, S, T, K;
int h[N], rh[N], e[M], w[M], ne[M], idx;
int dist[N], cnt[N];
bool st[N];

void add(int h[], int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void dijkstra()
{
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, T});

    memset(dist, 0x3f, sizeof dist);
    dist[T] = 0;

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.y;
        if (st[ver]) continue;
        st[ver] = true;

        for (int i = rh[ver]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[ver] + w[i])
            {
                dist[j] = dist[ver] + w[i];
                heap.push({dist[j], j});
            }
        }
    }
}

int astar()
{
    priority_queue<PIII, vector<PIII>, greater<PIII>> heap;
    heap.push({dist[S], {0, S}});

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.y.y, distance = t.y.x;
        cnt[ver] ++ ;
        if (cnt[T] == K) return distance;

        for (int i = h[ver]; ~i; i = ne[i])
        {
            int j = e[i];
            if (cnt[j] < K)
                heap.push({distance + w[i] + dist[j], {distance + w[i], j}});
        }
    }

    return -1;
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    memset(rh, -1, sizeof rh);

    for (int i = 0; i < m; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(h, a, b, c);
        add(rh, b, a, c);
    }
    scanf("%d%d%d", &S, &T, &K);
    if (S == T) K ++ ;

    dijkstra();
    printf("%d\n", astar());

    return 0;
}
```
##### AcWing179   八数码  
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <queue>

#define x first
#define y second

using namespace std;

typedef pair<int, string> PIS;

int f(string state)
{
    int res = 0;
    for (int i = 0; i < 9; i ++ )
        if (state[i] != 'x')
        {
            int v = state[i] - '1';
            res += abs(v / 3 - i / 3) + abs(v % 3 - i % 3);
        }

    return res;
}

string bfs(string start)
{
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
    char op[5] = "urdl";

    string end = "12345678x";
    unordered_map<string, int> dist;
    unordered_map<string, pair<char, string>> pre;
    priority_queue<PIS, vector<PIS>, greater<PIS>> heap;

    heap.push({f(start), start});
    dist[start] = 0;

    while(heap.size())
    {
        auto t = heap.top();
        heap.pop();

        string state = t.y;
        if (state == end) break;

        int x, y;
        for (int i = 0; i < 9; i ++ )
            if (state[i] == 'x')
            {
                x = i / 3, y = i % 3;
                break;
            }

        string source = state;
        for (int i = 0; i < 4; i ++ )
        {
            int a = x + dx[i], b = y + dy[i];
            if (a < 0 || a >= 3 || b < 0 || b >= 3) continue;
            state = source;
            swap(state[x * 3 + y], state[a * 3 + b]);
            if (dist.count(state) == 0 || dist[state] > dist[source] + 1)
            {
                dist[state] = dist[source] + 1;
                pre[state] = {op[i], source};
                heap.push({dist[state] + f(state), state});
            }
        }
    }

    string res;
    while (end != start)
    {
        res += pre[end].x;
        end = pre[end].y;
    }
    reverse(res.begin(), res.end());

    return res;
}

int main()
{
    string start, seq;
    char c;
    while (cin >> c)
    {
        start += c;
        if (c != 'x') seq += c;
    }

    int cnt = 0;
    for (int i = 0; i < 8; i ++ )
        for (int j = i + 1; j < 8; j ++ )
            if (seq[i] > seq[j])
                cnt ++ ;

    if (cnt % 2) puts("unsolvable");
    else cout << bfs(start) << endl;

    return 0;
}
```


## 0x28 IDA*

##### AcWing180   排书
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 15;

int n;
int q[N], w[5][N];

int f()
{
    int res = 0;
    for (int i = 0; i + 1 < n; i ++ )
        if (q[i + 1] != q[i] + 1)
            res ++ ;
    return (res + 2) / 3;
}

bool check()
{
    for (int i = 0; i < n; i ++ )
        if (q[i] != i + 1)
            return false;
    return true;
}

bool dfs(int depth, int max_depth)
{
    if (depth + f() > max_depth) return false;
    if (check()) return true;

    for (int l = 0; l < n; l ++ )
        for (int r = l; r < n; r ++ )
            for (int k = r + 1; k < n; k ++ )
            {
                memcpy(w[depth], q, sizeof q);
                int x, y;
                for (x = r + 1, y = l; x <= k; x ++, y ++ ) q[y] = w[depth][x];
                for (x = l; x <= r; x ++, y ++ ) q[y] = w[depth][x];
                if (dfs(depth + 1, max_depth)) return true;
                memcpy(q, w[depth], sizeof q);
            }
    return false;
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        scanf("%d", &n);
        for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);

        int depth = 0;
        while (depth < 5 && !dfs(0, depth)) depth ++ ;
        if (depth >= 5) puts("5 or more");
        else printf("%d\n", depth);
    }

    return 0;
}
```
##### AcWing181   回转游戏
```cpp
/*
      0     1
      2     3
4  5  6  7  8  9  10
      11    12
13 14 15 16 17 18 19
      20    21
      22    23
*/


#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 24;

int q[N];
int op[8][7] = {
    {0, 2, 6, 11, 15, 20, 22},
    {1, 3, 8, 12, 17, 21, 23},
    {10, 9, 8, 7, 6, 5, 4},
    {19, 18, 17, 16, 15, 14, 13},
    {23, 21, 17, 12, 8, 3, 1},
    {22, 20, 15, 11, 6, 2, 0},
    {13, 14, 15, 16, 17, 18, 19},
    {4, 5, 6, 7, 8, 9, 10}
};
int center[8] = {6, 7, 8, 11, 12, 15, 16, 17};
int opposite[8] = {5, 4, 7, 6, 1, 0, 3, 2};

int path[100];

int f()
{
    static int sum[4];
    memset(sum, 0, sizeof sum);
    for (int i = 0; i < 8; i ++ ) sum[q[center[i]]] ++ ;

    int s = 0;
    for (int i = 1; i <= 3; i ++ ) s = max(s, sum[i]);
    return 8 - s;
}

bool check()
{
    for (int i = 1; i < 8; i ++ )
        if (q[center[i]] != q[center[0]])
            return false;
    return true;
}

void operation(int x)
{
    int t = q[op[x][0]];
    for (int i = 0; i < 6; i ++ ) q[op[x][i]] = q[op[x][i + 1]];
    q[op[x][6]] = t;
}

bool dfs(int depth, int max_depth, int last)
{
    if (depth + f() > max_depth) return false;
    if (check()) return true;

    for (int i = 0; i < 8; i ++ )
    {
        if (opposite[i] == last) continue;
        operation(i);
        path[depth] = i;
        if (dfs(depth + 1, max_depth, i)) return true;
        operation(opposite[i]);
    }

    return false;
}

int main()
{
    while (scanf("%d", &q[0]), q[0])
    {
        for (int i = 1; i < N; i ++ ) scanf("%d", &q[i]);
        int depth = 0;
        while (!dfs(0, depth, -1))
        {
            depth ++ ;
        }
        if (!depth) printf("No moves needed");
        for (int i = 0; i < depth; i ++ ) printf("%c", 'A' + path[i]);
        printf("\n%d\n", q[6]);
    }

    return 0;
}
```
##### AcWing182   破坏正方形
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 61;

int n, m;
bool st[N];
vector<int> square[N];

bool check(vector<int> &sq)
{
    for (auto x : sq)
        if (st[x])
            return false;
    return true;
}

int f()
{
    static bool state[N];
    memcpy(state, st, sizeof st);

    int res = 0;
    for (int i = 0; i < m; i ++ )
    {
        auto &sq = square[i];
        if (check(sq))
        {
            res ++ ;
            for (auto x : sq) st[x] = true;
        }
    }

    memcpy(st, state, sizeof st);

    return res;
}

bool dfs(int depth)
{
    if (f() > depth) return false;

    for (int i = 0; i < m; i ++ )
    {
        auto &sq = square[i];
        if (check(sq))
        {
            for (auto x : sq)
            {
                st[x] = true;
                if (dfs(depth - 1)) return true;
                st[x] = false;
            }
            return false;
        }
    }

    return true;
}

main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        scanf("%d", &n);

        m = 0;
        for (int i = 1; i <= n; i ++ )
            for (int a = 1; a + i - 1 <= n; a ++ )
                for (int b = 1; b + i - 1 <= n; b ++ )
                {
                    square[m].clear();
                    for (int j = 0; j < i; j ++ )
                    {
                        int d = 2 * n + 1;
                        square[m].push_back((a - 1) * d + b + j);
                        square[m].push_back((a - 1 + i) * d + b + j);
                        square[m].push_back(n + 1 + (a - 1) * d + b - 1 + j * d);
                        square[m].push_back(n + 1 + (a - 1) * d + b - 1 + j * d + i);
                    }
                    m ++ ;
                }

        memset(st, 0, sizeof st);
        int k;
        scanf("%d", &k);
        for (int i = 0, t; i < k; i ++ )
        {
            scanf("%d", &t);
            st[t] = true;
        }

        int depth = 0;
        while (!dfs(depth)) depth ++ ;

        printf("%d\n", depth);
    }

    return 0;
}
```

## 0x29 总结与练习

##### AcWing183   靶形数独
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 9, M = 1 << N;

int ones[M], map[M];
int row[N], col[N], cell[3][3];
int g[N][N];
int ans = -1;

inline int lowbit(int x)
{
    return x & -x;
}

void init()
{
    for (int i = 0; i < N; i++) map[1 << i] = i;
    for (int i = 0; i < M; i++)
        for (int j = i; j; j -= lowbit(j))
            ones[i] ++;

    for (int i = 0; i < 9; i++) row[i] = col[i] = cell[i / 3][i % 3] = M - 1;
}

inline int get_score(int x, int y, int t)
{
    return (min(min(x, 8 - x), min(y, 8 - y)) + 6) * t;
}

inline void draw(int x, int y, int t)
{
    int s = 1;
    if (t > 0) g[x][y] = t;
    else
    {
        s = -1;
        t = -t;
        g[x][y] = 0;
    }

    t--;
    row[x] -= (1 << t) * s;
    col[y] -= (1 << t) * s;
    cell[x / 3][y / 3] -= (1 << t) * s;
}

inline int get(int x, int y)
{
    return row[x] & col[y] & cell[x / 3][y / 3];
}

void dfs(int cnt, int score)
{
    if (!cnt)
    {
        ans = max(ans, score);
        return;
    }

    int minv = 10;
    int x, y;
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j ++ )
            if (!g[i][j])
            {
                int t = ones[get(i, j)];
                if (t < minv)
                {
                    minv = ones[get(i, j)];
                    x = i, y = j;
                }
            }

    for (int i = get(x, y); i; i -= lowbit(i))
    {
        int t = map[lowbit(i)] + 1;
        draw(x, y, t);
        dfs(cnt - 1, score + get_score(x, y, t));
        draw(x, y, -t);
    }
}

int main()
{
    init();

    int cnt = 0, score = 0;
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j < N; j++)
        {
            int x;
            cin >> x;
            if (x)
            {
                draw(i, j, x);
                score += get_score(i, j, x);
            }
            else cnt++;
        }

    dfs(cnt, score);

    cout << ans << endl;

    return 0;
}
```
  
##### AcWing184   虫食算
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 30;

int n;
char e[3][N];
int q[N], path[N];
bool st[N];     // state

bool check()
{
    for (int i = n - 1, t = 0; i >= 0; i -- )
    {
        int a = e[0][i] - 'A', b = e[1][i] - 'A', c = e[2][i] - 'A';
        if (path[a] != -1 && path[b] != -1 && path[c] != -1)
        {
            a = path[a], b = path[b], c = path[c];
            if (t != -1)
            {
                if ((a + b + t) % n != c) return false;
                if (!i && a + b + t >= n) return false;
                t = (a + b + t) / n;
            }
            else
            {
                if ((a + b + 0) % n != c && (a + b + 1) % n != c) return false;
                if (!i && a + b >= n) return false;
            }
        }
        else t = -1;
    }

    return true;
}

bool dfs(int u)
{
    if (u == n) return true;

    for (int i = 0; i < n; i ++ )
        if (!st[i])
        {
            st[i] = true;
            path[q[u]] = i;
            if (check() && dfs(u + 1)) return true;
            st[i] = false;
            path[q[u]] = -1;
        }

    return false;
}

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < 3; i ++ ) scanf("%s", e[i]);
    for (int i = n - 1, k = 0; i >= 0; i -- )
        for (int j = 0; j < 3; j ++ )
        {
            int t = e[j][i] - 'A';
            if (!st[t])
            {
                st[t] = true;
                q[k ++ ] = t;
            }
        }

    memset(st, 0, sizeof st);
    memset(path, -1, sizeof path);
    dfs(0);

    for (int i = 0; i < n; i ++ ) printf("%d ", path[i]);

    return 0;
}

```
##### AcWing185   玛雅游戏
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

int n;
int g[5][7], bg[5][5][7];
int cnt[11], bcnt[5][11];
bool st[5][7];

struct Path
{
    int x, y, d;
}path[5];

void move(int a, int b, int c)
{
    swap(g[a][b], g[c][b]);

    while (true)
    {
        bool flag = true;
        // 处理悬空方格
        for (int x = 0; x < 5; x ++ )
        {
            int z = 0;
            for (int y = 0; y < 7; y ++ )
                if (g[x][y])
                    g[x][z ++ ] = g[x][y];
            while (z < 7) g[x][z ++ ] = 0;
        }

        memset(st, 0, sizeof st);
        for (int x = 0; x < 5; x ++ )
            for (int y = 0; y < 7; y ++ )
                if (g[x][y])
                {
                    int l = x, r = x;
                    while (l - 1 >= 0 && g[l - 1][y] == g[x][y]) l -- ;
                    while (r + 1 < 5 && g[r + 1][y] == g[x][y]) r ++ ;
                    if (r - l + 1 >= 3)
                    {
                        st[x][y] = true;
                        flag = false;
                    }
                    else
                    {
                        l = r = y;
                        while (l - 1 >= 0 && g[x][l - 1] == g[x][y]) l -- ;
                        while (r + 1 < 7 && g[x][r + 1] == g[x][y]) r ++ ;

                        if (r - l + 1 >= 3)
                        {
                            st[x][y] = true;
                            flag = false;
                        }
                    }
                }

        if (flag) break;
        for (int x = 0; x < 5; x ++ )
            for (int y = 0; y < 7; y ++ )
                if (st[x][y])
                {
                    cnt[0] -- ;
                    cnt[g[x][y]] -- ;
                    g[x][y] = 0;
                }
    }
}

bool dfs(int u)
{
    if (u == n) return !cnt[0];

    for (int i = 1; i <= 10; i ++ )
        if (cnt[i] == 1 || cnt[i] == 2)
            return false;

    // 枚举所有操作
    memcpy(bg[u], g, sizeof g);
    memcpy(bcnt[u], cnt, sizeof cnt);
    for (int x = 0; x < 5; x ++ )
        for (int y = 0; y < 7; y ++ )
            if (g[x][y])
            {
                int nx = x + 1;
                if (nx < 5)
                {
                    path[u] = {x, y, 1};
                    move(x, y, nx);
                    if (dfs(u + 1)) return true;
                    memcpy(g, bg[u], sizeof g);
                    memcpy(cnt, bcnt[u], sizeof cnt);
                }

                nx = x - 1;
                if (nx >= 0 && !g[nx][y])
                {
                    path[u] = {x, y, -1};
                    move(x, y, nx);
                    if (dfs(u + 1)) return true;
                    memcpy(g, bg[u], sizeof g);
                    memcpy(cnt, bcnt[u], sizeof cnt);
                }
            }


    return false;
}

int main()
{
    scanf("%d", &n);
    for (int x = 0; x < 5; x ++ )
    {
        int t, y = 0;
        while (scanf("%d", &t), t)
        {
            cnt[0] ++ ;
            cnt[t] ++ ;
            g[x][y ++ ] = t;
        }
    }

    if (dfs(0))
    {
        for (int i = 0; i < n; i ++ ) printf("%d %d %d\n", path[i].x, path[i].y, path[i].d);
    }
    else puts("-1");

    return 0;
}
```

##### AcWing186   巴士
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

typedef pair<int, int> PII;

const int N = 2000, M = 60;

int n;
int bus[M];
vector<pair<int, PII>> routes;

bool check(int a, int d)
{
    for (int i = a; i < 60; i += d)
        if (!bus[i])
            return false;
    return true;
}

bool dfs(int depth, int sum, int start)
{
    if (!depth) return sum == n;

    // 枚举选哪个路线
    for (int i = start; i < routes.size(); i ++ )
    {
        auto r = routes[i];
        int a = r.second.first, d = r.second.second;
        if (r.first * depth + sum < n) continue;
        if (!check(a, d)) continue;
        for (int j = a; j < 60; j += d) bus[j] -- ;
        if (dfs(depth - 1, sum + r.first, i)) return true;
        for (int j = a; j < 60; j += d) bus[j] ++ ;
    }


    return false;
}

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ )
    {
        int t;
        scanf("%d", &t);
        bus[t] ++ ;
    }

    for (int a = 0; a < 60; a ++ )
        for (int d = a + 1; a + d < 60; d ++ )
            if (check(a, d))
                routes.push_back({(59 - a) / d + 1, {a, d}});

    sort(routes.begin(), routes.end(), greater<pair<int, PII>>());

    int depth = 0;
    while (!dfs(depth, 0, 0)) depth ++ ;

    printf("%d\n", depth);

    return 0;
}
```

 
##### AcWing187   导弹防御系统
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 60;

int n;
int h[N];
int up[N], down[N];

bool dfs(int depth, int u, int su, int sd)
{
    if (su + sd > depth) return false;
    if (u == n) return true;

    // 枚举放到上升子序列中的情况
    bool flag = false;
    for (int i = 1; i <= su; i ++ )
        if (up[i] < h[u])
        {
            int t = up[i];
            up[i] = h[u];
            if (dfs(depth, u + 1, su, sd)) return true;
            up[i] = t;
            flag = true;
            break;
        }
    if (!flag)
    {
        up[su + 1] = h[u];
        if (dfs(depth, u + 1, su + 1, sd)) return true;
    }

    // 枚举放到下降子序列中的情况
    flag = false;
    for (int i = 1; i <= sd; i ++ )
        if (down[i] > h[u])
        {
            int t = down[i];
            down[i] = h[u];
            if (dfs(depth, u + 1, su, sd)) return true;
            down[i] = t;
            flag = true;
            break;
        }
    if (!flag)
    {
        down[sd + 1] = h[u];
        if (dfs(depth, u + 1, su, sd + 1)) return true;
    }

    return false;
}

int main()
{
    while (cin >> n, n)
    {
        for (int i = 0; i < n; i ++ ) cin >> h[i];

        int depth = 0;
        while (!dfs(depth, 0, 0, 0)) depth ++ ;

        cout << depth << endl;
    }

    return 0;
}
```
  
##### AcWing188   武士风度的牛
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 155;

int n, m;
char g[N][N];
int dist[N][N];

int bfs(PII start, PII end)
{
    queue<PII> q;
    memset(dist, -1, sizeof dist);
    dist[start.x][start.y] = 0;

    q.push(start);

    int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};
    int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};

    while (q.size())
    {
        auto t = q.front();
        q.pop();
        for (int i = 0; i < 8; i ++ )
        {
            int x = t.x + dx[i], y = t.y + dy[i];
            if (x < 0 || x >= n || y < 0 || y >= m) continue;
            if (g[x][y] == '*') continue;
            if (dist[x][y] != -1) continue;
            dist[x][y] = dist[t.x][t.y] + 1;

            if (make_pair(x, y) == end) return dist[x][y];

            q.push({x, y});
        }
    }

    return -1;
}

int main()
{
    cin >> m >> n;
    for (int i = 0; i < n; i ++ ) cin >> g[i];

    PII start, end;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            if (g[i][j] == 'K') start = {i, j};
            else if (g[i][j] == 'H') end = {i, j};

    cout << bfs(start, end) << endl;

    return 0;
}
```  
##### AcWing189   乳草的入侵
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 110;

int n, m;
PII start;
char g[N][N];
int dist[N][N];

int bfs()
{
    memset(dist, -1, sizeof dist);
    queue<PII> q;
    q.push(start);
    dist[start.x][start.y] = 0;

    int res = 0;
    while (q.size())
    {
        auto t = q.front();
        q.pop();

        for (int x = t.x - 1; x <= t.x + 1; x ++ )
            for (int y = t.y - 1; y <= t.y + 1; y ++ )
                if (x != t.x || y != t.y)
                {
                    if (x < 1 || x > n || y < 1 || y > m) continue;
                    if (g[x][y] == '*' || dist[x][y] != -1) continue;
                    dist[x][y] = dist[t.x][t.y] + 1;
                    res = max(res, dist[x][y]);
                    q.push({x, y});
                }
    }

    return res;
}

int main()
{
    cin >> m >> n >> start.y >> start.x;
    start.x = n + 1 - start.x;

    for (int i = 1; i <= n; i ++ ) cin >> g[i] + 1;

    cout << bfs() << endl;

    return 0;
}

```  
##### AcWing190   字串变换

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#include <unordered_map>

using namespace std;

const int N = 6;

int n;
string A, B;
string a[N], b[N];

int extend(queue<string>& q, unordered_map<string, int>&da, unordered_map<string, int>& db, 
    string a[N], string b[N])
{
    int d = da[q.front()];
    while (q.size() && da[q.front()] == d)
    {
        auto t = q.front();
        q.pop();

        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < t.size(); j ++ )
                if (t.substr(j, a[i].size()) == a[i])
                {
                    string r = t.substr(0, j) + b[i] + t.substr(j + a[i].size());
                    if (db.count(r)) return da[t] + db[r] + 1;
                    if (da.count(r)) continue;
                    da[r] = da[t] + 1;
                    q.push(r);
                }
    }

    return 11;
}

int bfs()
{
    if (A == B) return 0;
    queue<string> qa, qb;
    unordered_map<string, int> da, db;

    qa.push(A), qb.push(B);
    da[A] = db[B] = 0;

    int step = 0;
    while (qa.size() && qb.size())
    {
        int t;
        if (qa.size() < qb.size()) t = extend(qa, da, db, a, b);
        else t = extend(qb, db, da, b, a);

        if (t <= 10) return t;
        if ( ++ step == 10) return -1;
    }

    return -1;
}

int main()
{
    cin >> A >> B;
    while (cin >> a[n] >> b[n]) n ++ ;

    int t = bfs();
    if (t == -1) puts("NO ANSWER!");
    else cout << t << endl;

    return 0;
}
```
##### AcWing191   天气预报
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 366;

int n;
bool st[N][3][3][7][7][7][7];
struct Node
{
    int day, x, y, s0, s1, s2, s3;
};
int state[N][4][4];

int bfs()
{
    if (state[1][1][1] || state[1][1][2] || state[1][2][1] || state[1][2][2]) return 0;

    queue<Node> q;
    memset(st, 0, sizeof st);
    q.push({1, 1, 1, 1, 1, 1, 1});
    st[1][1][1][1][1][1][1] = true;

    int dx[] = {-1, 0, 1, 0, 0}, dy[] = {0, 1, 0, -1, 0};

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        if (t.day == n) return 1;

        for (int i = 0; i < 5; i ++ )
            for (int j = 1; j <= 2; j ++ )
            {
                int x = t.x + dx[i] * j, y = t.y + dy[i] * j;
                if (x < 0 || x >= 3 || y < 0 || y >= 3) continue;

                auto& s = state[t.day + 1];
                if (s[x][y] || s[x][y + 1] || s[x + 1][y] || s[x + 1][y + 1]) continue;

                int s0 = t.s0, s1 = t.s1, s2 = t.s2, s3 = t.s3;
                if (!x && !y) s0 = 0;
                else if ( ++ s0 == 7) continue;
                if (!x && y == 2) s1 = 0;
                else if ( ++ s1 == 7) continue;
                if (x == 2 && !y) s2 = 0;
                else if ( ++ s2 == 7) continue;
                if (x == 2 && y == 2) s3 = 0;
                else if ( ++ s3 == 7) continue;

                if (st[t.day + 1][x][y][s0][s1][s2][s3]) continue;

                st[t.day + 1][x][y][s0][s1][s2][s3] = true;
                q.push({t.day + 1, x, y, s0, s1, s2, s3});
            }
    }

    return 0;
}

int main()
{
    while (cin >> n, n)
    {
        for (int i = 1; i <= n; i ++ )
            for (int j = 0; j < 4; j ++ )
                for (int k = 0; k < 4; k ++ )
                    cin >> state[i][j][k];

        cout << bfs() << endl;
    }

    return 0;
}
```  
##### AcWing192   立体推箱子
```cpp
 
```  
##### AcWing193   算乘方的牛
```cpp
 
```  
##### AcWing194   涂满它
```cpp
 
```  
##### AcWing195   骑士精神
```cpp
 
```  



# 0x30 数学知识(41)

包括质数、约数、同余、矩阵乘法、高斯消元与线性空间、组合计数、容斥原理与Mobius函数、概率与数学期望、0/1分数规划、博弈论之SG函数等内容。

## 0x31 质数

##### AcWing196   质数距离
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1000010;

int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
    memset(st, false, sizeof st);
    cnt = 0;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] * i <= n; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

int main()
{
    long long l, r;
    while (cin >> l >> r)
    {
        get_primes(50000);

        memset(st, false, sizeof st);
        for (int i = 0; i < cnt; i ++ )
        {
            int p = primes[i];

            // 把[l, r]中所有p的倍数筛掉
            for (long long j = max((l + p - 1) / p * p, 2ll * p); j <= r; j += p)
                st[j - l] = true;
        }

        cnt = 0;
        for (int i = 0; i <= r - l; i ++ )
            if (!st[i] && i + l > 1)
                primes[cnt ++ ] = i + l;

        if (cnt < 2) puts("There are no adjacent primes.");
        else
        {
            int minp = 0, maxp = 0;
            for (int i = 0; i + 1 < cnt; i ++ )
            {
                int d = primes[i + 1] - primes[i];
                if (d < primes[minp + 1] - primes[minp]) minp = i;
                if (d > primes[maxp + 1] - primes[maxp]) maxp = i;
            }

            printf("%d,%d are closest, %d,%d are most distant.\n", primes[minp], primes[minp + 1], primes[maxp], primes[maxp + 1]);
        }
    }
    return 0;
}
```

##### AcWing197   阶乘分解  
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1000010;

int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; j < cnt && i * primes[j] <= n; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

int main()
{
    int n;
    cin >> n;
    get_primes(n);

    for (int i = 0; i < cnt; i ++ )
    {
        int p = primes[i];
        int s = 0;
        for (int j = p; j <= n; j *= p)
        {
            s += n / j;
            if (j > n / p) break;
        }
        cout << p << ' ' << s << endl;
    }

    return 0;
}
```

## 0x32 约数

##### AcWing198   反素数
```cpp
#include <iostream>

using namespace std;

typedef long long LL;

int ps[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};

int n;
int sum = 0, minx;

void dfs(int u, int last, int p, int s)
{
    if (s > sum || s == sum && p < minx)
    {
        sum = s;
        minx = p;
    }

    for (int i = 1; i <= last; i ++ )
    {
        if ((LL)p * ps[u] > n) break;
        p *= ps[u];
        dfs(u + 1, i, p, s * (i + 1));
    }
}

int main()
{
    cin >> n;

    dfs(0, 30, 1, 1);

    cout << minx << endl;

    return 0;
}
```

##### AcWing199   余数之和
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

int main()
{
    LL n, k;
    cin >> n >> k;
    LL res = n * k;
    for (LL x = 1, gx; x <= n; x = gx + 1)
    {
        gx = k / x ? min(n, k / (k / x)) : n;
        res -= (k / x) * (x + gx) * (gx - x + 1) / 2;
    }

    cout << res << endl;

    return 0;
}
```
  
##### AcWing200   Hankson的趣味题
```cpp
算法1
暴力枚举 b1b1 的所有约数

#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

int lcm(int a, int b)
{
    return a * 1ll * b / gcd(a, b);
}

int main()
{
    int n;
    scanf("%d", &n);

    while (n -- )
    {
        int a, b, c, d;
        scanf("%d%d%d%d", &a, &b, &c, &d);
        int s = 0;
        for (int i = 1; i * i <= d; i ++ )
        {
            if (d % i) continue;
            if (gcd(a, i) == b && lcm(c, i) == d)
                s ++ ;
            if (i != d / i && gcd(a, d / i) == b && lcm(c, d / i) == d)
                s ++ ;
        }
        printf("%d\n", s);
    }

    return 0;
}


算法2
先筛出 sqrt(b1)内的所有质数，再用试除法分解质因数，然后sqrt(b1)的所有约数，效率比暴力做法快了8倍左右。

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

typedef long long LL;
typedef pair<int, int> PII;

const int N = 45000, M = 50;

int primes[N], cnt;
bool st[N];

PII factor[M];
int cntf;

int divider[N], cntd;

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

void dfs(int u, int p)
{
    if (u > cntf)
    {
        divider[cntd ++ ] = p;
        return;
    }

    for (int i = 0; i <= factor[u].second; i ++ )
    {
        dfs(u + 1, p);
        p *= factor[u].first;
    }
}

int main()
{
    get_primes(N);

    int n;
    scanf("%d", &n);
    while (n -- )
    {
        int a0, a1, b0, b1;
        scanf("%d%d%d%d", &a0, &a1, &b0, &b1);

        int d = b1;
        cntf = 0;
        for (int i = 0; primes[i] <= d / primes[i]; i ++ )
        {
            int p = primes[i];
            if (d % p == 0)
            {
                int s = 0;
                while (d % p == 0) s ++, d /= p;
                factor[ ++ cntf] = {p, s};
            }
        }
        if (d > 1) factor[ ++ cntf] = {d, 1};

        cntd = 0;
        dfs(1, 1);

        int res = 0;
        for (int i = 0; i < cntd; i ++ )
        {
            int x = divider[i];
            if (gcd(x, a0) == a1 && (LL)x * b0 / gcd(x, b0) == b1)
            {

                res ++ ;
            }
        }

        printf("%d\n", res);
    }

    return 0;
}
```
 
##### AcWing201   可见的点
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 1010;

int primes[N], euler[N], cnt;
bool st[N];

// 质数存在primes[]中，euler[i] 表示
// i的欧拉函数
void get_eulers(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; j < cnt && i * primes[j] <= n; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0)
            {
                euler[i * primes[j]] = euler[i] * primes[j];
                break;
            }
            euler[i * primes[j]] = euler[i] * (primes[j] - 1);
        }
    }
}

int main()
{
    int T, n;

    get_eulers(N - 1);

    cin >> T;
    for (int k = 1; k <= T; k ++ )
    {
        cin >> n;
        int res = 0;
        for (int i = 2; i <= n; i ++ ) res += euler[i];
        printf("%d %d %d\n", k, n, res * 2 + 3);
    }

    return 0;
}
```
    

## 0x33 同余

     
  
##### AcWing202   最幸运的数字
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

LL mul(LL a, LL b, LL p)
{
    LL res = 0, t = a % p;
    while (b)
    {
        if (b & 1) res = (res + t) % p;
        t = (t + t) % p;
        b >>= 1;
    }

    return res;
}

LL qmi(LL m, LL k, LL p)
{
    LL res = 1, t = m;
    while (k)
    {
        if (k&1) res = mul(res, t, p);
        t = mul(t, t, p);
        k >>= 1;
    }
    return res;
}

int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

LL get_euler(LL x)
{
    auto res = x;
    for (int i = 2; i * i <= x; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);
    return res;
}

int main()
{
    LL l;
    for (int T = 1; ; T ++ )
    {
        cin >> l;
        if (!l) break;
        l = l * 9 / gcd(l, 8);
        auto euler = get_euler(l);

        LL res = 1e18;
        for (LL i = 1; i * i <= euler; i ++ )
            if (euler % i == 0)
            {
                if (qmi(10, i, l) == 1) res = min(res, i);
                if (qmi(10, euler / i, l) == 1) res = min(res, euler / i);
            }

        if (res > 1e16) res = 0;

        printf("Case %d: ", T);
        cout << res << endl;
    }

    return 0;
}
```

##### AcWing203   同余方程
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

LL exgcd(LL a, LL b, LL &x, LL &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    LL d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}

int main()
{
    LL a, b, x, y;
    cin >> a >> b;
    exgcd(a, b, x, y);

    cout << (x % b + b) % b << endl;

    return 0;
}
```
 
##### AcWing204   表达整数的奇怪方式
```cpp


```
  

## 0x34 矩阵乘法

     
  
##### AcWing205   斐波那契  
##### AcWing206   石头游戏       

## 0x35 高斯消元与线性空间

     
  
##### AcWing207   球形空间产生器  
##### AcWing208   开关问题  
##### AcWing209   装备购买  
##### AcWing210   异或运算    
     
## 0x36 组合计数

     
  
##### AcWing211   计算系数  
##### AcWing212   计数交换  
##### AcWing213   古代猪文  

## 0x37 容斥原理与Mobius函数

     
  
##### AcWing214   Devu和鲜花  
##### AcWing215   破译密码  
       
## 0x38 概率与数学期望

     
  
##### AcWing216   Rainbow的信号  
##### AcWing217   绿豆蛙的归宿  
##### AcWing218   扑克牌    
     
## 0x39 0/1分数规划

## 0x3A 博弈论之SG函数

     
  
##### AcWing219   剪纸游戏  
        
## 0x3B 总结与练习

     
##### AcWing220   最大公约数  
##### AcWing221   龙哥的问题  
##### AcWing222   青蛙的约会  
##### AcWing223   阿九大战朱最学  
##### AcWing224   计算器  
##### AcWing225   矩阵幂求和  
##### AcWing226   233矩阵  
##### AcWing227   小部件厂  
##### AcWing228   异或  
##### AcWing229   新NIM游戏


##### AcWing230   排列计数

    
##### AcWing231   天码
```cpp
#include <iostream>
#include <cstring>

using namespace std;

typedef long long LL;
const int N = 10010;

int n, numbers[N];

LL C(int n, int m)
{
    if (n < m) return 0;

    LL res = 1;
    for (int i = n, j = 0; j < m; j ++, i -- ) res *= i;
    for (int i = 1; i <= m; i ++ ) res /= i;
    return res;
}

int main()
{
    while(cin >> n)
    {
        memset(numbers, 0, sizeof numbers);

        for (int i = 0, t; i < n; i ++ )
        {
            cin >> t;
            numbers[t] ++ ;
        }

        LL res = C(n, 4);

        for (int i = 2; i < N; i ++ )
        {
            int ps = 0, x = i;
            for (int j = 2; j * j <= x; j ++ )
                if (x % j == 0)
                {
                    int s = 0;
                    while (x % j == 0) s ++, x /= j;
                    if (s > 1)
                    {
                        ps = -10;
                        break;
                    }
                    ps ++ ;
                }

            if (x > 1) ps ++ ;

            if (ps > 0)
            {
                int s = 0;
                for (int j = i; j < N; j += i) s += numbers[j];
                if (ps & 1) res -= C(s, 4);
                else res += C(s, 4);
            }
        }

        cout << res << endl;
    }
    return 0;
}
```
  
##### AcWing232   守卫者的挑战

##### AcWing233   换教室  
##### AcWing234   放弃测试  
##### AcWing235   魔法珠  
##### AcWing236   格鲁吉亚和鲍勃      
