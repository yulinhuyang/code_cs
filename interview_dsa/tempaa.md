参考：

[读书笔记]CSAPP深入理解计算机系统：https://zhuanlan.zhihu.com/p/103476182           
九曲阑干笔记：https://blog.csdn.net/qq_33034981/category_9806839.html        
南京大学 计算机系统基础(一) 袁春风： https://www.bilibili.com/video/BV1kE411X7S5       
南京大学 计算机系统基础（二） 袁春风： https://www.bilibili.com/video/BV1rE41127Re       
南京大学 计算机系统基础(三) 袁春风： https://www.bilibili.com/video/av74071598       


# 目录

**第1章　计算机系统漫游** 

1.1　信息就是位+上下文          
1.2　程序被其他程序翻译成不同的格式                 
1.3　了解编译系统如何工作是大有益处的    
1.4　处理器读并解释储存在内存中的指令    
1.4.1　系统的硬件组成        
1.4.2　运行hello程序      
1.5　高速缓存至关重要           
1.6　存储设备形成层次结构       
1.7　操作系统管理硬件       
1.7.1　进程       
1.7.2　线程       
1.7.3　虚拟内存       
1.7.4　文件       
1.8　系统之间利用网络通信       
1.9　重要主题       
1.9.1　Amdahl定律       
1.9.2　并发和并行       
1.9.3　计算机系统中抽象的重要性      

**第一部分   程序结构和执行**  
    
**第2章　信息的表示和处理**   

2.1　信息存储      
2.1.1　十六进制表示法
2.1.2　字数据大小
2.1.3　寻址和字节顺序
2.1.4　表示字符串
2.1.5　表示代码
2.1.6　布尔代数简介
2.1.7　C语言中的位级运算
2.1.8　C语言中的逻辑运算
2.1.9　C语言中的移位运算
2.2　整数表示
2.2.1　整型数据类型
2.2.2　无符号数的编码
2.2.3　补码编码
2.2.4　有符号数和无符号数之间的转换
2.2.5　C语言中的有符号数与无符号数
2.2.6　扩展一个数字的位表示
2.2.7　截断数字
2.2.8　关于有符号数与无符号数的建议
2.3　整数运算
2.3.1　无符号加法
2.3.2　补码加法
2.3.3　补码的非
2.3.4　无符号乘法
2.3.5　补码乘法
2.3.6　乘以常数
2.3.7　除以2的幂
2.3.8　关于整数运算的最后思考
2.4　浮点数
2.4.1　二进制小数
2.4.2　IEEE浮点表示
2.4.3　数字示例
2.4.4　舍入
2.4.5　浮点运算
2.4.6　C语言中的浮点数

**第3章　程序的机器级表示**

3.1　历史观点
3.2　程序编码
3.2.1　机器级代码
3.2.2　代码示例
3.2.3　关于格式的注解
3.3　数据格式
3.4　访问信息
3.4.1　操作数指示符
3.4.2　数据传送指令
3.4.3　数据传送示例
3.4.4　压入和弹出栈数据
3.5　算术和逻辑操作
3.5.1　加载有效地址
3.5.2　一元和二元操作
3.5.3　移位操作
3.5.4　讨论
3.5.5　特殊的算术操作
3.6　控制
3.6.1　条件码
3.6.2　访问条件码
3.6.3　跳转指令
3.6.4　跳转指令的编码
3.6.5　用条件控制来实现条件分支
3.6.6　用条件传送来实现条件分支
3.6.7　循环
3.6.8　switch语句
3.7　过程
3.7.1　运行时栈
3.7.2　转移控制
3.7.3　数据传送
3.7.4　栈上的局部存储
3.7.5　寄存器中的局部存储空间
3.7.6　递归过程
3.8　数组分配和访问
3.8.1　基本原则
3.8.2　指针运算
3.8.3　嵌套的数组
3.8.4　定长数组
3.8.5　变长数组
3.9　异质的数据结构
3.9.1　结构
3.9.2　联合
3.9.3　数据对齐
3.10　在机器级程序中将控制与数据结合起来
3.10.1　理解指针
3.10.2　应用：使用GDB调试器
3.10.3　内存越界引用和缓冲区溢出
3.10.4　对抗缓冲区溢出攻击
3.10.5　支持变长栈帧
3.11　浮点代码
3.11.1　浮点传送和转换操作
3.11.2　过程中的浮点代码
3.11.3　浮点运算操作
3.11.4　定义和使用浮点常数
3.11.5　在浮点代码中使用位级操作
3.11.6　浮点比较操作
3.11.7　对浮点代码的观察结论

**第4章　处理器体系结构**

4.1　Y86-64指令集体系结构
4.1.1　程序员可见的状态
4.1.2　Y86-64指令
4.1.3　指令编码
4.1.4　Y86-64异常
4.1.5　Y86-64程序
4.1.6　一些Y86-64指令的详情
4.2　逻辑设计和硬件控制语言HCL
4.2.1　逻辑门
4.2.2　组合电路和HCL布尔表达式
4.2.3　字级的组合电路和HCL整数表达式
4.2.4　集合关系
4.2.5　存储器和时钟
4.3　Y86-64的顺序实现
4.3.1　将处理组织成阶段
4.3.2　SEQ硬件结构
4.3.3　SEQ的时序
4.3.4　SEQ阶段的实现
4.4　流水线的通用原理
4.4.1　计算流水线
4.4.2　流水线操作的详细说明
4.4.3　流水线的局限性
4.4.4　带反馈的流水线系统
4.5　Y86-64的流水线实现
4.5.1　SEQ+：重新安排计算阶段
4.5.2　插入流水线寄存器
4.5.3　对信号进行重新排列和标号
4.5.4　预测下一个PC
4.5.5　流水线冒险
4.5.6　异常处理
4.5.7　PIPE各阶段的实现
4.5.8　流水线控制逻辑
4.5.9　性能分析
4.5.10　未完成的工作

**第5章　优化程序性能**

5.1　优化编译器的能力和局限性
5.2　表示程序性能
5.3　程序示例
5.4　消除循环的低效率
5.5　减少过程调用
5.6　消除不必要的内存引用
5.7　理解现代处理器
5.7.1　整体操作
5.7.2　功能单元的性能
5.7.3　处理器操作的抽象模型
5.8　循环展开
5.9　提高并行性
5.9.1　多个累积变量
5.9.2　重新结合变换
5.10　优化合并代码的结果小结
5.11　一些限制因素
5.11.1　寄存器溢出
5.11.2　分支预测和预测错误处罚
5.12　理解内存性能
5.12.1　加载的性能
5.12.2　存储的性能
5.13　应用：性能提高技术
5.14　确认和消除性能瓶颈
5.14.1　程序剖析
5.14.2　使用剖析程序来指导优化
5.15　小结

**第6章　存储器层次结构**

6.1　存储技术
6.1.1　随机访问存储器
6.1.2　磁盘存储
6.1.3　固态硬盘
6.1.4　存储技术趋势
6.2　局部性
6.2.1　对程序数据引用的局部性
6.2.2　取指令的局部性
6.2.3　局部性小结
6.3　存储器层次结构
6.3.1　存储器层次结构中的缓存
6.3.2　存储器层次结构概念小结
6.4　高速缓存存储器
6.4.1　通用的高速缓存存储器组织结构
6.4.2　直接映射高速缓存
6.4.3　组相联高速缓存
6.4.4　全相联高速缓存
6.4.5　有关写的问题
6.4.6　一个真实的高速缓存层次结构的解剖
6.4.7　高速缓存参数的性能影响
6.5　编写高速缓存友好的代码
6.6　综合：高速缓存对程序性能的影响
6.6.1　存储器山
6.6.2　重新排列循环以提高空间局部性
6.6.3　在程序中利用局部性


# 笔记

## CSAPP：[V]课程综述

https://csapp.cs.cmu.edu/

http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/index.html

推荐C的书本：Brian Kernighan和Dennis Ritchie的《The C Programming Language》。

**Great Reality 1：Ints are not Integers, Floats are not Reals**

当溢出发生时，值可能变成整数或者负数，但是结果通常是不正确的。
		
		计算机中，int是由若干位表示的，当结果超过这个位所能表示的极限时，就会发生溢出，使得计算结果错误。但是int始终满足交换律、结合律等。

计算机中，float的取值范围特别大，当两个相差特别大的数进行运算时，可能会使得较小的数字消失，所以不满足结合律。

int和float都存在一些不符合常理的特点，这是因为它们使用有限的位来表示数域中无穷的数。


**Great Reality 2：You've got to know assembly**

观察编写的C语言代码是如何变成机器码，以及如何在机器上执行的,Intel处理器的汇编语言，它最新版本是x86-64，指令集是64位版本的。

**Great Reality 3：Memory Matters**

```C++
typedef struct {
  int a[2];
  double d;
} struct_t;

double fun(int i) {
  volatile struct_t s;
  s.d = 3.14;
  s.a[i] = 1073741824; /* Possibly out of bounds */
  return s.d;
}
```

<center> <img src="https://pic4.zhimg.com/80/v2-989c0d7d3f7c71f7fe87aee0caabe39b_720w.jpg" style="zoom:80%" /> </center>
<center>数组的内存布局：</center>

fun(6)时，就会出现Segmentation fault。

内存引用错误主要是因为C和C++没有提供边界检查。

C和C++并没有提供内存保护，比如有超出边界的数组、非法的指针以及滥用的malloc/free通常都会造成bug，这个bug是否出现，还取决于你的系统和编译器，并且这个bug可能要运行很多次才会发现。这里你可能就需要根据内存的排列方式来对某个数据结构进行修改。

**Great Reality 4：There's more to performance than asymptotic complexity**

```cpp
# 代码一
void copyij(int src[2048][2048],
            int dst[2048][2048])
{
  int i,j;
  for (i = 0; i < 2048; i++)
    for (j = 0; j < 2048; j++)
      dst[i][j] = src[i][j];
}
# 代码二
void copyji(int src[2048][2048],
            int dst[2048][2048])
{
  int i,j;
  for (j = 0; j < 2048; j++)
    for (i = 0; i < 2048; i++)
      dst[i][j] = src[i][j];
}
```

代码一进行的是行优先，而代码二进行的是列优先的。但是在普通的系统中，代码一运行速度为4.3ms，而代码二运行速度为81.8ms，性能相差差不多20倍。


<center> <img src="https://pic1.zhimg.com/80/v2-f8c4d5db924eea1d6a316bf2a0a96330_720w.jpg" style="zoom:70%" /> </center>
<center>四种内存访问模式</center>


**Great Reality 5：Computers do more than execute programs**

https://pic1.zhimg.com/80/v2-9261fa5b390395e7b190ead4d369ff8c_720w.jpg

## CSAPP：第1章 计算机系统漫游

### 1.4　处理器读并解释储存在内存中的指令 

#### 1.4.1　系统的硬件组成 

<center> <img src="https://pic3.zhimg.com/80/v2-556a69b41b84eac82c1497a4b6f7a29e_720w.jpg" style="zoom:70%" /> </center>
<center>计算机硬件组成</center>

寄存器：通常为8位寄存器，用来保存一个字节的数据。CPU中有若干寄存器，每个寄存器都有唯一的地址，用来保存CPU中临时运算结果。其中有两个寄存器比较特殊：   

					指令地址寄存器：用来保存当前指令在内存中的地址，每次执行完一条指令后，会对该寄存器的值进行修改，指向下一条指令的地址。     
					指令寄存器：用来保存当前从主存中获取的，需要执行的指令。     

ALU：算术逻辑单元，主要用来处理CPU中的数学和逻辑运算。

#### 1.4.2　运行hello程序

<center> <img src="https://pic1.zhimg.com/80/v2-2cafa537bff05cc3e40cdaec022ec7b4_720w.jpg" style="zoom:70%" /> </center>
<center>程度的编译与执行</center>

gcc -o hello hello.c

预处理器：将源文件中以`#`开头的命令修改为原始的C程序。比如将`#include `替换成头文件`stdio.h`中的内容。

编译器：将C语言的`hello.i`翻译成汇编语言的`hello.s`。通过为不同语言不同系统上配置不同的编译器，能够提供通用的汇编语言，这样对于相同的语言，就能兼容不同的操作系统。

汇编器：将汇编语言写的`hello.s`翻译成由机器语言指令构成的`hello.o`，并保存成二进制文件。

链接阶段：通常会使用C标准库中提供的函数，但是我们代码中并没有这些函数的具体实现，所以就需要在链接阶段将该函数的具体实现合并到我们的`hello.o`。

**执行hello程序**

1. shell读入我们输入的字符`./hello`后，将其逐一读入到CPU的寄存器中，然后再将其存放到主存中。    
2. 输入回车后，shell执行一系列指令将hello目标文件中的代码和数据从磁盘复制到主存。    
3. CPU开始执行hello的main程序中的机器指令，它将`hello, world\n`字符串中的字节从主存复制到CPU寄存器，再从CPU寄存器复制到显示设备。  
   
### 1.5　高速缓存至关重要

局部性原理：程序具有访问局部区域内的数据和代码的趋势。

在单处理器系统中，一般含有二级缓存，最小的L1高速缓存速度几乎和访问存储器相当，大一些的L2高速缓存通过特殊总线连接到处理器，虽然比L1高速缓存慢，但是还是比直接访问主存来的快。在多核处理器中，还有一个L3高速缓存，用来共享多个核之间的数据。
