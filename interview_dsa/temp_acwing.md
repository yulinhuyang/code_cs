
**闫氏DP分析法**

闫氏DP分析法 + 背包九讲

核心思想：从集合角度考虑，所有的DP问题，本质上都是有限集中的最值问题

动态规划两个要点：状态与状态转移；阶段自然也应该有两个：状态表示和状态计算

状态表示：

	化零为整，把几个具有相同点的元素合在一起考虑，成为一个状态F(i)     
	集合：F(i)表示什么集合；     
	属性：F(i)存的数与集合的关系：如 max,min,count,sum 等
	
状态计算: 化整为零，将F(i)表示的集合

	将其划分为若干个子集，要求不重(针对涉及加和类型的属性)和不漏
	划分的依据：找最后一个不同点，如倒数第二个数是哪个数，考虑最后一步操作，据此划分集合   
	划分过后，求 F(i) 就可根据子集来求        
	例：当属性为 max 时，F(i)= max(子集的max); 当属性为 count 时，F(i)=∑(子集的count)
	
“DP的所有优化，都是对代码的恒等变形”—yxc
	
```C++
//0-1背包
F(i,j)
状态表示：
	集合：所有只考虑前i个物品，且总体积不超过的j的方案。     
	属性：题目要求我们求最大价值，则其属性就是max。    
状态计算：
	最后一个不同点就是最后一个物品选或不选。
	划分之后，分别求出左边和右边的最大值。
	左边集合在 F(i,j)内，且不包含i(不选)：F(i − 1,j)；
	右边集合，选i：max(F(i − 1,j − Vi)+Wi),但是不一定存在，需要判断 j≥Vi
	
最终：F(i,j)=max(F(i−1,j) , F(i−1,j−Vi)+Wi)

对于01背包，方程中 F(i,j) 只与 F(i−1,x) 有关，且 x ≤ j，可以滚动数组优化
//逆序循环
for 物品：   
	for 体积：  
		for 决策：
		
for (int i = 1; i <= n; i++) {
    for (int j = m; j >= v[i]; j--) {
        f[j] = max(f[j], f[j - v[i]] + w[i]);
    }
}
```

```C++
//完全背包问题
F(i,j)
状态表示：
	集合：所有只从前i个物品中选，总体积不超过j的所有方案。
	属性：max
状态计算：
	划分子集：最后一个物品可以选若干个，要把集合划分成若干个，分别代表不选第i种，选1个i，选两个i。
	第一个子集：不选，F(i−1,j)
	剩下的子集: 选k个第i种物品,F(i,j) = max(F(i−1,j− k*Vi)+k*Wi
	转移方程：F(i,j)=max(F(i−1,j) , F(i−1,j−Vi)+Wi , F(i−1,j−2Vi)+2Wi , …)
	简化依据：F(i,j−Vi)=max(F(i−1,j−Vi),F(i−1,j−2Vi)+Wi, F(i−1,j−3Vi)+2Wi , …)
	转换成两项形式：F(i,j)=max(F(i−1,j) , F(i,j−Vi)+Wi)

滚动优化：
for (int i = 1; i <= n; i++) {
    for (int j = v[i]; j <= m; j++) {
        f[j] = max(f[j], f[j - v[i]] + w[i]);
    }
}	
```

```C++
//合并石子问题
F(i,j)
状态表示：
	集合：所有将区间[i,j]合并成一堆的方案集合。
	属性：题目求的是最小值，所以min。
状态计算：
	最后一个不同点，合并到[i,j]时，一定是由两个区间[i,k]和[k,j]合并而来的，且k∈[i,j]
	以这个分界点 k 为划分依据，分成 j−i 类。
	两个区间互不干扰，所以两边取min，两边恰好是 F(i,k)和 F(k+1,j)。
	F(i,j) = 两个子区间的最小代价 + 这部分石子的总质量
	F(i,j)=min( F(i,k+1)+F(k+1,j) )+Sj−Si−1 ，S是石子重量的前缀和。

枚举区间长度： 
	枚举左边界l:
		枚举分界点k:
		
for (int len = 2; len <= n; len ++ )
    for (int l = 1; l + len - 1 <= n; l ++ )
    {
        int r = l + len - 1;
        f[l][r] = INF;
        for (int k = l; k < r; k ++ )
            f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);
    }	
```

```C++
//最长公共子序列
状态表示：
	集合：所有A[1,i]与B[1,j]的公共子序列的集合
	属性：max
	
状态计算：
	f[i,j] = max(f[i-1,j],f[i,j-1],f[i-1,j-1]+1)
```

