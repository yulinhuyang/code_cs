
#### 3.9.3　数据对齐

**对齐原则**是任何K字节的基本对象的地址必须是K的倍数

![img](pics/v2-eb000636c4b38f3a342fe7cb97cd13f5_720w.jpg)

为此，在`struct`中两个连续的对象，编译器可能中间会插入间隙，来满足各自对内存地址的要求。并且还有**两个额外的要求：**

- 要求结构的初始地址一定是结构体中最大对象大小的倍数，使得偏移量加上初始地址才是真的满足倍数关系的。
- 在结构体末尾填充，使其是结构体中最大对象大小的倍数，使得结构数组中下一个元素的地址也是成倍数关系的。

![img](pics/v2-48b8732ad7e07f17a2a3dd5b3ba6debf_720w.jpg)

我们可以画图把一个个对象依次填充进去，并且要求它的偏移量是满足K的倍数。然后考虑要在末尾填充多少字节能够使得总共大小是最大对象大小的倍数。最终最大对象的大小就是对初始地址的对齐要求。

### 3.10　在机器级程序中将控制与数据结合起来

**x86-64内存分布**

真实物理内存通过操作系统将其映射虚拟内存，从程序员的角度，内存就被抽象为一个很大的字节数组，每个元素是一个字节。在86-64机器上，64位二进制数为该数组地址进行编码，意味着64位操作系统最大能容纳2^64字节的内存大小。

虚拟内存存储数据也是分不同区域的，如下图所示（不是按比例绘制的），地址从下到上依次递增。

<center> <img src="pics/v2-7cd7264f28d58a9be5e57315ad683345_720w.jpg" style="zoom:80%" /> </center>     


- **Stack**：在Linux中，将栈放置在整个地址空间的最顶部，用于函数调用，及**局部变量**的存储，这样随着函数的运行，栈顶就能向低地址不断扩展。常用系统中栈的大小是8MB，可通过命令`limit`查看，如果用栈指针访问超过8MB范围的地址，就会出现**段错误（Segmentation Fault）**。 相同程序的栈的分配是固定的。
- **Shared Libraries：**类似于`printf`和`malloc`的这类**库函数**平时是被存储在磁盘上的，当我们程序需要使用库函数时，就会在程序开始执行时，将它们加载到你的程序中，这称为**动态加载（Dynamic Linking**）。
- **Heap：**用来存放通过**`malloc`、`callc`或`new`**等申请的变量，这些变量在程序运行时会动态变化。当你不断通过`malloc`申请空间又没释放时，堆顶的指针就不会断向高地址增加，使得占用的内存不断变多。堆在分配时是具有随机性的。
- **Data：**该数据区用来存放程序开始时分配的数据，你声明的**全局变量、静态变量或字符常量等**都在这个数据段中。
- **Text：**根据可执行目标文件的内容进行初始化，是放置你的可执行程序的位置。这部分区域是只读的。

以以下代码为例

<center> <img src="pics/v2-e9b39aed2190b7332b488809d7aa9f86_720w.jpg" style="zoom:80%" /> </center>     


`big_array`、`huge_array`和`global`是全局变量，因此存储在Data区中。`useless`和`main`是函数，因此存放在Text中。`main`函数中的`p1`、`p2`、`p3`、`p4`是通过`malloc`申请空间的，所以保存在Heap区。`local`是局部变量，所以保存在Stack区中。

![img](pics/v2-099c9cdd9067127ab3261927732da30f_720w.jpg)

我们可以发现，通过`malloc`申请的变量，较小的会保存到靠近Data区，而较大的会保存到靠近Stack极限的位置。由于Heap中有部分还没有申请，所以如果尝试引用Heap中空白的区域，会产生段错误。

#### 3.10.1　理解指针

如果指针通过`&`创建，表示获得某个对象的地址，在机器代码中对应于`leaq`。如果指针通过*进行访问，表示访问该指针指向的对象的值，在机器代码中对应于内存引用。    
特殊的NULL(0)表示该指针不指向任何值。    

通过int *p;定义了一个int *类型的指针p，则通过p获取对象内容时，就会获取4字节数据作为该对象内容。

同样可以声明**函数指针**，表示指向函数在机器代码中的第一条指令的内存地址

```c
T (*fp)(arg1T, arg2T,...);
```

其中，`T`为函数的返回值类型，`arg1T`表示第一个参数的类型，以此类推。然后将函数名赋值给该函数指针，就能直接通过该函数指针调用函数了。

#### 3.10.2　应用：使用GDB调试器

#### 3.10.3　内存越界引用和缓冲区溢出

#### 3.10.4　对抗缓冲区溢出攻击

**使用安全函数**

gets函数有一个问题就是不知道返回的数据大小是否超过缓冲区的栈空间，如果溢出的话会导致返回地址错误，程序会跳转到意想不到的地方。

因为fgets有一个用来指定程序最多可以读取多少字节的参数，如果输入的字节超过这个数字，就会对其进行截断。
可以使用strncpy代替strcpy。要注意不要直接使用scanf的%s来读取字符串，要么使用fgets代替，要么使用%ns来指定最多可以输入多长的字符串。

- 保护机制一：地址空间布局随机化，程序的不同部分会被加载到内存的不同区域
- 保护机制二：栈破坏检测，在缓冲区与栈保护中间加一个金丝雀值，在函数返回时判断金丝雀值是否变化来判断是否有错误
- 保护机制三：栈中的页可以被设置属性为可读、可写、不可执行，通过限制可执行代码区域来放置缓冲区溢出

#### 3.10.5　支持变长栈帧

为了管理变长栈帧，x86-64代码使用`%rbp`作为**帧指针（Frame Pointer）**。进入函数时，先将其存入到“保存寄存器区”，然后将当前的栈指针`%rsp`的值赋予`%rbp`，则函数最后可直接通过将`%rbp`的值赋予`%rsp`就能释放变长的栈帧，并且通过“保存寄存器区”来重置`%rbp`的值。

### 3.11　浮点代码

通过SSE提供的XMM寄存器和AVX提供的YMM寄存器来对浮点数进行SIMD运算。

包含的寄存器如下所示

<center> <img src="pics/v2-7f63e705303a129f273ae3e69c0935a2_720w.jpg" style="zoom:90%" /> </center>     

一个XMM寄存器，可以满足16个char、8个short、4个int、4个float和2个double同时进行操作，也就实现了SIMD运算。

#### 3.11.1　浮点传送和转换操作

![img](pics/v2-8ef5d9a4bbbb619fdc61cba12a78d246_720w.jpg)

浮点数-->整型：

![img](pics/v2-776546f2367e4f91596fc797ef302450_720w.jpg)

前面的`cvt`表示转换（convert），后一个`t`表示截断（truncated）。在将浮点数转换成整数时，指令会执行截断，把值向0进行舍入。可以发现这些都是标量指令。

整型-->浮点数：

![img](pics/v2-c8819c28968805c2f29c911eb931bcac_720w.jpg)

#### 3.11.2　过程中的浮点代码

- 函数传入的浮点数，或者函数使用浮点数进行计算时，都需要使用上述寄存器。也可以使用栈来传递额外的浮点参数。
- %xmm0既是函数第一个参数的寄存器，也是函数返回值的寄存器
- 所有寄存器都是“调用者保存寄存器”，所以函数要先将这些值保存在内存中，才去调用别的函数。

注意：参数到寄存器的映射取决于参数的顺序和类型。如果是整型或指针，就使用通用寄存器，如果是浮点数，就使用XMM寄存器。

#### 3.11.3　浮点运算操作

提供一组执行算数运算你的标量AVX2浮点指令

<center> <img src="pics/v2-ae8bf8cbbbb8f00fb50753e46c03b5e1_720w.jpg" style="zoom:90%" /> </center>     

每条指令可以有一个源操作数或两个源操作数，以及一个目的操作数。其中，第一个源操作数可以是XMM寄存器或内存位置，而第二个操作数和目的操作数只能是XMM寄存器。

注意：当计算中出现整型、float和double混合时，需要将整型和float都转换成double再计算。

#### 3.11.4　定义和使用浮点常数

和整数运算操作不同，AVX浮点操作不能用立即数作为常数。编译器会为浮点常数分配和初始化存储空间，然后代码再从内存中读取这些值。

## 第4章　处理器体系结构 

### 4.1　Y86-64指令集体系结构

#### 4.1.1　程序员可见的状态

硬件描述语言（Hardware Description Language，HDL）可以用来描述硬件结构，是一种文本语言，类似于编程语言，包括Verilog和VHDL。

实现一个数字系统主要有三个组成部分：

- 1 计算对位进行操作的函数的组合逻辑
- 2 存储位的存储器单元
- 3 控制存储器单元更新的时钟信号

#### 4.1.2　Y86-64指令

### 4.2　逻辑设计和硬件控制语言HCL

#### 4.2.1　逻辑门

将很多逻辑门组合成一个实现某种功能的网，就能构成**计算块（Computational block）**，称为**组合电路（Combinational Circuits）**。想要构建有效的组合电路，有以下**限制：**

- 每个逻辑门的输入必须连接到以下其中之一：

- - 一个系统输入
  - 某个存储器单元的输出
  - 某个逻辑门的输出

- 两个或多个逻辑门的输出不能连接在一起

- 网络不能形成回路

#### 4.2.2　组合电路和HCL布尔表达式

**例1：**

![img](pics/v2-6b50cc9e2e510812c5b8c1dbf62451c9_720w.jpg)

**HCL表达式：**`bool eq = (a && b) || (!a && !b);`

**功能：**用来判断输入`a`和`b`是否相同，结果保存在`eq`中。

**例2：**

![img](pics/v2-31bce23d064b38eff5577bfb23d7448c_720w.jpg)

**HCL表达式：**`bool out = (s && a) || (!s && b);`

**功能：**该组合电路称为**多路复用器（Multiplexor，MUX）**， 当`s=1`时，`out`的值就是`a`的值；当`s=0`时，`out`值就是`b`的值。

**HCL表达式和C语言逻辑表达式区别：**

- `=`在HCL表达式中表示给表达式赋予的名字
- 组合电路中输出会持续相应输入的变化，而C语言只有在程序执行过程中遇到了才进行求职
- 逻辑门只允许对0和1进行操作，而C语言将0表示为FASLE，将其余任意值表示为TRUE
- C语言中存在部分求值的特点，组合逻辑中不存在

#### 4.2.5　存储器和时钟

为了产生时序电路（Sequential Circuit），即存在状态并且能在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。而这些存储设备是由同一个具有周期性信号的时钟控制的，决定什么时候将新值保存到存储器中。

主要有两类存储器设备：

- **时钟寄存器（寄存器）：**存储单个位或字，主要作为电路不同部分的组合逻辑之间的屏障。

- **随机访问存储器（内存）：**存储多个字，用地址来选择读写哪个字。**包括：**

- - **处理器的虚拟内存系统：**通过操作系统对存储器进行抽象，使得处理器可以在很大的地址空间中访问，地址为虚拟内存的索引值。
  - **寄存器文件：**是一个以寄存器标识符为地址，存储着对应程序寄存器值的随机访问存储器。在IA32或Y86-64处理器中，有15个程序寄存器（`%rax`~`%r14`）。

这里要注意区分机器级编程中的寄存器和硬件中的寄存器

- **硬件：**寄存器指的是时钟寄存器，直接将它的输入和输出连接到电路的其他部分。这里称为硬件寄存器。
- **机器级编程：**寄存器代表的是存储在寄存器文件中的，CPU中少数可寻址的字，地址为寄存器标识符。这里称为程序寄存器。

### 4.3　Y86-64的顺序实现
#### 4.3.1　将处理组织成阶段
#### 4.3.2　SEQ硬件结构

我们可以得到顺序实现的SEQ抽象视图

![img](pics/v2-7bc4c0445975a2aa00465089e82ceb90_720w.jpg)

- 数据内存和指令内存都是在相同的内存空间中，只是根据不同的功能对其进行划分
- 寄存器文件包含两个读端口`A`和`B`，以及两个写端口`M`和`E`，分别接收来自内存的值`valM`以及ALU计算的结构`valE`。
- PC更新的值可能来自于：下一条指令地址`valP`、来自内存的值`valM`、调用指令或跳转指令的目标地址`valC`。

更加详细的图如下所示

![img](pics/v2-0fcb524cf8794ef3640b17ef5779785a_720w.jpg)

- 白色方框为时钟寄存器；蓝色方框为硬件单元，当做黑盒子而不关心细节设计；白色圆圈表示线路名字。
- 宽度为字长的数据使用粗线；宽度为字节或更窄的数据用细线；单个位的数据用虚线，主要表示控制值。
- 灰色圆角矩形表示控制逻辑块，能在不同硬件单元之间传递数据，以及操作这些硬件单元，使得对每个不同的指令执行指定的运算。是本章的重点，会给出对应的HCL表达式。

#### 4.3.3　SEQ的时序
#### 4.3.4　SEQ阶段的实现

### 4.4　流水线的通用原理

#### 4.4.1　计算流水线
#### 4.4.2　流水线操作的详细说明
#### 4.4.3　流水线的局限性
#### 4.4.4　带反馈的流水线系统

### 4.5　Y86-64的流水线实现

#### 4.5.1　SEQ+：重新安排计算阶段

![img](pics/v2-0186c3d90add46649d7efbce39352c5e_720w.jpg)

对应的SEQ+硬件结构如下图所示，可以发现将更新PC阶段移到了时钟周期开始的位置。

![img](pics/v2-14b32da251541d94dff7e5a2f3ab6ce0_720w.jpg)

我们可以在各个阶段中加入流水线寄存器，并将信号重新排列来将SEQ+转换成初步的流水线处理器PIPE-，硬件结构如下图所示

![img](pics/v2-f411a0fb3cdbb173ed5e5f257552a642_720w.jpg)

#### 4.5.2　插入流水线寄存器
#### 4.5.3　对信号进行重新排列和标号
#### 4.5.4　预测下一个PC
#### 4.5.5　流水线冒险

流水线冒险主要包含数据冒险和控制冒险，当程序状态的读写**不处于同一阶段**，就可能出现数据冒险，当出现分支预测错误或`ret`指令时，会出现控制冒险。

在Y86-64中，程序状态包含程序寄存器、内存、条件码寄存器和状态寄存器。程序寄存器的读取处于译码阶段，而写入处于写回阶段，因此程序寄存器会出现数据冒险的可能，以以下代码为例

![img](pics/v2-660fd508757184e2c3741cc534bf5cda_720w.jpg)

#### 4.5.6　异常处理
#### 4.5.7　PIPE各阶段的实现
#### 4.5.8　流水线控制逻辑
#### 4.5.9　性能分析
#### 4.5.10　未完成的工作


## 第5章　优化程序性能

参考：https://zhuanlan.zhihu.com/p/107369491

- 使用内联方式来优化函数调用问题   
- **优化方法：**  
  - 基本编码原则：
	- 消除连续的函数引用：识别要执行多次（比如在循环内）但是计算结果不会改变的计算，将该计算移到前面。同时也考虑减少循环中函数的调用。
	-消除不必要的内存引用：当在循环中使用指针时，会反复对内存进行读写，我们可以引入一个临时变量来保存中间结果，使其保存在寄存器中，就无需涉及内存引用了，最终再将寄存器中的值保存到指针中。

  - 低级优化：

    - **kx1循环展开：**一个循环中计算多个操作，减少需要的循环次数，能减少不必要的操作，但是没有消除数据相关，无法突破延迟界限。
    - **kxk循环展开：**声明多个独立变量，在循环中独立计算，能减少循环次数，并使用多个功能单元及其流水线，能消除数据相关突破延迟界限。当 k  >= C X L时接近吞吐量界限，其中C为操作容量、L为操作延迟。
    - **重新结合：**通过修改结合方法，来减少目标寄存器上的操作，由此减少关键路径上的操作数。
    - 反复测试代码，使得汇编代码产生条件传送。

- 上下相同寄存器才会构成一段数据相关链   
- 注意：延迟是指执行一个操作所需的时钟周期，但是由于功能单元存在流水线，所以可以每个时钟周期都开始一个操作。只有当两个操作之间存在数据相关时，无法使用流水线了，才考虑操作的延迟。   
- 数据相关是针对寄存器而言的   
- 要在更大范围观察写/读相关，不一定存在一个迭代中，可能在相邻迭代中，只要发现有存储操作，而后执行相同地址的加载操作，就会有写/读相关。  

