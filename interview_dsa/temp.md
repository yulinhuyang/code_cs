**数字三角形模型:**

AcWing1015 摘花生: dp[i][j]=max(dp[i-1][j],dp[i][j-1])+s[i][j];

Acwing1018 最低通行费:


**最长上升子序列模型:**

双向LIS：AcWing1017 怪盗基德滑翔翼

折线LIS：AcWing1014 登山问题

AcWing1010 拦截导弹：最长LIS + LIS数目

最长上升子序列 II --子序列数目：贪心  
	开一个q[]记录所有下降子序列末尾元素，q[]一开始是空集，长度为0，遍历每个数，对于当前这个数：  
	情况1：在q[]中若找不到比这个数更小的数，扩大q[]长度并记录这个数  
	情况2：在q[]中可以找到比这个数小的最大的数, 则将它覆盖到所找到的位置上

AcWing187 导弹防御系统 dfs + 上升下降子序列


**背包DP：**

		for 物品：   
			for 体积：  
				for 决策：  

当空间优化为1维之后，只有完全背包问题的体积是从小到大循环的。

二维数组的时候，循环顺序无所谓

完全背包：求所有前缀的最大值

多重背包：求滑动窗口内的最大值

acwing6 多重背包问题3：

dp[i][j] = max(dp[i-1][j], dp[i-1][j-v] + w, dp[i-1][j-2*v] + 2*w,..., dp[i-1][j-k*v] + k*w)

多重背包问题3单调队列优化： https://www.acwing.com/solution/content/6500/


二维费用问题：AcWing8 二维背包

AcWing12 背包问题求具体方案： 相当于图论最短路径,反向回推(求最大n->1,再求方案1->n)

AcWing11 背包问题求方案数：记录法 

AcWing10 有依赖的背包：树形dp + 分组背包

AcWing7 混合背包：完全+0-1背包

AcWing532 货币系统：凑零钱问题，F[i]表示ai~ai-1可以凑出来ai


**状态机模型：**

用状态机表示状态，可以类比状态压缩

AcWing1049 大盗阿福：0-1 状态机

https://www.acwing.com/solution/content/23723/

		0 不抢(自循环) <----> 1 抢

		f[i][0] = max(f[i - 1][0], f[i - 1][1]);
		f[i][1] = f[i - 1][0] + w[i];
		
AcWing1057 股票买卖IV：

	0 手中有货 <------->1 手中无货
	
	dp[i][j][0]:最多进行j次交易的情况下，第i天结束后，手中不持股的最大利润
	dp[i][j][1]:最多进行j次交易的情况下，第i天结束后，手中持股的最大利润
	初始化：dp[0][i][1] = -INF 因为第0天结束后不可能持股
	注意：卖股票不算交易次数，注意状态转移方程。
		
	dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1] + w[i]);
	dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0] - w[i]);
	
	初始化状态：0合法，-INF不合法
	
AcWing1058 股票买卖V：

	0-1-2 状态机
	
	f[i][0]=max(f[i-1][0],f[i-1][2]-a[i]);
	f[i][1]=f[i-1][0]+a[i];
	f[i][2]=max(f[i-1][1],f[i-1][2]);

AcWing 1053. 修复DNA： Ac自动机= Trie + KMP

**状态压缩DP:**

棋盘式(基于连通性)：预处理

AcWing1064 骑士：井格，左右不存在相邻的1，上下不存在相邻两位a&b，斜线不存在a|b

AcWing327 玉米田：十字，左右不存在相邻的1，上下不存在相邻两位a&b

AcWing292 炮兵阵地：十字延伸，
    
	if ((a & b) | (b & c) | (a & c))continue;
    if (g[i - 1] & a | g[i] & b) continue

**区间DP:**

AcWing 1068 环形石子合并：破环成链，枚举len + 循环双指针l r + 循环枚举k(l~r)

AcWing 1069 凸多边形的划分: 固定好一个边，就确定了两个点，那么再连一个点就构成一个三角形。f[L,R] = min(f[L,R],f[L,K] + f[K,R]+w[L]*w[K]*w[R])

AcWing 321 棋盘切割: 记忆化搜索。f[x1][y1][x2][y2][k]

**树形DP:**

AcWing 1072 树的最长路径：dfs 次大+最大

在树中任选一个节点a,找到距离这个节点的最远的节点u,之后再找到距离u最远的节点v,那么u-v之间的距离就是整个树的最大距离。

AcWing 1075 数字转换: 首先预处理出每个数的约数之和,可以对每一个合法的路径进行建边,最后就可以转化为求树的最长路径问题。

AcWing 1074 二叉苹果树：f[i][j]表示枚举i节点的子树选择j个树枝的最大价值

没有上司的舞会：树形dp状态机，最大独立集。

战略游戏：树形dp状态机，每条边必选一个点。

AcWing 1077 皇宫看守： 

	f[i][0] += min(f[j][1], f[j][2]); 父节点看护
	f[i][1] = min(f[i][1], sum - min(f[j][1], f[j][2]) + f[j][2]); 子节点看护
	f[i][2] += min(min(f[j][0], f[j][1]), f[j][2]);

**数位DP: **

用来解决一类特定问题，这种问题比较好辨认，一般具有这几个特征：

要求统计满足一定条件的数的数量（即，最终目的为计数）；这些条件经过转化后可以使用「数位」的思想去理解和判断；输入会提供一个数字区间（有时也只提供上界）来作为统计的限制；上界很大（比如 ），暴力枚举验证会超时。

技巧1：区间转化，[X,Y] == f(Y) - f(X-1)

技巧2：树的方式考虑

AcWing1081 度的数量:init+dp(拆位->分类讨论)

AcWing1082 数字游戏

AcWing1083 Windy数

**单调队列DP:**

单调队列辅助进行序列的窗口中F[i]单调值的存储

AcWing135 最大子序和: 长度不超过m的区间中找最值，前缀和+滑动窗口+dp，

AcWing1088 旅行问题: 拆环为链+顺时针一遍+逆时针一遍+前缀和+单调队列区间最小值

AcWing1089 烽火传递：f[i]表示前1~i座烽火台满足条件，且第i座烽火台点燃的方案集合

f[i] = min(f[j])+wi

AcWing1090 绿色通道：二分判定 + 烽火台

AcWing1087 修剪草坪：f[i] = s[i] + f[j-1]-s[j],队列中f[j-1] - s[j]最大的

AcWing1091 理想正方形：先逐行滑窗n的最大最小值存储到row_max[i]和row_min[i],再逐列滑窗n的最大最小值存储b[j]和c[j],再遍历所有列求max(b[j] - c[j])。


**BFS**

-Flood Fill

计算连通图，可以基于BFS,也可以基于DFS(可能爆栈)

AcWing1097 池塘计数：八连通遍历，枚举bfs flood fill + bool st判重

AcWing1098 城堡问题: 四连通遍历，枚举bfs flood fill + bool st判重

AcWing1106 山峰和山谷：八连通遍历，二维循环,枚举bfs flood fill + bool st判重

**最短路模型**

图中权都是1的时候，可以bfs求最短路径

证明：单调性、两段性

AcWing1076 迷宫问题：反向搜，pair<int,int> st[N][N] 记录路径+判重

AcWing188 武士风度的牛：走日遍历，dist[x][y]+1

AcWing 1100 抓住那头牛:

**多源BFS**

加一个虚拟源点，把多个源连接起来；队列初始化后，把所有距离为1的点加进来,初始化为0

两段性：x x x;x+1 x+1 x+1,队列中只有x和x+1两种  -->单调性：每次队头元素出来的时候就是最小值了

AcWing173 矩阵距离:队列初始化后，把所有距离为1的点加进来,初始化为0

**最小步数模型**

最小步数模型：将整个“图”视为一个状态也即一个节点. 状态的转移视为权值为1的边.

AcWing1107 魔板：按照a->b->c顺序拓展，一定可以找到最小字典序的操作，unordered_map<string,pair<char,string>> pre 记录转移路径和操作

**双端队列广搜**

边权是0或1，边权为0的边，队头入队，边权为1的边，队尾入队

扩展之后仍然满足两段性，单调性

AcWing175 电路维修：双端队列bfs

**双向广搜**

优化效果明显，可以优化最小步数模型：方式有A一步，B一步或者每次选择当前队列中元素较少的方向拓展。

unordered_map<string, int> da, db：分别记录从起点状态（状态：这里是字符串）到中间某状态的最小步数，从终点状态到中间某状态的最小步数。

两个队列，q[a]和q[b]，来分别进行bfs：while(qa.size() && qb.size())

标志位t来记录双向广搜是否相遇：结构结果是两者之和

AcWing190 字串变换：双向广搜

**A***

BFS的队列换成优先队列；

队列中存储的元素包含的信息：1.当前状态 2. 从起点到当前点的真实距离 + 从当前点到终点的估计距离;

每次选择预测距离最小的点扩展。

	while(!q.empty())
	{
		t <-- 优先队列的队头；
		当终点第一次出队时，break;
		for t的所有邻边：
			将邻边入队
	}

A*处理的边权非负就可以，估计距离必须 <= 真实距离;

只能保证终点出队的时候，距离是最优的。

BFS入队时判重，Dijkstra出队的时判重，A*出队时不判重。

AcWing179 八数码问题

bfs or A*，逆序对数量偶数有解，奇数无解。

对八数码问题的一些补充：https://www.acwing.com/solution/content/45382/

1.采用曼哈顿距离之和作为启发式时可以保证每一个结点出队时都已经找到了它的最优路径

估价函数:以任意“状态”为输入，计算出从该状态到目标状态所需代价的估计值。

估价函数:当前状态中每个数与它的目标位置的曼哈顿距离之和。

AcWing178 第k短路：



**DFS**

优点：栈思路，代码短，比BFS简单和快

缺点：层数太多的时候，有可能爆栈

深搜的两类模型：一类是棋盘上能否到达某个点（内部搜索），一个是某个状态的棋盘能否转移成另外一个状态的棋盘（棋盘整体作为一个状态，外部搜索）。

是否恢复现场：内部搜索不需要恢复，外部搜索整体作为一个状态需要恢复现场。

**连通性模型**

AcWing1112 迷宫：DFS判断可达性，判断是否。

AcWing1113 红与黑：DFS的floodfill问题，返回cnt个数。

**搜索顺序**

AcWing1116 马走日：回溯，系统栈帮忙模拟的，搜索树，每个棋盘状态都是一个节点。

AcWing1117 单词接龙：最短重合前后缀

AcWing1118 分成互质组：如果ai和组内数都互质，将ai加入当前组；如果ai不符合条件，需要重新开一组

**剪枝与优化**

1 优化搜索顺序：大部分情况下，应优先搜索分支（选择策略）较少的节点。 
2 排除等效冗余 
3 可行性剪枝 
4 最优性剪枝 
5 记忆化搜索(DP)

AcWing165 小猫爬山：优先放重猫；超过当前最优答案则停止。

AcWing166 数独：位运算剪枝，选择分支最少的格子。

AcWing167 木棒：优化搜索顺序，从大到小枚举；排除等效冗余（按照组合数方式枚举；如果当前木棍加到当前棒中失败，则后面略过所有长度相等的木棍；如果木棒的第一根木棍失败了，则进行回溯）

AcWing168 生日蛋糕 


**迭代加深**

某些层特别深，但是答案在比较浅的层里面，可以迭代加深搜，while(!dfs(1,k)) k++。

AcWing170 加成序列：迭代加深，优先枚举较大的数，排除等效冗余。枚举所有选择，枚举选择i：u-1->0,j：i->0。

**双向DFS**

用空间换时间，先暴搜前一半，结果存下来，然后暴搜后一半，去表中二分查找。

AcWing171 送礼物(dfs+二分)：先将所有物品按重量从大到小排序；先将前K件物品凑出的所有重量打表，然后排序去重；搜索剩下的N-K件物品的选择方式，然后在表中二分出不超过w的最大值。

**IDA***

结合迭代加深，在每个搜索树节点的位置，估计当前点到目标点超过了迭代加深的上限max_step,则从当前节点continue。

AcWing180 排书：估价函数，错后继数量。枚举长度[l,r]放在k的后面去。

AcWing181 回转游戏：估价函数（8-cnt（中间相同数的个数），不枚举上一次的逆操作。
