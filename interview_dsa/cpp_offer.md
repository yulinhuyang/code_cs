# 剑指offer + 专项突破版拓展

# 0x00 基本算法

## 0x01 位运算
- 15 二进制中1的个数(191 位1的个数) 
- 43 1～n 整数中 1 出现的次数(233 数字 1 的个数)
- 65 不用加减乘除做加法
- Offer II 2 二进制加法(67 二进制求和)
- Offer II 3 前n 个数字二进制中1的个数(338 比特位计数)
- Offer II 4 只出现一次的数字(137 只出现一次的数字 II)

- Offer II 5 单词长度的最大乘积(318 最大单词长度乘积)
- Offer II 70 排序数组中只出现一次的数字(540 有序数组中的单一元素)

##### Offer 56 - I. 数组中数字出现的次数

```C++
class Solution {
public:
    vector<int> singleNumbers(vector<int> &nums) {
        int one = 0;
        for (auto &num:nums) {
            one ^= num;
        }
        int index = 1;
        while ((one & index) == 0) {
            index <<= 1;
        }
        int first = 0, second = 0;
        for (auto &num:nums) {
            if (num & index) first ^= num;
            else second ^= num;
        }
        return {first, second};
    }
};
```
#####  Offer 56 - II. 数组中数字出现的次数 II

```C++
class Solution {
public:
    int singleNumber(vector<int> &nums) {
        vector<int> bit(32, 0);
        for (auto &num:nums) {
            int pos = 0;
            while (num) {
                if (num & 1) bit[pos]++;
                num = num >> 1;
                pos++;
            }
        }
        int res = 0;
        for (int i = 0; i < 32; i++) {
            if (bit[i] %= 3) {
                res |= 1 << i;
            }
        }
        return res;
    }
};
```

##### Offer 65. 不用加减乘除做加法

异或： 不进位加法

```C++
class Solution {
public:
    int add(int a, int b) {
        while(b){
            int sum = a ^ b;//所有不进位和
            int carry = (unsigned int)(a & b) << 1;//所有进位
            a = sum;
            b = carry;
        }
        return a;
    }
};

```

## 0x02 递归与模拟

- 17 打印从1到最大的n位数
- 44 数字序列中某一位的数字(400 第 N 位数字)
- 56_I 数组中数字出现的次数
- 56_II 数组中数字出现的次数 II
- 61 扑克牌中的顺子 
- 64 求 1+2+3+...+n 
- Offer II 1 整数除法(29 两数相除)

##### Offer 44. 数字序列中某一位的数字

模拟，数位计数问题

```C++
class Solution
{
public:
    int findNthDigit(int n)
    {
        long long start = 1;
        long long digit = 1;
        long long count = 9;
        while (n > count)
        {
            n -= count;
            start *= 10;
            digit += 1;
            count = 9 * digit * start;
        }
        long long res = start + (n - 1)/digit;
        return to_string(res)[(n - 1) % digit] - '0';
    }
};

```

##### offer II 318 最大单词长度乘积

位运算预处理 + 模拟

```C++
class Solution {
public:
    int maxProduct(vector<string> &words) {
        int m = words.size();
        unordered_map<int, int> hash;
        for (auto &word:words) {
            int t = 0, n = word.size();
            for (int i = 0; i < n; i++) {
                int pos = word[i] - 'a';
                t |= 1 << pos;
            }
            if (!hash.count(t) || hash[t] < n) hash[t] = n;
        }
        int res = 0;
        for (auto &w1:hash) {
            for (auto &w2:hash) {
                if (!(w1.first & w2.first)) {
                    res = max(res, w1.second * w2.second);
                }
            }
        }
        return res;
    }
};

```

## 0x03 前缀和与差分
- Offer II 10 和为 k 的子数组(560. 和为 K 的子数组)
- Offer II 11 0和1个数相同的子数组(525 连续数组)
- Offer II 12 左右两边子数组的和相等(724 寻找数组的中心下标)
- Offer II 13 二维子矩阵的和(304 二维区域和检索 - 矩阵不可变)

## 0x04  二分和三分
- 4 二维数组中的查找(240 搜索二维矩阵 II): 先去掉干扰条件相等的数,折线分析法。
- 11 旋转数组的最小数字(154 寻找旋转排序数组中的最小值 II)
- 16 数值的整数次方(50 Pow(x, n))
- 53_I 在排序数组中查找数字 I(34 在排序数组中查找元素的第一个和最后一个位置)
- 53_II 0～n-1中缺失的数字

- Offer II 68 查找插入位置(35 搜索插入位置)
- Offer II 69 山峰数组的顶部(852 山脉数组的峰顶索引)
- Offer II 73 狒狒吃香蕉(875 爱吃香蕉的珂珂)
- Offer II 72 求平方根(69 x 的平方根)

##### 4. 二维数组中的查找 

```C++
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        if(matrix.size() == 0){
            return 0;
        }
        int m = matrix.size();
        int n = matrix[0].size();
        int i = 0,j = n - 1;
        while(i <= m - 1  && j >= 0){
            if(matrix[i][j] == target){
                return  true;
            }else if(matrix[i][j] < target){
                i++;
            }else{
                j--;
            }
        }
        return  false;
    }
};
```
##### 11 旋转数组的最小数字

```C++
class Solution {
public:
    int minArray(vector<int>& numbers) {
        int n = numbers.size() - 1;
        while(n > 0 && numbers[0] == numbers[n]) n--;
        if(numbers[0] <= numbers[n]) return numbers[0];
        int l = 0,r = n;
        while(l < r){
            int mid = l + r >> 1;
            if(numbers[mid] <= numbers[n]) r = mid;
            else l = mid + 1;
        }
        return numbers[l];
    }
};
```

## 0x05 双指针与排序  
- 57 和为s的两个数字
- 57_II 和为s的连续正数序列
- 66 构建乘积数组

### 双指针

- Offer II 6 排序数组中两个数字之和(167 两数之和 II - 输入有序数组)
- Offer II 7 数组中和为0的三个数(15 三数之和)
- Offer II 8 和大于等于target的最短子数组(209. 长度最小的子数组)
- Offer II 9 乘积小于 K 的子数组(009. 乘积小于 K 的子数组)


##### Offer 57  和为s的两个数字

典型双指针算法

```C++
class Solution {
public:
    vector<int> twoSum(vector<int> &nums, int target) {
        int m = nums.size();
        for (int i = 0, j = m - 1; i < j;) {
            while (nums[i] + nums[j] > target) j--;
            while (nums[i] + nums[j] < target) i++;
            if (nums[i] + nums[j] == target) return {nums[i],nums[j]};
        }
        return {0,0};
    }
};
```


##### Offer 66. 构建乘积数组

双向遍历

```C++
class Solution {
public:
    vector<int> constructArr(vector<int>& a) {
        if(a.empty()) return {};
        int n = a.size();
        vector<int> res(n,0);
        res[0] = 1;
        for(int i = 1, p = a[0];i < n;i++){
            res[i] = p;
            p *= a[i];
        }
        
        for(int i = n - 2,p = a[n - 1];i > -1;i--){
            res[i] *= p;
            p *= a[i];
        }
        return res;
    }
};
```


### 排序  
- 21 调整数组顺序使奇数位于偶数前面 
- 45 把数组排成最小的数 
- 51 数组中的逆序对
- Offer II 75 数组相对排序(1122 数组的相对排序)
- Offer II 76 数组中的第 k 大的数字(215 数组中的第K个最大元素)

#####  Offer 40. 最小的k个数

y总 快速排序 和 快速选择 模板： https://www.acwing.com/blog/content/8597/

快排模板：    

    int i = l - 1, j = r + 1, x = q[l + r >> 1];       
    双指针划分               
    i,j 两指针相遇后，只有两种情况，(1) i == j; (2) i > j             
    递归两侧要用j     
         
快选模板： 
   
    if (k <= j - l + 1) return quick_select(nums, l, j, k);       
    else return quick_select(nums, j + 1, r, k - (j - l + 1));      
    
    
```C++
//快选模板
int quick_select(int q[], int l, int r, int k) {
    // 当数组为空时，quick_sort(q, 0, len(q) - 1)中l = 0, r = -1, 会出现 l > r的情况
    // 除了 一开始 需要判断 l > r, 以后 只需要 判断 l == r 即可
    // 因为 快速选择 传进来的 序列 最少有一个元素, 所以 一般 len(q) >= 1, 不用判断 l > r 也可以
    // 除了 len(q) == 0 会造成 一开始 l > r 之外，以后return 的时候 肯定有 l == r
    if (l >= r) return q[l];

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j) // i,j 两指针相遇后，只有两种情况，(1) i == j; (2) i > j
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }

    if (j - l + 1 >= k) return quick_select(q, l, j, k);
    else return quick_select(q, j + 1, r, k - (j - l + 1));
}
```

    
```C++
class Solution {
public:
    vector<int> getLeastNumbers(vector<int> &arr, int k) {
        quickSort(arr, 0, arr.size() - 1);
        vector<int> res;
        for (int i = 0; i < k; i++) {
            res.emplace_back(arr[i]);
        }
        return res;
    }

    void quickSort(vector<int> &arr, int l, int r) {
        if (l >= r) return;
        int i = l - 1, j = r + 1, x = arr[l + r >> 1];
        while (i < j) {
            do { i++; } while (arr[i] < x);
            do { j--; } while (arr[j] > x);
            if (i < j) swap(arr[i], arr[j]);
        }
        quickSort(arr, l, j);
        quickSort(arr, j + 1, r);
    }
};
```

##### offer 51 数组中的逆序对

归并排序模板， res += (mid - i + 1);

```C++
class Solution {
    int res;
public:
    int reversePairs(vector<int> &nums) {
        int m = nums.size();
        int l = 0, r = m - 1;
        mergeSort(nums, l, r);
        return res;
    }

    void mergeSort(vector<int> &nums, int l, int r) {
        if (l >= r) return;
        int mid = l + r >> 1;
        mergeSort(nums, l, mid);
        mergeSort(nums, mid + 1, r);

        vector<int> tmp(r - l + 1, 0);
        int k = 0, i = l, j = mid + 1;
        while (i <= mid && j <= r) {
            if (nums[i] <= nums[j]) tmp[k++] = nums[i++];
            else {
                res += (mid - i + 1);
                tmp[k++] = nums[j++];
            }
        }
        while (i <= mid) tmp[k++] = nums[i++];
        while (j <= r) tmp[k++] = nums[j++];
        for (int i = l, j = 0; i <= r; i++, j++) nums[i] = tmp[j];
    }
};
```


### 滑动窗口
- Offer II 008 和大于等于 target的最短子数组
- Offer II 14 字符串中的变位词(567 字符串的排列)
- Offer II 15 字符串中的所有变位词(438 找到字符串中所有字母异位词)
- Offer II 16 不含重复字符的最长子字符串(3 无重复字符的最长子串)
- Offer II 17 含有所有字符的最短字符串(76 最小覆盖子串)
- Offer II 57 值和下标之差都在给定的范围内(220 存在重复元素 III)

##### Offer 57 - II  和为s的连续正数序列

双指针可变滑窗

```C++
class Solution {
public:
    vector<vector<int>> findContinuousSequence(int target) {
        vector<vector<int>> res;
        int i = 1, j = 2;
        int sum = i + j;
        while (i < j && j < target) {
            while (sum < target) sum += ++j;
            
            if (sum == target) {
                vector<int> tmp;
                for (int k = i; k <= j; k++) {
                    tmp.emplace_back(k);
                }
                res.emplace_back(tmp);
            }
            sum -= i++;
        }
        return res;
    }
};
```

#####  Offer II 008 和大于等于 target的最短子数组

滑窗和/积满足某种条件区间的两类解法：

1  双指针 可变滑窗：先扩j后缩i，外扩j内缩i ；          
2  前缀和+二分(向后搜索)                 

```C++
//双指针 可变滑窗法
class Solution {
public:
    int minSubArrayLen(int target, vector<int> &nums) {
        if (target < 1) return 0;
        int m = nums.size();
        int sum = 0, ans = INT_MAX;
        for (int i = 0, j = 0; j < m; j++) {
            sum += nums[j];
            while (sum >= target && i <= j) {
                sum -= nums[i];
                ans = min(ans, j - i + 1);
                i++;
            }
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```


```C++
//前缀和+二分
class Solution {
    int binaryLeft(int target, vector<int> &nums, int l, int r) {
        while (l < r) {
            int mid = l + r >> 1;
            if (nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        return l;
    }

public:
    int minSubArrayLen(int target, vector<int> &nums) {
        int m = nums.size();
        vector<int> sum(m + 1, 0);
        for (int i = 1; i < m + 1; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
        int ans = INT_MAX;
        for (int i = 1; i < m + 1; i++) {
            int tmp = target + sum[i - 1];
            int j = binaryLeft(tmp, sum, i, m);
            if (sum[j] >= tmp) ans = min(ans, j - i + 1);
        }

        return ans == INT_MAX ? 0 : ans;
    }
};
```


##### leetcode  724. 寻找数组的中心下标

前缀和

```C++
class Solution {
public:
    int pivotIndex(vector<int> &nums) {
        int total = accumulate(nums.begin(), nums.end(), 0);
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (2 * sum + nums[i] == total) {
                return i;
            }
            sum += nums[i];
        }
        return -1;
    }
};
```

### 回文串
- Offer II 18 有效的回文(125 验证回文串)
- Offer II 19 最多删除一个字符得到回文(680 验证回文字符串 Ⅱ)
- Offer II 20 回文子字符串的个数(647 回文子串)


### Cycle Sort  
- 3 数组中重复的数字:圈排序
- 50 第一个只出现一次的字符
- Offer II 071 按权重生成随机数(528 random-pick-with-weight)

##### Offer 03 数组中重复的数字
```C++
map/set计数法

class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        set<int> numSet;
        for(auto num:nums){
            if(numSet.count(num)){
                return num;
            } else{
                numSet.emplace(num);
            }
        }
        return 0;
    }
};

反复交换法：

class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        int n = nums.size() - 1;
        for(int i = 0;i <= n;i++){
            if(nums[i] < 0 || nums[i] > n) return -1;
        }
        for(int i = 0;i <= n;i++){
            while(nums[i]!= i){
                if(nums[i] == nums[nums[i]])
                    return nums[i];
                swap(nums[i],nums[nums[i]]);
            }
        }
        return -1;
    }
};
```

## 0x06 贪心

- 14 剪绳子 
- Offer II 74 合并区间(56 合并区间)

# 0x10 基本数据结构

## 0x11 栈/单调栈
- 9 用两个栈实现队列
- 30 包含min函数的栈(155 最小栈)
- 31 栈的压入、弹出序列(946 验证栈序列)
- Offer II 36 后缀表达式(150 逆波兰表达式求值)
- Offer II 37 小行星碰撞(735 行星碰撞)
- Offer II 38 每日温度(739 每日温度)
- Offer II 39 直方图最大矩形面积(84 柱状图中最大的矩形)
- Offer II 40 矩阵中最大的矩形(85 最大矩形)


##### 9. 用两个栈实现队列
```C++
class CQueue {
    stack<int> a;
    stack<int> b;
public:
    CQueue() {
    }

    void appendTail(int value) {
        a.emplace(value);
    }

    int deleteHead() {
        if(b.size() == 0){
            int m = a.size();
            for (int i = 0; i < m; i++) {
                b.emplace(a.top());
                a.pop();
            }
        }
        if(b.empty()){
            return -1;
        } else{
            auto res = b.top();
            b.pop();
            return res;
        }
    }
};
```
##### leetcode 946 验证栈序列

先push，再判pop,节省最后一次的循环后判断。

```C++
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        if(pushed.size()!= popped.size()) return false;
        stack<int> stk;
        int j = 0;
        for(int i = 0;i < pushed.size();i++){
            stk.push(pushed[i]);
            while(!stk.empty() && stk.top() == popped[j]){
                stk.pop();
                j++;
            }
        }
        return stk.empty();
    }
};
```


## 0x12 队列/单调队列

- 59_I 滑动窗口的最大值(239 滑动窗口最大值)
- 59_II 队列的最大值
- Offer II 41 滑动窗口的平均值(346 plus)
- Offer II 42 最近请求次数(933 最近的请求次数)

#####  Offer II 041 滑动窗口的平均值

队列

```C++
class MovingAverage {
    deque<int> q;
    int capacity;
    double sum = 0;
public:
    /** Initialize your data structure here. */
    MovingAverage(int size) {
        capacity = size;
    }

    double next(int val) {
        q.emplace_back(val);
        sum += val;
        if (q.size() > capacity) {
            sum -= q.front();
            q.pop_front();
        }
        return sum / q.size();
    }
};
```
##### Offer II 42 最近的请求次数

队列应用

```C++
class RecentCounter {
    deque<int> q;
public:
    RecentCounter() {
    }

    int ping(int t) {
        q.emplace_back(t);
        while (q.front() < t - 3000) q.pop_front();
        return q.size();
    }
};

```

## 0x13 链表与邻接表

- 6 从尾到头打印链表:递归法，也可以用栈缓存再弹出，递归的本质就是栈
- 18_1 在 O(1) 时间内删除链表节点 
- 18_2 删除链表中重复的结点 
- 22  链表中倒数第k个节点
- 23  链表中环的入口结点 
- 24  反转链表(206 反转链表) 
- 25  合并两个排序的链表(21 合并两个有序链表) 
- 35  复杂链表的复制(138 复制带随机指针的链表) 
- 52  两个链表的第一个公共节点(160 相交链表)
- Offer II 21 删除链表的倒数第 n 个结点(19 删除链表的倒数第 N 个结点)
- Offer II 22 链表中环的入口节点(142 环形链表 II)
- Offer II 23 两个链表的第一个重合节点(160 相交链表)
- Offer II 24 反转链表(206 反转链表)
- Offer II 25 链表中的两数相加(445 两数相加 II)
- Offer II 26 重排链表(143 重排链表)
- Offer II 27 回文链表(234 回文链表)
- Offer II 28 展平多级双向链表(430 扁平化多级双向链表)
- Offer II 29 排序的循环链表(708 plus)
- Offer II 77 链表排序(148 排序链表)
- Offer II 78 合并排序链表(23 合并K个升序链表)
 

##### Offer 06 从尾到头打印链表
```C++
//递归法
class Solution {
    vector<int> res;
    void reverse(ListNode* head){
        if(head == nullptr){
            return;
        }
        reverse(head->next);
        res.emplace_back(head->val);
    }
public:
    vector<int> reversePrint(ListNode* head) {
        reverse(head);
        return res;
    }
};
```
## 0x14 hash
- Offer II 30 插入、删除和随机访问都是 O(1) 的容器(380 O(1) 时间插入、删除和获取随机元素)
- Offer II 32 有效的变位词(242 有效的字母异位词)
- Offer II 33 变位词组(49 字母异位词分组)
- Offer II 34 外星语言是否排序(953 验证外星语词典)
- Offer II 35 最小时间差(539 最小时间差)
- Offer II 31 最近最少使用缓存(146 LRU 缓存)
- Offer II 119 最长连续序列(128 最长连续序列)


## 0x15 字符串(KMP与最小表示法）   
- 5 替换空格 
- 20 表示数值的字符串 
- 46 把数字翻译成字符串 
- 67 把字符串转换成整数(8 字符串转换整数 (atoi)) 
- 58_I 翻转单词顺序(151 颠倒字符串中的单词)
- 58_II 左旋转字符串

##### Offer 05 替换空格
```C++
class Solution {
public:
    string replaceSpace(string s) {
        string output;
        for(auto chr:s){
            if(chr == ' '){
                output += "%20";
            } else{
                output += string(1,chr);
            }
        }
        return output;
    }
};
```

##### Offer 45. 把数组排成最小的数

自定义排序：
        static bool cmp(string a,string b){
            return a + b < b + a;
        }
        
```C++
class Solution {
    static bool cmp(string a,string b){
        return a + b < b + a;
    }
public:
    string minNumber(vector<int>& nums) {
        
        vector<string> nums_strs;
        for(auto & num:nums){
            nums_strs.emplace_back(to_string(num));
        }
        sort(nums_strs.begin(),nums_strs.end(),cmp);
        string res;
        for(auto & num_str:nums_strs){
            res += num_str;
        }
        return res;
    }
};
```
##### Offer 58 - II. 左旋转字符串

```C++
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        int len = s.size();
        string res;
        for(int i = n;i < len + n;i++){
            res.push_back(s[i % len]);
        }
        return res;
    }
};
```


## 0x16  Trie树（字典树）
- Offer II 62 实现前缀树(208 实现 Trie (前缀树))
- Offer II 63 替换单词(648 单词替换)
- Offer II 64 神奇的字典(676 实现一个魔法字典)
- Offer II 65 最短的单词编码(820 单词的压缩编码)
- Offer II 66 单词之和(677 键值映射)
- Offer II 67 最大的异或(421 数组中两个数的最大异或值)

## 0x17 二叉堆 
- 40 最小的k个数
- 41_1 数据流中的中位数(295 数据流的中位数)
- 41_2 字符流中第一个不重复的字符
- Offer II 59 数据流的第 K 大数值(703 数据流中的第 K 大元素)
- Offer II 60 出现频率最高的 k 个数字(347 前 K 个高频元素)
- Offer II 61 和最小的 k 个数对(373 查找和最小的 K 对数字)

## 0x21 树与图的遍历

### 树的遍历   
- 7 重建二叉树(105 从前序与中序遍历序列构造二叉树)
- 8 二叉树的下一个结点
- 26 树的子结构 
- 27 二叉树的镜像(226 翻转二叉树) 
- 28 对称的二叉树(101 对称二叉树) 
- 32_I 从上往下打印二叉树 
- 32_II 从上到下打印二叉树 II(102 二叉树的层序遍历) 
- 32_III 从上到下打印二叉树 III(按之字形顺序)
- 33 二叉搜索树的后序遍历序列 
- 34 二叉树中和为某一值的路径 
- 36 二叉搜索树与双向链表(426 plus) 
- 37 序列化二叉树(297 二叉树的序列化与反序列化) 
- 54 二叉搜索树的第k大节点
- 55_I 二叉树的深度(104 二叉树的最大深度)
- 55_II 平衡二叉树(110 平衡二叉树)
- 68_I 二叉搜索树的最近公共祖先(235 二叉搜索树的最近公共祖先)
- 68_II 二叉树的最近公共祖先(236 二叉树的最近公共祖先)
- Offer II 43 往完全二叉树添加节点(919 完全二叉树插入器)
- Offer II 44 二叉树每层的最大值(515 在每个树行中找最大值)
- Offer II 45 二叉树最底层最左边的值(513 找树左下角的值)
- Offer II 46 二叉树的右侧视图(199 二叉树的右视图)
- Offer II 47 二叉树剪枝(814 二叉树剪枝)
- Offer II 48 序列化与反序列化二叉树(297 二叉树的序列化与反序列化)
- Offer II 49 从根节点到叶节点的路径数字之和(129 求根节点到叶节点数字之和)
- Offer II 50 向下的路径节点之和(437 路径总和 III)
- Offer II 51 节点之和最大的路径(124 二叉树中的最大路径和)
- Offer II 52 展平二叉搜索树(897 递增顺序搜索树)
- Offer II 53 二叉搜索树中的中序后继(285 plus)：比p大的最小的数
- Offer II 54 所有大于等于节点的值之和(538 把二叉搜索树转换为累加树)
- Offer II 55 二叉搜索树迭代器(173 二叉搜索树迭代器)
- Offer II 56 二叉搜索树中两个节点之和(653 两数之和 IV - 输入 BST)


##### offer 26 树的子结构

双递归：recur + isSubStructure

```C++
class Solution {
public:
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if(!A && !B) return true;
        if(!A ||!B) return false;
        return recur(A,B) || isSubStructure(A->left,B) || isSubStructure(A->right,B);
    }

    bool recur(TreeNode* A, TreeNode* B) {
        if(!B) return true;
        if(!A || A->val != B->val){
            return false;
        }
        return recur(A->left,B->left) && recur(A->right,B->right);
    }

};
```

##### offer 54 二叉搜索树的第k大节点

dfs 二叉树

```C++
class Solution {
    int res;
public:
    int kthLargest(TreeNode *root, int k) {
        dfs(root, k);
        return res;
    }

    void dfs(TreeNode *root, int &k) {
        if (!root || k == 0) return;
        dfs(root->right, k);
        k--;
        if (k == 0) {
            res = root->val;
            return;
        }
        dfs(root->left, k);
    }
};
```

##### offer 33 二叉树的后序遍历序列

dfs区间遍历树

```C++
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        int l = 0;
        int r = postorder.size() - 1;
        return dfs(postorder,l,r);
    }

    bool dfs(vector<int>& postorder,int l,int r){
        if(l > r) return true;
        int root = postorder[r];
        int k = l;
        while(postorder[k] < root) k++;
        for(int j = k; j < r;j++){
            if(postorder[j] < root) {
                return false;
            }
        }
        return dfs(postorder,l,k - 1) && dfs(postorder,k,r - 1);
    }
};
```

##### Offer 68 - I  二叉搜索树的最近公共祖先LCA

```C++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root || root == p || root == q) return root;
        auto left = lowestCommonAncestor(root->left,p,q);
        auto right = lowestCommonAncestor(root->right,p,q);

        if(!left) return right;
        if(!right) return left;
        return root;
    }
};

```
##### Offer 68 - II. 二叉树的最近公共祖先LCA

```C++
class Solution {
public:
    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {
        auto ancestor = root;
        while (ancestor) {
            if (ancestor->val < p->val && ancestor->val < q->val) {
                ancestor = lowestCommonAncestor(root->right, p, q);
            } else if (ancestor->val > p->val && ancestor->val > q->val) {
                ancestor = lowestCommonAncestor(root->left, p, q);
            } else {
                break;
            }
        }

        return ancestor;
    }
};
```
##### Offer II 053 二叉搜索树中的中序后继

```C++
class Solution {
public:
    TreeNode *inorderSuccessor(TreeNode *root, TreeNode *p) {
        TreeNode *ans = NULL;
        while (root) {
            //比p大的最小的数
            if (root->val > p->val) {
                ans = root;
                root = root->left;
            } else {
                root = root->right;
            }
        }
        return ans;
    }
};
```


## 0x22 DFS(递归、回溯)
- 12 矩阵中的路径(79 单词搜索): dfs四方向遍历，回溯做选择（修改涂色变量相当于push_back）
- 29 顺时针打印矩阵(54 螺旋矩阵)
- 38 字符串的排列

- Offer II 79 所有子集(78 子集)
- Offer II 80 含有 k 个元素的组合(77 组合)
- Offer II 81 允许重复选择元素的组合(39 组合总和)
- Offer II 82 含有重复元素集合的组合(40 组合总和 II)
- Offer II 83 没有重复元素集合的全排列(46 全排列)
- Offer II 84 含有重复元素集合的全排列(47 全排列 II)

##### offer 12 矩阵中的路径

回溯做选择（修改涂色变量相当于push_back），不是floodfill

```C++
class Solution {
public:
    int m, n;
    int dx[4] = {0, 0, -1, 1}, dy[4] = {-1, 1, 0, 0};

    bool exist(vector<vector<char>> &board, string word) {
        if (!board.size() || board[0].empty()) return false;
        m = board.size(), n = board[0].size();
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                if (dfs(board, i, j, word, 0))
                    return true;
        return false;
    }

    bool dfs(vector<vector<char>> &board, int i, int j, string word, int u) {
        if (board[i][j] != word[u]) return false;
        if (u == word.size() - 1) return true;

        board[i][j] = '.';
        for (int k = 0; k < 4; k++) {
            int newI = i + dx[k], newJ = j + dy[k];
            if (newI >= 0 && newI <= m - 1 && newJ >= 0 && newJ <= n - 1)
                if(dfs(board, newI, newJ, word, u + 1)) return true;
        }
        board[i][j] = word[u];
        return false;
    }
};
```

##### offer 38 字符串的排列

相同的位置不要再选其他的相同元素

```C++
class Solution {
    vector<string> res;
    string path;
    vector<int> visit;
public:
    vector<string> permutation(string s) {
        visit.resize(s.size());
        sort(s.begin(), s.end());
        dfs(0, s);
        return res;
    }

    void dfs(int index, string s) {
        if (index == s.size()) {
            res.emplace_back(path);
            return;
        }
        for (int i = 0; i < s.size(); i++) {
            if (visit[i]) continue;
            path.push_back(s[i]);
            visit[i] = true;
            dfs(index + 1, s);
            visit[i] = false;
            path.pop_back();
            while (i + 1 < s.size() && s[i] == s[i + 1]) i++;
        }
    }
};
```

## 0x23 BFS

- 13 机器人的运动范围
- Offer II 107 矩阵中的距离(542 01 矩阵)
- Offer II 108 单词演变(127 单词接龙)
- Offer II 109 开密码锁(752 打开转盘锁)
- Offer II 110 所有路径(797 所有可能的路径)
- Offer II 111 计算除法(399 除法求值)
- Offer II 112 最长递增路径(329 矩阵中的最长递增路径)


##### Offer 13 机器人的运动范围
```C++
class Solution {
    int get(int x) {
        int res = 0;
        for (; x; x /= 10) {
            res += x % 10;
        }
        return res;
    }

public:
    int movingCount(int m, int n, int k) {
        if(!k){
            return  1;
        }
        queue<pair<int, int>> queue;
        vector<pair<int, int>> dirs = {{-1, 0},
                                       {1,  0},
                                       {0,  -1},
                                       {0,  1}};
        vector<vector<int>> visited(m,vector<int>(n,0));
        int ans = 1;
        queue.emplace(make_pair(0, 0));
        visited[0][0] = 1;
        while (!queue.empty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                auto pos = queue.front();
                queue.pop();
                for (auto dir:dirs) {
                    int newX = pos.first + dir.first;
                    int newY = pos.second + dir.second;
                    if (newX < 0 || newX > m - 1 || newY < 0 || newY > n - 1 || get(newX) + get(newY) > k || visited[newX][newY]) {
                        continue;
                    }
                    queue.emplace(make_pair(newX, newY));
                    visited[newX][newY] = 1;
                    ans += 1;
                }
            }
        }
        return ans;
    }
};
```

## 0x30 数学知识

- 14 不修改数组找出重复的数：抽屉原理
- 14_I 剪绳子(343 整数拆分)
- 14_II 剪绳子 II
- 39 数组中出现次数超过一半的数字(169 多数元素)
- 62 圆圈中最后剩下的数字
- Offer II 71 按权重生成随机数(528 按权重随机选择)


##### 14-I  剪绳子

```C++
class Solution {
public:
    int cuttingRope(int n) {
        if(n <= 3){
            return n - 1;
        }
        int a = n / 3;
        int b = n % 3;
        if(b == 0) return pow(3,a);
        if(b == 1) return pow(3,a - 1)*4;
        return pow(3,a)*2;

    }
};
```

##### Offer 62 圆圈中最后剩下的数字

f(n, m) = (f(n−1, m) + m) % n     
f(n, m)表示，n个人报数，每报到m时杀掉那个人，返回最终胜利者的编号

```C++
class Solution {
public:
    int lastRemaining(int n, int m) {
        if(n == 1) return 0;
        //f(n, m)表示，n个人报数，每报到m时杀掉那个人，返回最终胜利者的编号
        return (lastRemaining(n - 1,m) + m) % n;
    }
};

```


## 0x41  数据结构进阶 - 并查集

- Offer II 116 省份数量(547 省份数量)
- Offer II 118 多余的边(684 冗余连接)
- Offer II 117 相似的字符串(839 相似字符串组)

## 0x50 动态规划
- 10_I 斐波那契数列 
- 10_II 青蛙跳台阶问题(70 爬楼梯)
- 19 正则表达式匹配(10 正则表达式匹配)
- 42 连续子数组的最大和(53 最大子数组和) 
- 47 礼物的最大价值 
- 48 最长不含重复字符的子字符串(3 无重复字符的最长子串)
- 49 丑数(264 丑数 II) 
- 60 n个骰子的点数
- 63 股票的最大利润(121 买卖股票的最佳时机)
- Offer II 86 分割回文子字符串(131 分割回文串)
- Offer II 87 复原 IP(93 复原 IP 地址)
- Offer II 88 爬楼梯的最少成本(746 使用最小花费爬楼梯)
- Offer II 89 房屋偷盗(198 打家劫舍)
- Offer II 90 环形房屋偷盗(213 打家劫舍 II)
- Offer II 91 粉刷房子(256 plus)
- Offer II 92 翻转字符(926 将字符串翻转到单调递增)
- Offer II 93 最长斐波那契数列(873 最长的斐波那契子序列的长度)
- Offer II 94 最少回文分割(132 分割回文串 II)
- Offer II 95 最长公共子序列(1143 最长公共子序列)
- Offer II 96 字符串交织(97 交错字符串)
- Offer II 97 子序列的数目(115 不同的子序列)
- Offer II 98 路径的数目(62 不同路径)
- Offer II 99 最小路径之和(64 最小路径和)
- Offer II 100 三角形中最小路径之和(120 三角形最小路径和)
- Offer II 101 分割等和子集(416 分割等和子集)
- Offer II 102 加减的目标值(494 目标和)
- Offer II 103 最少的硬币数目(322 零钱兑换)
- Offer II 104 排列的数目(377 组合总和 Ⅳ)
- Offer II 105 岛屿的最大面积(695 岛屿的最大面积)

##### 10.1 斐波那契数列 
```C++
class Solution {
public:
    int fib(int n) {
        if(n == 0) return 0;
        if(n == 1) return 1;
        long fb0 = 0;
        long fb1 = 1;
        for (int i = 2; i <= n; i++) {
            auto tmp = fb0 + fb1;
            fb0 = fb1;
            fb1 = tmp % 1000000007;
        }
        return fb1 % 1000000007;
    }
};
```

##### Offer 46 把数字翻译成字符串

闫氏dp分析法总结：

https://www.acwing.com/file_system/file/content/whole/index/content/406072/

https://www.acwing.com/blog/content/19060/

https://www.cnblogs.com/IzayoiMiku/p/13635809.html

求方案数count: +

```C++
class Solution {
public:
    int translateNum(int num) {
        string s = to_string(num);
        int n = s.size();
        vector<int> f(n + 1, 0);
        f[0] = 1;
        f[1] = 1;
        for (int i = 2; i < n + 1; i++) {
            f[i] = f[i - 1];
            int t = 10 * (s[i - 2] - '0') + s[i - 1] - '0';
            if (t >= 10 && t <= 25) {
                f[i] = f[i - 1] + f[i - 2];
            }
        }
        return f[n];
    }
};

```
#####  Offer 60. n个骰子的点数

分组背包问题模板

```C++
class Solution {
public:
    vector<double> dicesProbability(int n) {
        //前i次投总和是j的方式
        vector<vector<int>> f(n + 1, vector<int>(6 * n + 1, 0));
        //分组背包
        f[0][0] = 1;
        for (int i = 1; i < n + 1; i++)//物品组
        {
            for (int j = 1; j < 6 * n + 1; j++)//体积
            {
                for (int k = 1; k <= 6; k++) {//选择 1-6
                    if (j >= k) f[i][j] += f[i - 1][j - k];
                }
            }
        }

        vector<int> tmp(f[n].begin() + n, f[n].end());
        int sum = accumulate(tmp.begin(), tmp.end(), 0);
        vector<double> res;
        for (int i = 0; i < tmp.size(); i++) {
            res.emplace_back((double) tmp[i] / (double) sum);
        }
        return res;
    }
};
```



## 0x60 图论

- Offer II 58 日程表(729 我的日程安排表 I)
- Offer II 113 课程顺序(210 课程表 II)
- Offer II 114 外星文字典(269 plus)
- Offer II 115 重建序列(444 plus)
- Offer II 106 二分图(785 判断二分图)






