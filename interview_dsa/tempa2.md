### 1.6　存储设备形成层次结构

<center> <img src="https://pic2.zhimg.com/80/v2-5baf6d3c4dfc3497d4abf87e5359eae1_720w.jpg" style="zoom:70%" /> </center>
<center>存储器层次结构</center>

存储器层次结构的主要思想是将上一层的存储器作为下一层存储器的高速缓存。程序员可以利用对整个存储器层次结构的理解来提高程序性能。  
     
### 1.7　操作系统管理硬件  

#### 1.7.1　进程

> 内核：操作系统常驻内存的部分，不是一个独立的进程，而是管理全部进程所用代码和数据结构的集合。

操作系统通过交错执行若干个程序的指令，不断地在进程间进行切换来提供这种错觉，这个称为并发运行。

首先，当进程A要切换到进程B时，进程A通过系统调用，将控制权递给操作系统，然后操作系统会保存进程A所需的所有状态信息，称为上下文，比如寄存器以及内存内容，然后创建进程B及其上下文，然后将控制权递给进程B。当进程B终止后，操作系统就会恢复进程A的上下文，并将控制权还给进程A，这样进程A就能从断点处继续执行。这个过程都是由操作系统的内容进行控制的。   

#### 1.7.2　线程

现代系统中，一个进程中可以并发多个线程，每条线程并行执行不同的任务，线程是操作系统能够进行运算调动的最小单位，是进程中的实际运作单位。每个线程运行在进程的上下文中，并共享相同的代码和全局数据。优点：多线程之间比多进程之间更容易共享数据，并且效率更高。		
		
解析：这里一个进程中可以并发多个线程，指的是一个进程一次只能运行一个线程，但是一个进程可以同时含有多个线程，每个线程可以执行不同的任务，进程让线程之间快速切换来达到并发线程。

> 注意：并发运行中每次还是只能运行一个单位，但是通过快速切换来达到同时运行多个单位的错觉。		     

#### 1.7.3　虚拟内存

程序运行在从0开始的连续虚拟内存空间中，而操作系统负责将程序的虚拟内存地址投影到对应的真实物理内存中。这样使得程序员能直接对连续的空间地址进行操作，而无需考虑非连续的物理内存地址。主要方法：把进程虚拟内存的内容保存在磁盘中，然后将主存当做磁盘的高速缓存。

操作系统将进程的虚拟内存划分为多个区域，每个区域都有自己的功能，接下来从最低的地址开始介绍：

- 程序代码和数据：对所有进程来说，代码都是从同一固定地址开始，然后是C全局变量。这部分在进程一开始运行时就被指定大小了。
- 堆：当调用类似C中的malloc和free标准库函数时，堆会在进程运行时动态扩展和伸缩。
- 共享库：用来存放像C标准库和数学库这样公共库的代码和数据的区域。
- 栈：位于用户虚拟内存顶部，编译器用来实现函数调用，当调用函数时，栈就增长，当返回一个函数时，栈就缩小。
- 内核虚拟内存：地址空间顶部的区域为内核保留，不运行程序读写这个区域，或直接调用内核代码定义的函数。

<center> <img src="https://pic3.zhimg.com/80/v2-846f9268b03bdd60c908e1a0da19613e_720w.jpg" style="zoom:70%" /> </center>
<center>进程的虚拟地址空间</center>   

#### 1.7.4　文件

操作系统将所有I/O设备看成是文件，而文件是字节序列，这样系统中的所有输入输出可以调用系统函数来读写文件实现，简化了对各种各样的I/O设备的操作。       

### 1.8　系统之间利用网络通信  

从一个单独的系统来看，网络可以看成一个I/O设备，当系统从主存复制一串字节到网络适配器时，计算机就会自动将其发送到另一台机器。在后续的课程会详细介绍。

#### 1.9.1　Amdahl定律

Amdahl定律对提升系统某一部分性能所带来的的效果进行量化。

它的主要思想是：当我们对系统某部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。
假设某应用程序原始执行时间`T_old`，某部分所需执行时间与该时间的比例为`alpha`，该部分提升比例为k，则新的**总执行时间**为：
![[公式]](https://www.zhihu.com/equation?tex=T_%7Bnew%7D%3D%281-%5Calpha%29T_%7Bold%7D%2B%5Calpha+T_%7Bold%7D%2Fk%3DT_%7Bold%7D%5B%281-%5Calpha%29%2B%5Calpha%2Fk%5D)
**加速比**为：
![[公式]](https://www.zhihu.com/equation?tex=S%3D%5Cfrac%7B1%7D%7B%281-%5Calpha%29%2Ba%2Fk%7D)
当k趋向于无穷时，可以计算出该部分加速到极限时所能得到的加速比为：
![[公式]](https://www.zhihu.com/equation?tex=S%3D%5Cfrac%7B1%7D%7B1-%5Calpha%7D)

该定律提供的一个主要观点是：要想显著加速整个系统，必须提升全系统中相当大的部分的速度。 
      
#### 1.9.2　并发和并行

并发（Concurrency）指一个同时具有多个活动的系统。并行（Paralleism）指的是用并发来时一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。

### 1.9.2.1 线程级并发

在单处理器系统中，通过进程之间的并发可以设计出多个程序执行的系统；通过线程之间的并发，可以在一个进程中执行多个控制流。

多处理器系统主要分成超线程和多核处理器。

超线程技术：随着CPU的发展，引入了超标量、乱序运行、大量的寄存器及寄存器重命名、多指令解码器、预测运行等特性，这些特性的原理是让CPU拥有大量资源，可是在现实中这些资源经常闲置，为了有效利用这些资源，可以多增加某些硬件，比如有多个指令地址寄存器和寄存器，而其他硬件部分只有一部分，这就空出了可以额外执行另一个线程的硬件了，超线程技术就可以让一个核同时运行两个线程了。

多核处理器：就是将多个CPU集成到一个集成电路中，然后使用一个L3高速缓存来在多个核之间共享数据。

### 1.9.2.2 指令级并行

一个指令的执行过程通常包含：取指令阶段、解码阶段和执行指令阶段

<center> <img src="https://pic2.zhimg.com/80/v2-128d8c42daafe50a06964cfa074d4f81_720w.jpg" style="zoom:70%" /> </center>
<center>CPU顺序处理指令</center>

<center> <img src="https://pic4.zhimg.com/80/v2-60b488382f86994c85b00a3db9a1700f_720w.jpg" style="zoom:70%" /> </center>
<center>CPU并行处理指令</center>

###  1.9.2.3 单指令、多数据并行

很多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行

## CSAPP：第2章 信息的表示和处理

### 2.1　信息存储 

#### 2.1.1　十六进制表示法

二进制转十六进制时，如果位数不满足4的倍数，则左边补0。        
二进制与十六进制的快速转换：      

假设将2的n次方转换为十六进制，n=i+4j，则十六进制的表示为2的i次方后面接j个0。    
例：2的11次方转换为十六进制，11=3+4*2，则十六进制表示为2的3次方后面接2个0，即为0x800。   

十进制转n进制：用十进制数除n，取余，用商继续除，直到商为0。    
c语言中每个字符串都有一个结尾字符null，用ascii码表示，ascii码具有较好的平台移植性。

#### 2.1.2　字数据大小

字长（Word Size）定义了操作系统通常处理多大的值和算数运算，并且指针和地址大小也是字长确定的。
程序可以通过不同的编译指令将其编译成32位程序或者64位程序（程序的字长是由编译决定的）。
32位程序可以允许在32位机器或者64位机器上，但是64位程序只能允许在64位机器上。32位机器虚拟地址空间4GB，64位机器虚拟地址空间16EB。

> 不同字长的机器中，指针的大小也就不同，并且不同机器/操作系统配置使用不同的存储分配规则，会使得指针的长度和内容差很多。

<center> <img src="https://pic1.zhimg.com/80/v2-4fee3518f4971cb842d8f92cf4f24494_720w.jpg" style="zoom:100%" /> </center>


#### 2.1.3　寻址和字节顺序

1bit = 8位二进制数 = 1个字节。
字节的存储顺序：大端法（IBM，Sun）正序，小端法（intel，android，ios）逆序，新机器（ARM）支持双端配置。
一个字节=8位二进制数，这种一位一位表示数据的方法称为位模式。
    
> 在两个不同类型的机器之间通过网络传输数据时，如果这两个机器使用了不同的字节顺序，就会造成问题。所以网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则， 确保发送方机器将它的内部表示转换成网络标准，而接收方机器将网络标准转换为它自己的内部表示。
> 当我们通过反汇编器得到可执行程序的指令序列时，字节顺序也很重要。

#### 2.1.4　表示字符串

#### 2.1.7　C语言中的位级运算

位级运算:|表示OR、&表示AND、~表示NOT、^表示XOR，常见用法就是实现掩码运算。

#### 2.1.8　C语言中的逻辑运算

逻辑运算: 提早终止（Early Termination）。

#### 2.1.9　C语言中的移位运算

移位运算：逻辑右移就是丢弃最低的k位，并在左侧补充k个零；算数右移，丢弃最低的k位，并在左侧补充最高有效位的值。    
一般编译器/及其组合都对有符号数使用算数右移， 而对于无符号数，就使用逻辑右移。

### 2.2　整数表示

#### 2.2.1　整型数据类型

有符号（signed）和无符号（unsigned）两个版本，常量默认是有符号版本，可以加上后缀u或者U来将其指定为无符号版本。

<center> <img src="https://pic2.zhimg.com/80/v2-5e20fa527362eacfaf96de94ba087709_720w.jpg" style="zoom:70%" /> </center>
<center>CPU并行处理指令</center>

有符号数的取值范围是不对称的，负数的范围比正数范围大1。

给定一串二进制编码来表示整数，具体如何解释这些二进制主要取决于它的编码方式，对相同的二进制采用不同的编码方式得到的整数结果是不同的。

<center> <img src="https://pic2.zhimg.com/80/v2-d5f671dada9952846dabfe60cbe859f5_720w.jpg" style="zoom:90%" /> </center>

C库中的文件<limits.h>定义了一组常量，来限定编译器运行的这台机器的不同整型数据类型的取值范围，比如它定义了常量INT_MAX、INT_MIN和UINT_MAX，就分别对应上面推导的最大值和最小值。



#### 2.2.2　无符号数的编码

假设一个整型数类型为w位，我们可以将它的位向量写成x，或者写成 ![[公式]](https://www.zhihu.com/equation?tex=%5Bx_%7Bw-1%7D%2Cx_%7Bw-2%7D%2C...%2Cx_0%5D) 。我们可以直接将x看成是一个二进制表示的，就获得了x的无符号表示。定义一个函数 ![[公式]](https://www.zhihu.com/equation?tex=B2U_w) （Binary to Unsigned）表示将w位的二进制转化为无符号数，我们可以得到该函数的表达式为

![[公式]](https://www.zhihu.com/equation?tex=B2U_w%3D%5Csum_%7Bi%3D0%7D%5E%7Bw-1%7D%7Bx_i2%5Ei%7D)

相当于就是将二进制数转化为十进制数。


C中有一些内置函数返回的是无符号数，比如`sizeof`，如果将其与有符号数进行计算时要格外小心。

#### 2.2.3　补码编码
#### 2.2.4　有符号数和无符号数之间的转换

C语言可以在各种不同的数字类型之间做强制类型转换，它的具体实现要从位级角度来看，它保持位值不变，只是改变了解释这些位的方式。

#### 2.2.5　C语言中的有符号数与无符号数

- 在C语言中，当一个有符号数和一个无符号数进行计算时，会隐式地将有符号数转化为无符号数。当进行逻辑判断时，可能会出现问题。
- 由于有符号数到无符号数的隐式转换，可能会导致错误或漏洞，因此建议绝不使用无符号数。但是如果我们想把字看成是位的集合，而没有实际意义，则无符号数非常有用。    
- 补码用来表示有符号数，符号位不只是负号，是有数值含义的；0101中符号位的0=0，所以0101=5;1011中符号位的1=-8，所以1011=-5。       
- 对无符号数来说，最大值就是所有位=1时表示的值，最小值就是0;对有符号数来说，最大值就是符号位为0，其余位为1时表示的值，最小值就是符号位为1，其余位为0时表示的值。    所以，有符号数所有位=1时表示-1，注意和无符号数的最大值区分开。  

- 有符号数和无符号数的转换：位模式不变，强行改变解释，因此数值会发生变化。          
- 当执行运算时同时出现有符号数和无符号数，此时有符号数会被强制转换为无符号数进行运算，会出现-1>0的情况。            
- 强制转换时如果是大数向小数转换，会出现大数可能被截断的情况。     

#### 2.2.6　扩展一个数字的位表示

我们想要在不改变值的情况下进行扩展。    
对于无符号数，根据无符号数编码的定义，我们可以直接在位向量的前端扩展0，这个称为**零扩展（Zero Extension）**。

在不同字长的整数之间进行类型转换，要保持在数据类型范围内的数值是不变的。以下有两种情况：从较短字长的数据类型转换到较长字长的数据类型，比如short到int，就需要进行扩展位；从较长字长的数据类型转换到较短字长的数据类型，比如int到short，就需要截断位。

#### 2.2.7　截断数字

### 2.3　整数运算

计算机中计算都是通过二进制数来计算的，所以无论是无符号数还是有符号数，计算得到的位模式是相同的

溢出：完整的计算结果不能放到数据类型的字长限制中。

- 无符号数加法可能会遇到溢出：
～例如1个字节的255+1=0，0是如何得到的？低位全0进位，最高位1溢出丢失。溢出不会报错，可以通过对和进行判断是否大于其中一个无符号值来判断是否出现溢出的状态。
～有符号加法会出现正向溢出和负向溢出，溢出结果推算同上，注意有符号数的位模式即可。如果正+正为负，负+负为非负，即可发现出现了溢出。
- 怎么求-x？
无符号数：0的逆元是自己，其他逆元 = 最大值 - 自己
有符号数：最小值的逆元是自己，其他逆元 =- 自己

- 乘法和除法可以等价为移位和加减法的组合，注意有符号数的右移是算数右移。
- 整数除法有余数时，采取向0舍入的规则，此时有符号数的负数需要先加上偏置再进行算术右移，右移k位，则偏置=2的k次方-1。
- 与乘法不同，整数的除法右移规则只能针对2的幂次，不能推广至任意常数，对一般常数的除法暂缺。

#### 2.3.1　无符号加法

- 判断溢出方法：当x>0, y>0，计算结果小于等于0时，发生了正溢出；当x<0, y<0，计算结果大于等于0时，发生了负溢出。
- 加法逆元：也是利用溢出的原理来计算补码的加法逆元。注意：部分补码的加法逆元和数学上的相反数是相同的。

#### 2.3.2　补码加法

使用补码的一个优势在于：补码加法可以使用和无符号数加法相同的硬件，相同的算法，就得到到有符号数的加法。所以大多数计算机用相同的机器指令来执行补码和无符号数加法。  
综上所述，补码加法中，使用和无符号数相同的位向量，可以保证在补码取值范围内计算正确，而和超过最大值称为正溢出，超过最小值称为负溢出。

#### 2.3.3　补码的非

#### 2.3.4　无符号乘法

对于两个w位的无符号数相乘，会得到2w位的数，计算机会截断得到低w位作为计算结果

#### 2.3.5　补码乘法

对于两个w位的补码相乘，也是得到2w位的数，同样截断低w位作为结果。

#### 2.3.6　乘以常数

乘上2幂: 只要左移幂次就行      
乘上任意整数K: 可以先对计算关于2幂次的展开,想要乘上K，可以得到它的位向量，然后根据位向量进行移位并相加，就能得到乘法运算结果。

#### 2.3.7　除以2的幂

右移操作来除以2的幂。对于无符号数，我们使用逻辑右移来除以2的幂，而对于补码，我们要用算术右移来保持符号不变。    
出现除不尽的情况，计算结果都是向0舍入的。  

### 2.4　浮点数

#### 2.4.2　IEEE浮点表示

IEEE浮点表示使用 ![[公式]](https://www.zhihu.com/equation?tex=V%3D%28-1%29%5Es%5Ctimes+M%5Ctimes+2%5EE) 表示数字。其中包含三部分：

- **符号（Sign）s：**用来确定V的正负性，当s=0时表示正数，s=1时表示负数。用一个单独的符号位直接进行编码。
- **尾数（Significand）M：** 是一个二进制小数，通常介于1和2之间的小数。使用k位二进制进行编码的小数。
- **阶码（Exponent）E：**对浮点数进行加权。使用n位进行编码的正数 ![[公式]](https://www.zhihu.com/equation?tex=e_%7Bk-1%7D%2Ce_%7Bk-2%7D%2C...%2Ce_0)。

C语言中有单精度精浮点数`float`，其中s=1、k=8、n=23；还有双精度浮点数`double`，其中s=1、k=11、n=52。

![img](pics/v2-db6d6ab3b68227d45df5e3995787409f_720w.jpg)

![img](pics/v2-f5e130f5f454f7752e1339f6ca1c8d5c_720w.jpg)

![img](pics/v2-441d9146a1ec099e79a8fae7c08340ef_720w.jpg)

- float由一个符号位+8个阶码位+23个小数位表示
- 根据阶码位的三种状态，可表示四种数值：  
阶码不全为0或全为1，表示规格化值
阶码全为0，表示非规格化值
阶码全为1，小数为0，表示无穷值inf
阶码全为1，小数为不为0，表示非数值nan
- 规格化值的计算公式如图，注意偏置的计算与阶码位数相关
- 非规格化的数用来表示正负0，以及非常接近0的小数。
- 可以用浮点数来表示整数，通过上述公式推理浮点数的符号位、阶码和小数位

#### 2.4.4　舍入

常见的舍入方法有四种：向零舍入、向上舍入、向下舍入以及向偶数舍入。以十进制为例可以看以下表格

![img](https://pic2.zhimg.com/v2-098cc0a1bd3c8a46fae91bfc9a110071_r.jpg)

#### 2.4.5　浮点运算


#### 2.4.6　C语言中的浮点数

- float/double转换成int：首先小数部分会被截断，也就是向0舍入。float的尾数部分为23字节，比int的32字节小，所以int可以精确表示float的整数部分，而double的尾数有52位，可能会出现舍入。
并且当超过int的取值范围或NaN时，微处理器会指定 [100...0] 为整数不确定值，即对应的 TMinw ，所以一个很大的浮点数转化为int时，可能会出现负数。
- int或float转换为double：double尾数有52位，而int只有32位，float只有23位，所以double会精确表示int和float，不会出现溢出和输入。
- int转换为float：不会发生溢出，但是由于float尾数位数比较少，会出现舍入。
- double转换为float：可能会出现溢出和舍入。
- 由于舍入导致的精度损失，浮点数的加法和乘法都不满足结合率和分配率。

总结：超过数值表示范围，会发生溢出；尾数较短，会发生输入。


## 第3章　程序的机器级表示


#### 3.1 机器级表示

- intel处理器的发展历史，从1978年的8086到现在的i9，从16位扩展到64位
- 生成汇编文件x.s，汇编文件里面包括以.开头的指导汇编器和链接器的指令，以及与代码相关的汇编代码
- intel中把16位看作一个字，所以32位称为双字，64位称为四字，汇编码中指令后缀的字母可以代表数据类型，例如movb,movw分别代表复制字节，复制字
- gcc中-s参数表示从c文件生成汇编文件s，改成-c参数则是从c文件生成机器代码o
- 利用反汇编工具objdump可以从机器代码o生成汇编代码s。

程序计数器（Program Counter）：指示了下个指令的内存地址。
程序员实际使用的寄存器（Register）：可以看成非常小的内存，可以通过特定名字来指定。
只有几个位的状态码（Condition Codes）：指示了最近一些指令的运行结果，比如是否产生0、是否产生负数或正数等等。这些值可以用来实现条件分支。

- 两个抽象：1 由指令集体系结构或指令集架构（Instruction Set Architecture，ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响；2 机器级程序使用的内存地址是虚拟内存地址，使得内存模型看上去是一个很大的连续字节数组。

#### 3.2　程序编码

1. **预处理器**会扩展源代码，插入所有用`#include`指令的文件，扩展所有用`#define`声明指定的宏。
2. **编译器**基于编程语言的规则、目标机器的指令集和操作系统的惯例，会将源代码转换为汇编代码作为输出，给出程序的每一条指令。
3. **汇编器**将汇编代码转化为二进制目标代码文件，它是机器代码的一种形式，包含了所有指令的二进制表示，但是还没有填入全局值的地址。
4. **链接器**将目标代码文件和实现库函数的代码合并，产生最终可执行代码文件。

![img](pics/v2-82aca65f1bb3fb2805ef5d8eaab039e6_720w.jpg)

**编译器**

文件`mstore.c`中包含以下代码：

```text
long mult2(long, long);
void multstore(long x, long y,long *dest){
    long t = mult2(x,y);
    *dest = t;
} 
```

我们通过命令`gcc -0g -S mstore.c`将其编译成汇编代码，得到`mstore.s`。其中，

-  `-Og`：是生成机器代码的优化等级，这个表示编译器会生成符合原始C代码整体结构的机器代码，这是用于调试的级别，便于我们学习观察。其他的`-O1`或`-O2`会得到更好的程序性能，但是机器代码和源代码的关系就比较难以理解。
- `-S`：只生成到汇编代码。

![img](pics/v2-00075e568d36528f2afb34bcfd6350d2_720w.jpg)

**汇编器**

运行`gcc -Og -c mstore.c`来进行编译和汇编，会生成二进制文件`mstore.o`，它是对一系列指令的编码，机器直接执行这些字节序列，对源代码一无所知。

可以通过**反汇编器（Disassembler）**来将机器代码转化为类似汇编代码的格式，在Linux中，我们可以运行`objdump -d mstore.o`，可以得到。

![img](pics/v2-c4fc386c468908cd39715aafe15f0a7b_720w.jpg)

最左侧一栏是对应的字节地址，中间是每个指令的编码，右侧是生成的汇编代码。我们可以发现：

1. 每个指令需要的字节数不同，常用的指令和需要较少操作数的指令所需的字节数比较少。
2. 每个指令都有自己对应的编码。
3. 反汇编得到的汇编代码和直接生成的有略微差异。

**链接器**
