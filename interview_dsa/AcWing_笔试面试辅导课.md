
## 目录
- 第一讲 

AcWing 756. 蛇形矩阵   
AcWing 1451. 单链表快速排序   
AcWing 1452. 寻找矩阵的极小值   
AcWing 1048. 鸡蛋的硬度   
AcWing 41. 包含min函数的栈   
AcWing 34. 链表中环的入口结点   


- 第二讲

AcWing 35. 反转链表   
AcWing 1453. 移掉K位数字   
AcWing 1454. 异或和是质数的子集数   
AcWing 1455. 招聘   
AcWing 173. 矩阵距离   
AcWing 797. 差分   

- 第三讲

AcWing 1056. 股票买卖 III   
AcWing 1487. 取硬币   
AcWing 1488. 最短距离   
AcWing 1489. 田忌赛马   
AcWing 77. 翻转单词顺序   
AcWing 851. spfa求最短路   

- 第四讲

AcWing 1490. 最长上升子串   
AcWing 1259. 二叉树遍历   
AcWing 1491. 圆桌座位   
AcWing 30. 正则表达式匹配   
AcWing 18. 重建二叉树   
AcWing 19. 二叉树的下一个节点   


- 第五讲

AcWing 33. 链表中倒数第k个节点   
AcWing 786. 第k个数   
AcWing 146. 序列   
AcWing 106. 动态中位数   
AcWing 122. 糖果传递   
AcWing 1536. 均分纸牌   
AcWing 104. 货仓选址   

- 第六讲

AcWing 92. 递归实现指数型枚举   
AcWing 94. 递归实现排列型枚举   
AcWing 1537. 递归实现排列类型枚举 II   
AcWing 145. 超市   
AcWing 1057. 股票买卖 IV   
AcWing 36. 合并两个排序的链表   

- 第七讲

AcWing 93. 递归实现组合型枚举   
AcWing 1573. 递归实现组合型枚举 II   
AcWing 55. 连续子数组的最大和   
AcWing 62. 丑数   
AcWing 29. 删除链表中重复的节点   

- 第八讲

AcWing 131. 直方图中最大的矩形   
AcWing 152. 城市游戏   
AcWing 1574. 接雨水   
AcWing 1575. 盛水最多的容器   
AcWing 454. 表达式求值   
AcWing 43. 不分行从上往下打印二叉树   

- 第九讲

AcWing 1611. 寻找峰值   
AcWing 843. n-皇后问题   
AcWing 1613. 数独简单版   
AcWing 1612. 最大正方形   
AcWing 52. 数组中出现次数超过一半的数字   
AcWing 901. 滑雪   

- 第十讲

AcWing 730. 机器人跳跃问题   
AcWing 845. 八数码   
AcWing 167. 木棒   
AcWing 731. 毕业旅行问题   
AcWing 45. 之字形打印二叉树   
AcWing 46. 二叉搜索树的后序遍历序列   

- 第十一讲

AcWing 48. 复杂链表的复刻   
AcWing 680. 剪绳子   
AcWing 1645. 不同的二叉搜索树   
AcWing 415. 栈   
AcWing 50. 序列化二叉树   
AcWing 60. 礼物的最大价值   

- 第十二讲

AcWing 1051. 最大的和   
AcWing 1026. 乘积最大   
AcWing 1698. 余数的最大值   
AcWing 1025. 开餐馆   
AcWing 1028. 复制书稿   
AcWing 1090. 绿色通道   

- 第十三讲 

AcWing 1099. 仙岛求药   
AcWing 1102. 移动骑士   
AcWing 1103. 棋盘游戏   
AcWing 1111. 字母   
AcWing 1114. 棋盘问题   
AcWing 75. 和为S的两个数字   

- 第十四讲

AcWing 1254. 找树根和孩子   
AcWing 1255. 医院设置   
AcWing 1256. 扩展二叉树   
AcWing 1764. 修塔游戏   
AcWing 1120. 埃及分数   
AcWing 79. 滑动窗口的最大值   

- 第十五讲

AcWing 1318. 取石子游戏   
AcWing 1302. 矩阵 A × B   
AcWing 1262. 鱼塘钓鱼   
AcWing 1274. 奶牛排队   
AcWing 1306. 迷路   
AcWing 89. a^b   

- 第十六讲

AcWing 1768. H 指数   
AcWing 1769. H 指数 II   
AcWing 1158. H指数   
AcWing 1108. 读书   
AcWing 558. 乘积三元组   
AcWing 1060. 墙的重建   
AcWing 53. 最小的k个数   

- 第十七讲

AcWing 591. 国家领导者   
AcWing 587. 吃蛋糕   
AcWing 561. 大按钮   
AcWing 571. 数学编码器   
AcWing 623. 投票   
AcWing 578. 去观光   
AcWing 80. 骰子的点数   


- 第十八讲 

AcWing 687. 扫雷   
AcWing 562. 壁画   
AcWing 595. 夏洛克和括号   
AcWing 620. 安全区   
AcWing 628. 美丽的数   
AcWing 76. 和为S的连续正数序列   

- 第十九讲
AcWing 647. 懒惰拼字赛   
AcWing 627. 排灯节照明   
AcWing 631. Googol字符串   
AcWing 643. 动态网格   
AcWing 695. 劣马   
AcWing 592. 雨   
AcWing 72. 平衡二叉树   

- 第二十讲
AcWing 703. 数独检查   
AcWing 697. 蒙斯特   
AcWing 698. 读电话号码   
AcWing 696. 哈默队长   
AcWing 1109. 等式   
AcWing 914. 樱桃网   
AcWing 78. 左旋转字符串   

## 内容

### 第一讲 

#####  AcWing 756. 蛇形矩阵
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n, m;
int res[N][N];


int main()
{
    cin >> n >> m;

    int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};

    for (int x = 0, y = 0, k = 1, d = 0; k <= n * m; k ++ )
    {
        res[x][y] = k;
        int a = x + dx[d], b = y + dy[d];
        if (a < 0 || a >= n || b < 0 || b >= m || res[a][b])  // 走到头
        {
            d = (d + 1) % 4;
            a = x + dx[d], b = y + dy[d];
        }
        x = a, y = b;
    }

    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < m; j ++ ) cout << res[i][j] << ' ';
        cout << endl;
    }

    return 0;
}
```
#####  AcWing 1451. 单链表快速排序
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* get_tail(ListNode* head) {
        while (head->next) head = head->next;
        return head;
    }

    ListNode* quickSortList(ListNode* head) {
        if (!head || !head->next) return head;

        auto left = new ListNode(-1), mid = new ListNode(-1), right = new ListNode(-1);
        auto ltail = left, mtail = mid, rtail = right;
        int val = head->val;

        for (auto p = head; p; p = p->next) {
            if (p->val < val) ltail = ltail->next = p;
            else if (p->val == val) mtail = mtail->next = p;
            else rtail = rtail->next = p;
        }

        ltail->next = mtail->next = rtail->next = NULL;
        left->next = quickSortList(left->next);
        right->next = quickSortList(right->next);

        // 拼接三个链表
        get_tail(left)->next = mid->next;
        get_tail(left)->next = right->next;

        auto p = left->next;
        delete left;
        delete mid;
        delete right;
        return p;
    }
};
```
#####  AcWing 1452. 寻找矩阵的极小值
```cpp
// Forward declaration of queryAPI.
// int query(int x, int y);
// return int means matrix[x][y].

class Solution {
public:
    vector<int> getMinimumValue(int n) {
        typedef long long LL;
        const LL INF = 1e15;

        int l = 0, r = n - 1;
        while (l < r)
        {
            int mid = l + r >> 1;

            int k;
            LL val = INF;
            for (int i = 0; i < n; i ++ )
            {
                int t = query(i, mid);
                if (t < val)
                {
                    val = t;
                    k = i;
                }
            }

            LL left = mid ? query(k, mid - 1) : INF;
            LL right = mid + 1 < n ? query(k, mid + 1) : INF;

            if (val < left && val < right) return {k, mid};
            if (left < val) r = mid - 1;
            else l = mid + 1;
        }

        int k;
        LL val = INF;
        for (int i = 0; i < n; i ++ )
        {
            int t = query(i, r);
            if (t < val)
            {
                val = t;
                k = i;
            }
        }

        return {k, r};
    }
};

```
#####  AcWing 1048. 鸡蛋的硬度

```cpp
第一种DP O(n2m)
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110, M = 11;

int n, m;
int f[N][M];

int main()
{
    while (cin >> n >> m)
    {
        for (int i = 1; i <= n; i ++ ) f[i][1] = i;
        for (int i = 1; i <= m; i ++ ) f[1][i] = 1;

        for (int i = 2; i <= n; i ++ )
            for (int j = 2; j <= m; j ++ )
            {
                f[i][j] = f[i][j - 1];
                for (int k = 1; k <= i; k ++ )
                    f[i][j] = min(f[i][j], max(f[k - 1][j - 1], f[i - k][j]) + 1);
            }

        cout << f[n][m] << endl;
    }

    return 0;
}

第二种DP (O(nm))
#include <cstdio>

const int N = 101, M = 11;

int n, m;
int f[N][M];

int main()
{
    while (~scanf("%d%d", &n, &m))
    {
        for (int i = 1; i <= n; i ++ )
        {
            for (int j = 1; j <= m; j ++ ) f[i][j] = f[i - 1][j] + f[i - 1][j - 1] + 1;
            if (f[i][m] >= n)
            {
                printf("%d\n", i);
                break;
            }
        }
    }

    return 0;
}

```
#####  AcWing 41. 包含min函数的栈
```cpp
class MinStack {
public:
    /** initialize your data structure here. */

    stack<int> stk, stk_min;

    MinStack() {

    }

    void push(int x) {
        stk.push(x);
        if (stk_min.size()) x = min(x, stk_min.top());
        stk_min.push(x);
    }

    void pop() {
        stk.pop();
        stk_min.pop();
    }

    int top() {
        return stk.top();
    }

    int getMin() {
        return stk_min.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */

```
#####  AcWing 34. 链表中环的入口结点
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *entryNodeOfLoop(ListNode *head) {
        if (!head || !head->next) return 0;
        ListNode *first = head, *second = head;

        while (first && second)
        {
            first = first->next;
            second = second->next;
            if (second) second = second->next;
            else return 0;

            if (first == second)
            {
                first = head;
                while (first != second)
                {
                    first = first->next;
                    second = second->next;
                }
                return first;
            }
        }

        return 0;
    }
};
```

### 第二讲

#####  AcWing 35. 反转链表
```cpp
迭代版本
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *prev = NULL, *cur = head;

        while (cur) {
            auto next = cur->next;
            cur->next = prev;
            prev = cur;
            cur = next;
        }

        return prev;
    }
};


递归版本
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next) return head;

        auto tail = reverseList(head->next);

        head->next->next = head;
        head->next = NULL;

        return tail;
    }
};

```
#####  AcWing 1453. 移掉K位数字
```cpp
#include <iostream>

using namespace std;

int main()
{
    string num;
    int k;
    cin >> num >> k;

    string res = "0";
    for (int i = 0; i < num.size(); i ++ )
    {
        while (k && num[i] < res.back())
        {
            res.pop_back();
            k -- ;
        }
        res += num[i];
    }

    while (k -- ) res.pop_back();
    int i = 0;
    while (i < res.size() && res[i] == '0') i ++ ;

    if (i == res.size()) puts("0");
    else cout << res.substr(i) << endl;

    return 0;
}
```
#####  AcWing 1454. 异或和是质数的子集数
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 5010, M = 8192, MOD = 1e9 + 7;

int n;
int a[N];
int f[2][M];

bool is_prime(int x)
{
    for (int i = 2; i * i <= x; i ++ )
        if (x % i == 0)
            return false;
    return true;
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++ ) cin >> a[i];

    f[0][0] = 1;
    for (int i = 1; i <= n; i ++ )
        for (int j = 0; j < M; j ++ )
        {
            f[i & 1][j] = f[i - 1 & 1][j];
            if ((j ^ a[i]) < M) f[i & 1][j] = (f[i & 1][j] + f[i - 1 & 1][j ^ a[i]]) % MOD;
        }

    int res = 0;
    for (int i = 2; i < M; i ++ )
        if (is_prime(i))
            res = (res + f[n & 1][i]) % MOD;

    cout << res << endl;

    return 0;
}
```
#####  AcWing 1455. 招聘
```cpp
#include <cstdio>

using namespace std;

const int N = 1010;

int n, m;
int a[N];

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        scanf("%d%d", &n, &m);
        for (int i = 0; i < m; i ++ ) scanf("%d", &a[i]);

        int res = 0;
        for (int i = 1, j = (n - 1) % m; i < n;)
        {
            i ++ ;
            if (-- j < 0) j = m - 1;
            res = (res + a[j]) % i;
        }

        printf("%d\n", res);
    }

    return 0;
}
```
#####  AcWing 173. 矩阵距离
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 1010, M = N * N;

int n, m;
char g[N][N];
PII q[M];
int dist[N][N];

void bfs()
{
    memset(dist, -1, sizeof dist);

    int hh = 0, tt = -1;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            if (g[i][j] == '1')
            {
                dist[i][j] = 0;
                q[ ++ tt] = {i, j};
            }

    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    while (hh <= tt)
    {
        auto t = q[hh ++ ];
        for (int i = 0; i < 4; i ++ )
        {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a < 0 || a >= n || b < 0 || b >= m) continue;
            if (dist[a][b] != -1) continue;

            dist[a][b] = dist[t.x][t.y] + 1;
            q[ ++ tt] = {a, b};
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i ++ ) scanf("%s", g[i]);

    bfs();

    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < m; j ++ )
            printf("%d ", dist[i][j]);
        puts("");
    }

    return 0;
}
```
#####  AcWing 797. 差分
```cpp
#include <cstdio>

using namespace std;

const int N = 100010;

int n, m;
int a[N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);
    for (int i = n; i; i -- ) a[i] -= a[i - 1];

    while (m -- )
    {
        int l, r, c;
        scanf("%d%d%d", &l, &r, &c);
        a[l] += c, a[r + 1] -= c;
    }

    for (int i = 1; i <= n; i ++ ) a[i] += a[i - 1];

    for (int i = 1; i <= n; i ++ ) printf("%d ", a[i]);
    puts("");

    return 0;
}
```

### 第三讲

#####  AcWing 1056. 股票买卖 III
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
int p[N], g[N], f[N];

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &p[i]);

    // 求g[i]：在1 ~ i中买卖一次的最大收益
    for (int i = 2, minv = p[1]; i <= n; i ++ )
    {
        g[i] = max(g[i - 1], p[i] - minv);
        minv = min(minv, p[i]);
    }

    // 求f[i]：在i ~ n中买卖一次的最大收益
    for (int i = n - 1, maxv = p[n]; i >= 1; i -- )
    {
        f[i] = max(f[i + 1], maxv - p[i]);
        maxv = max(maxv, p[i]);
    }

    int res = 0;
    for (int i = 2; i <= n; i ++ ) res = max(res, g[i] + f[i + 1]);
    printf("%d\n", res);

    return 0;
}
```
#####  AcWing 1487. 取硬币
```cpp
#include <iostream>

using namespace std;

const int N = 100010, MOD = 1e9 + 7;

int n1, n2, m;
int f[N];

int main()
{
    cin >> n1 >> n2 >> m;

    f[0] = 1;
    for (int i = 1; i <= n1; i ++ )
    {
        int p;
        cin >> p;
        for (int j = p; j <= m; j ++ ) f[j] = (f[j] + f[j - p]) % MOD;
    }
    for (int i = 1; i <= n2; i ++ )
    {
        int p;
        cin >> p;
        for (int j = m; j >= p; j -- ) f[j] = (f[j] + f[j - p]) % MOD;
    }

    cout << f[m] << endl;

    return 0;
}
```
#####  AcWing 1488. 最短距离
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, M = 300010;

int n, m;
int h[N], e[M], w[M], ne[M], idx;
int dist[N], q[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void spfa()
{
    int hh = 0, tt = 1;
    memset(dist, 0x3f, sizeof dist);
    dist[0] = 0;
    st[0] = 0;

    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;

        st[t] = false;
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])
                {
                    st[j] = true;
                    q[tt ++ ] = j;
                    if (tt == N) tt = 0;
                }
            }
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c), add(b, a, c);
    }

    scanf("%d", &m);
    while (m -- )
    {
        int v;
        scanf("%d", &v);
        add(0, v, 0);
    }

    spfa();

    scanf("%d", &m);
    while (m -- )
    {
        int v;
        scanf("%d", &v);
        printf("%d\n", dist[v]);
    }

    return 0;
}
```
#####  AcWing 1489. 田忌赛马
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n;
int a[N], b[N];

int judge(int x, int y)
{
    if (a[x] > b[y]) return 1;
    if (a[x] < b[y]) return -1;
    return 0;
}

int main()
{
    while (cin >> n, n)
    {
        for (int i = 0; i < n; i ++ ) cin >> a[i];
        for (int i = 0; i < n; i ++ ) cin >> b[i];

        sort(a, a + n, greater<int>());
        sort(b, b + n, greater<int>());

        int f1 = 0, f2 = 0, s1 = n - 1, s2 = n - 1;
        int res = 0;
        while (f1 <= s1)
        {
            if (judge(s1, s2) > 0) res ++, s1 --, s2 -- ;
            else if (judge(s1, s2) < 0) res += judge(s1, f2), s1 --, f2 ++ ;
            else
            {
                if (judge(f1, f2) > 0) res ++, f1 ++, f2 ++ ;
                else res += judge(s1, f2), s1 --, f2 ++ ;
            }
        }

        cout << res * 200 << endl;
    }

    return 0;
}
```
#####  AcWing 77. 翻转单词顺序
```cpp
class Solution {
public:
    string reverseWords(string s) {
        reverse(s.begin(), s.end());
        for (int i = 0; i < s.size(); i ++ )
        {
            int j = i;
            while (j < s.size() && s[j] != ' ') j ++ ;
            reverse(s.begin() + i, s.begin() + j);
            i = j;
        }
        return s;
    }
};
```
#####  AcWing 851. spfa求最短路
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 100010;

int n, m;
int h[N], w[N], e[N], ne[N], idx;
int dist[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        int t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return dist[n];
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    int t = spfa();

    if (t == 0x3f3f3f3f) puts("impossible");
    else printf("%d\n", t);

    return 0;
}
```




### 第四讲

#####  AcWing 1490. 最长上升子串
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
int a[N], f[N], g[N];

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);

    // 预处理f[i]：以i结尾的单调上升子串的最大长度
    for (int i = 1; i <= n; i ++ )
        if (a[i] > a[i - 1]) f[i] = f[i - 1] + 1;
        else f[i] = 1;

    // 预处理g[i]：以i开头的单调上升子串的最大长度
    for (int i = n; i; i -- )
        if (a[i] < a[i + 1]) g[i] = g[i + 1] + 1;
        else g[i] = 1;

    int res = 0;
    // 枚举删除哪个数
    for (int i = 1; i <= n; i ++ )
        if (a[i - 1] >= a[i + 1]) res = max(res, max(f[i - 1], g[i + 1]));
        else res = max(res, f[i - 1] + g[i + 1]);

    printf("%d\n", res);

    return 0;
}
```
#####  AcWing 1259. 二叉树遍历
```cpp
#include <iostream>
#include <unordered_map>

using namespace std;

struct Node
{
    char val;
    Node *left, *right;
    Node(char _val) : val(_val), left(NULL), right(NULL) {}
};

string res;

void dfs(Node *root)
{
    if (!root) return;
    res += root->val;
    dfs(root->left);
    dfs(root->right);
}

int main()
{
    string inorder, lorder;
    cin >> inorder >> lorder;

    unordered_map<char, int> pos;
    for (int i = 0; i < inorder.size(); i ++ ) pos[inorder[i]] = i;

    bool st[30] = {0};
    Node* q[30];

    q[0] = new Node(lorder[0]);
    for (int i = 0, j = 1; j < lorder.size();)  // 按成遍历，i是当前这层的起点，j是下一层的起点
    {
        for (int end = j; i < end; i ++ )  // 遍历当前这层
        {
            // 判断左儿子是否存在
            int p = pos[lorder[i]];
            st[p] = true;
            if (p && !st[p - 1])
            {
                q[i]-> left = new Node(lorder[j]);
                q[j ++ ] = q[i]->left;
            }
            if (p + 1 < lorder.size() && !st[p + 1])
            {
                q[i]->right = new Node(lorder[j]);
                q[j ++ ] = q[i]->right;
            }
        }
    }

    dfs(q[0]);

    cout << res << endl;

    return 0;
}
```
#####  AcWing 1491. 圆桌座位
```cpp
#include <iostream>

using namespace std;

const int N = 11;

int n, m;
int pos[N];
bool g[N][N], st[N];

int dfs(int u)
{
    if (u == n)
    {
        if (g[pos[n - 1]][pos[0]]) return 0;
        return 1;
    }

    int res = 0;
    for (int i = 1; i <= n; i ++ )
        if (!st[i] && !g[i][pos[u - 1]])
        {
            pos[u] = i;
            st[i] = true;
            res += dfs(u + 1);
            st[i] = false;
        }

    return res;
}

int main()
{
    cin >> n >> m;
    while (m -- )
    {
        int a, b;
        cin >> a >> b;
        g[a][b] = g[b][a] = true;
    }

    pos[0] = 1;
    st[1] = true;

    cout << dfs(1) << endl;

    return 0;
}
```
#####  AcWing 30. 正则表达式匹配
```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        int n = s.size(), m = p.size();
        s = ' ' + s, p = ' ' + p;

        vector<vector<bool>> f(n + 1, vector<bool>(m + 1));
        f[0][0] = true;

        for (int i = 0; i <= n; i ++ )
            for (int j = 1; j <= m; j ++ )
            {
                if (j + 1 < p.size() && p[j + 1] == '*') continue;

                if (i && p[j] != '*')
                {
                    f[i][j] = f[i - 1][j - 1] && (s[i] == p[j] || p[j] == '.');
                }
                else if (p[j] == '*')
                {
                    f[i][j] = f[i][j - 2] || i && f[i - 1][j] && (s[i] == p[j - 1] || p[j - 1] == '.');
                }
            }

        return f[n][m];
    }
};
```
#####  AcWing 18. 重建二叉树
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:

    map<int, int> hash;
    vector<int> preorder, inorder;

    TreeNode* buildTree(vector<int>& _preorder, vector<int>& _inorder) {
        preorder = _preorder, inorder = _inorder;
        for (int i = 0; i < inorder.size(); i ++ ) hash[inorder[i]] = i;
        return dfs(0, preorder.size() - 1, 0, inorder.size() - 1);
    }

    TreeNode* dfs(int pl, int pr, int il, int ir) {
        if (pl > pr) return nullptr;
        auto root = new TreeNode(preorder[pl]);
        int k = hash[root->val];
        auto left = dfs(pl + 1, pl + k - il, il, k - 1);
        auto right = dfs(pl + k - il + 1, pr, k + 1, ir);
        root->left = left, root->right = right;
        return root;
    }
};
```
#####  AcWing 19. 二叉树的下一个节点
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode *father;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* p) {
        if (p->right) {
            p = p->right;
            while (p->left) p = p->left;
            return p;
        }

        while (p->father && p == p->father->right) p = p->father;
        return p->father;
    }
};
```

### 第五讲

#####  AcWing 33. 链表中倒数第k个节点
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* findKthToTail(ListNode* head, int k) {
        int n = 0;
        for (auto p = head; p; p = p->next) n ++ ;
        if (k > n) return nullptr;
        auto p = head;
        for (int i = 0; i < n - k; i ++ ) p = p->next;
        return p;
    }
};
```
#####  AcWing 786. 第k个数
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int q[N];
int a[N], b[N];


int qsort(int l, int r, int k)
{
    if (l == r) return q[l];

    int x = q[l], i = l - 1, j = r + 1;
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }

    if (k <= j - l + 1) return qsort(l, j, k);
    return qsort(j + 1, r, k - (j - l + 1));
}


int main()
{
    int n, k;
    scanf("%d%d", &n, &k);
    for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);

    sort(q, q + n);

    printf("%d\n", q[k - 1]);

    return 0;
}

#####  AcWing 146. 序列
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 2010;

int m, n;
int a[N], b[N], c[N];

void merge()
{
    priority_queue<PII, vector<PII>, greater<PII>> heap;

    for (int i = 0; i < n; i ++ ) heap.push({b[i] + a[0], 0});

    for (int i = 0; i < n; i ++ )
    {
        auto p = heap.top();
        heap.pop();
        c[i] = p.x;
        heap.push({p.x - a[p.y] + a[p.y + 1], p.y + 1});
    }

    memcpy(a, c, sizeof a);
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        scanf("%d%d", &m, &n);
        for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);

        sort(a, a + n);

        for (int i = 0; i < m - 1; i ++ )
        {
            for (int j = 0; j < n; j ++ ) scanf("%d", &b[j]);
            merge();
        }

        for (int i = 0; i < n; i ++ ) printf("%d ", a[i]);
        puts("");
    }

    return 0;
}
```
#####  AcWing 106. 动态中位数
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        int id, n;
        scanf("%d%d", &id, &n);
        printf("%d %d\n", id, (n + 1) / 2);

        priority_queue<int> down;
        priority_queue<int, vector<int>, greater<int>> up;

        int cnt = 0;
        for (int i = 0; i < n; i ++ )
        {
            int x;
            scanf("%d", &x);

            if (down.empty() || x <= down.top()) down.push(x);
            else up.push(x);

            if (down.size() > up.size() + 1) up.push(down.top()), down.pop();
            if (up.size() > down.size()) down.push(up.top()), up.pop();

            if (i % 2 == 0)
            {
                printf("%d ", down.top());
                if ( ++ cnt % 10 == 0) puts("");
            }
        }

        if (cnt % 10) puts("");
    }

    return 0;
}
```
#####  AcWing 122. 糖果传递
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 1000010;

int n;
LL s[N], c[N];

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ )
    {
        scanf("%lld", &s[i]);
        s[i] += s[i - 1];
    }

    LL avg = s[n] / n;
    for (int i = 2; i <= n; i ++ ) c[i] = (i - 1) * avg - (s[i] - s[1]);

    sort(c + 1, c + n + 1);

    LL md = c[(n + 1) / 2];
    LL res = 0;
    for (int i = 1; i <= n; i ++ ) res += abs(c[i] - md);

    printf("%lld\n", res);

    return 0;
}
```
#####  AcWing 1536. 均分纸牌
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n;
int a[N];

int main()
{
    cin >> n;
    int sum = 0;
    for (int i = 0; i < n; i ++ ) cin >> a[i], sum += a[i];

    int res = 0;
    int avg = sum / n;
    for (int i = 0, x = 0; i < n; i ++ )
    {
        x = a[i] - avg + x;
        if (x) res ++ ;
    }

    cout << res << endl;

    return 0;
}
```
#####  AcWing 104. 货仓选址
```cpp
快速排序O(nlogn)
#include <cstdio>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
int a[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);

    sort(a, a + n);

    int md = a[n / 2];
    int res = 0;
    for (int i = 0; i < n; i ++ ) res += abs(a[i] - md);

    printf("%d\n", res);
    return 0;
}
快速选择算法O(n)
#include <cstdio>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
int a[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);

    nth_element(a, a + n / 2, a + n);  // O(N)

    int md = a[n / 2];

    int res = 0;
    for (int i = 0; i < n; i ++ ) res += abs(a[i] - md);

    printf("%d\n", res);
    return 0;
}
```

### 第六讲

#####  AcWing 92. 递归实现指数型枚举
```cpp
#include <iostream>

using namespace std;

const int N = 20;

int n;
bool st[N];

void dfs(int u)
{
    if (u > n)  // 叶子节点
    {
        for (int i = 1; i <= n; i ++ )
            if (st[i])
                cout << i << ' ';
        cout << endl;
        return;
    }

    st[u] = true;
    dfs(u + 1);  // 选择当前数的分支

    st[u] = false;
    dfs(u + 1);  // 不选当前数的分支
}

int main()
{
    cin >> n;

    dfs(1);

    return 0;
}
```
#####  AcWing 94. 递归实现排列型枚举
```cpp
#include <iostream>

using namespace std;

const int N = 10;

int n;
int nums[N];
bool st[N];

void dfs(int u)
{
    if (u > n)  // 叶子节点
    {
        for (int i = 1; i <= n; i ++ ) cout << nums[i] << ' ';
        cout << endl;
        return;
    }

    for (int i = 1; i <= n; i ++ )
        if (!st[i])
        {
            nums[u] = i;
            st[i] = true;
            dfs(u + 1);
            st[i] = false;
        }
}

int main()
{
    cin >> n;

    dfs(1);

    return 0;
}
```
#####  AcWing 1537. 递归实现排列类型枚举 II
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10;

int n;
int a[N], nums[N];
bool st[N];

void dfs(int u)
{
    if (u == n)
    {
        for (int i = 0; i < n; i ++ ) cout << nums[i] << ' ';
        cout << endl;
        return;
    }

    for (int i = 0; i < n; i ++ )
        if (!st[i])
        {
            nums[u] = a[i];
            st[i] = true;
            dfs(u + 1);
            st[i] = false;
            while (i + 1 < n && a[i + 1] == a[i]) i ++ ;
        }
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ ) cin >> a[i];

    sort(a, a + n);

    dfs(0);

    return 0;
}
```
#####  AcWing 145. 超市
```cpp
#include <iostream>
#include <algorithm>
#include <queue>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

int main()
{
    int n;
    while (cin >> n)
    {
        vector<PII> prod(n);
        for (int i = 0; i < n; i ++ ) cin >> prod[i].y >> prod[i].x;
        sort(prod.begin(), prod.end());

        priority_queue<int, vector<int>, greater<int>> heap;
        for (auto p : prod)
        {
            heap.push(p.y);
            if (heap.size() > p.x) heap.pop();
        }

        int res = 0;
        while (heap.size()) res += heap.top(), heap.pop();

        cout << res << endl;
    }

    return 0;
}
```
#####  AcWing 1057. 股票买卖 IV
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, M = 110, INF = 0x3f3f3f3f;

int n, m;
int w[N];
int f[N][M][2];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]);

    memset(f, -0x3f, sizeof f);
    f[0][0][0] = 0;

    for (int i = 1; i <= n; i ++ )
        for (int j = 0; j <= m; j ++ )
        {
            f[i][j][0] = f[i - 1][j][0];
            if (j) f[i][j][0] = max(f[i][j][0], f[i - 1][j - 1][1] + w[i]);
            f[i][j][1] = max(f[i - 1][j][1], f[i - 1][j][0] - w[i]);
        }

    int res = 0;
    for (int k = 0; k <= m; k ++ ) res = max(res, f[n][k][0]);

    printf("%d\n", res);

    return 0;
}
```
#####  AcWing 36. 合并两个排序的链表
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *head = 0, *tail = 0;

    void add_tail(int x)
    {
        ListNode *p = new ListNode(x);
        if (tail)
        {
            tail->next = p;
            tail = p;
        }
        else
        {
            head = tail = p;
        }
    }

    ListNode* merge(ListNode* l1, ListNode* l2) {
        ListNode *p = l1, *q = l2;

        while (p && q)
        {
            if (p->val < q->val)
            {
                add_tail(p->val);
                p = p->next;
            }
            else
            {
                add_tail(q->val);
                q = q->next;
            }
        }
        while (p)
        {
            add_tail(p->val);
            p = p->next;
        }
        while (q)
        {
            add_tail(q->val);
            q = q->next;
        }
        return head;
    }  
};
```

###  第七讲

#####  AcWing 93. 递归实现组合型枚举
```cpp
#include <iostream>

using namespace std;

const int N = 30;

int n, m;
bool st[N];

void dfs(int u, int s)
{
    if (s == m)
    {
        for (int i = 1; i <= n; i ++ )
            if (st[i])
                cout << i << ' ';
        cout << endl;
        return;
    }

    if (u > n) return;

    st[u] = true;
    dfs(u + 1, s + 1);
    st[u] = false;

    dfs(u + 1, s);
}

int main()
{
    cin >> n >> m;

    dfs(1, 0);

    return 0;
}
```
#####  AcWing 1573. 递归实现组合型枚举 II
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 30;

int n, m;
int a[N];
bool st[N];

void dfs(int u, int s)
{
    if (s > m) return;
    if (s == m)
    {
        for (int i = 0; i < u; i ++ )
            if (st[i])
                cout << a[i] << ' ';
        cout << endl;
        return;
    }

    if (u == n) return;

    int k = u;
    while (k < n && a[k] == a[u]) st[k ++ ] = true, s ++ ;

    dfs(k, s);  // 当前这段全选
    for (int i = k - 1; i >= u; i -- )
    {
        st[i] = false;
        s -- ;
        dfs(k, s);
    }
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ ) cin >> a[i];
    sort(a, a + n);

    dfs(0, 0);

    return 0;
}
```
#####  AcWing 55. 连续子数组的最大和
```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int res = nums[0];

        for (int i = 1, s = nums[0]; i < nums.size(); i ++ )
        {
            s = nums[i] + max(0, s);
            res = max(res, s);
        }

        return res;
    }
};
```
#####  AcWing 62. 丑数
```cpp
class Solution {
public:
    int getUglyNumber(int n) {
        vector<int> q(1, 1);

        int i = 0, j = 0, k = 0;
        while (q.size() < n)
        {
            int t = min(q[i] * 2, min(q[j] * 3, q[k] * 5));
            q.push_back(t);
            if (q[i] * 2 == t) i ++ ;
            if (q[j] * 3 == t) j ++ ;
            if (q[k] * 5 == t) k ++ ;
        }

        return q.back();
    }
};
```
#####  AcWing 29. 删除链表中重复的节点
```cpp
class Solution {
public:
    ListNode* deleteDuplication(ListNode* head) {
        auto dummy = new ListNode(-1);
        dummy->next = head;

        auto p = dummy;
        while (p->next) {
            auto q = p->next;
            while (q && p->next->val == q->val) q = q->next;

            if (p->next && p->next->next == q) p = p->next;
            else p->next = q;
        }

        return dummy->next;
    }
};
```


###  第八讲

#####  AcWing 131. 直方图中最大的矩形
```cpp
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 100010;

int n;
int h[N], l[N], r[N];
int q[N];

int main()
{
    while (scanf("%d", &n), n)
    {
        for (int i = 1; i <= n; i ++ ) scanf("%d", &h[i]);
        h[0] = h[n + 1] = -1;

        // 求左边界
        int tt = 0;
        q[0] = 0;
        for (int i = 1; i <= n; i ++ )
        {
            while (h[q[tt]] >= h[i]) tt -- ;
            l[i] = q[tt];
            q[ ++ tt] = i;
        }

        // 求右边界
        tt = 0;
        q[0] = n + 1;
        for (int i = n; i; i -- )
        {
            while (h[q[tt]] >= h[i]) tt -- ;
            r[i] = q[tt];
            q[ ++ tt] = i;
        }

        LL res = 0;
        for (int i = 1; i <= n; i ++ )
            res = max(res, (LL)h[i] * (r[i] - l[i] - 1));

        printf("%lld\n", res);
    }

    return 0;
}
```
#####  AcWing 152. 城市游戏
```cpp
#include <iostream>

using namespace std;

const int N = 1010;

int n, m;
int s[N][N], l[N], r[N];
int q[N];

int work(int h[])
{
    int tt = 0;
    h[0] = h[m + 1] = -1;
    q[0] = 0;
    for (int i = 1; i <= m; i ++ )
    {
        while (h[q[tt]] >= h[i]) tt -- ;
        l[i] = q[tt];
        q[ ++ tt] = i;
    }

    tt = 0;
    q[0] = m + 1;
    for (int i = m; i; i -- )
    {
        while (h[q[tt]] >= h[i]) tt -- ;
        r[i] = q[tt];
        q[ ++ tt] = i;
    }

    int res = 0;
    for (int i = 1; i <= m; i ++ ) res = max(res, h[i] * (r[i] - l[i] - 1));

    return res;
}

int main()
{
    cin >> n >> m;

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            char c;
            cin >> c;
            if (c == 'F') s[i][j] = s[i - 1][j] + 1;
        }

    int res = 0;
    for (int i = 1; i <= n; i ++ ) res = max(res, work(s[i]));

    cout << res * 3 << endl;

    return 0;
}
```
#####  AcWing 1574. 接雨水
```cpp
#include <iostream>

using namespace std;

const int N = 100010;

int n;
int h[N], q[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &h[i]);

    int res = 0;
    int tt = -1;
    for (int i = 0; i < n; i ++ )
    {
        int last = 0;
        while (tt >= 0 && h[q[tt]] <= h[i])
        {
            res += (h[q[tt]] - last) * (i - q[tt] - 1);
            last = h[q[tt]];
            tt -- ;
        }
        if (tt >= 0) res += (h[i] - last) * (i - q[tt] - 1);
        q[ ++ tt] = i;
    }

    printf("%d\n", res);

    return 0;
}
```
#####  AcWing 1575. 盛水最多的容器
```cpp
#include <iostream>

using namespace std;

const int N = 100010;

int n;
int h[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &h[i]);

    int res = 0;
    for (int i = 0, j = n - 1; i < j;)
    {
        res = max(res, min(h[i], h[j]) * (j - i));
        if (h[i] < h[j]) i ++ ;
        else j -- ;
    }

    printf("%d\n", res);

    return 0;
}
```
#####  AcWing 454. 表达式求值
```cpp
#include <iostream>
#include <stack>

using namespace std;

const int MOD = 10000;

stack<int> nums;
stack<char> ops;

void eval()
{
    int b = nums.top(); nums.pop();
    int a = nums.top(); nums.pop();
    char c = ops.top(); ops.pop();

    if (c == '+') nums.push((a + b) % MOD);
    else nums.push(a * b % MOD);
}

int main()
{
    string expr;
    cin >> expr;

    for (int i = 0; i < expr.size(); i ++ )
    {
        char c = expr[i];
        if (c >= '0' && c <= '9')
        {
            int v = 0;
            int j = i;
            while (j < expr.size() && expr[j] >= '0' && expr[j] <= '9')
            {
                v = v * 10 + expr[j] - '0';
                j ++ ;
            }
            nums.push(v % MOD);
            i = j - 1;
        }
        else if (c == '+')
        {
            while (ops.size()) eval();
            ops.push(c);
        }
        else
        {
            while (ops.size() && ops.top() == '*') eval();
            ops.push(c);
        }
    }

    while (ops.size()) eval();
    cout << nums.top() << endl;

    return 0;
}

```
#####  AcWing 43. 不分行从上往下打印二叉树
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> printFromTopToBottom(TreeNode* root) {
        vector<int> res;
        if (!root) return res;
        queue<TreeNode*> q;
        q.push(root);
        while (q.size()) {
            auto t = q.front();
            q.pop();
            res.push_back(t->val);
            if (t->left) q.push(t->left);
            if (t->right) q.push(t->right);
        }

        return res;
    }
};
```

### 第九讲

#####  AcWing 1611. 寻找峰值
```cpp
// Forward declaration of queryAPI.
// int query(int x);
// return int means nums[x].

class Solution {
public:
    int findPeakElement(int n) {
        int l = 0, r = n - 1;
        while (l < r)
        {
            int mid = l + r >> 1;
            if (query(mid) > query(mid + 1)) r = mid;
            else l = mid + 1;
        }
        return r;
    }
};
```
#####  AcWing 843. n-皇后问题
```cpp
#include <iostream>

using namespace std;

const int N = 15;

int n;
char g[N][N];
bool col[N], dg[N * 2], udg[N * 2];

void dfs(int u)
{
    if (u == n)
    {
        for (int i = 0; i < n; i ++ ) puts(g[i]);
        puts("");
        return;
    }

    for (int i = 0; i < n; i ++ )
        if (!col[i] && !dg[u + i] && !udg[u - i + n])
        {
            col[i] = dg[u + i] = udg[u - i + n] = true;
            g[u][i] = 'Q';
            dfs(u + 1);
            g[u][i] = '.';
            col[i] = dg[u + i] = udg[u - i + n] = false;
        }
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            g[i][j] = '.';

    dfs(0);

    return 0;
}
```
#####  AcWing 1613. 数独简单版
```cpp
#include <iostream>

using namespace std;

const int N = 10;

char g[N][N];
bool row[N][N], col[N][N], cell[N][N][N];

bool dfs(int x, int y)
{
    if (y == 9) return dfs(x + 1, 0);
    if (x == 9)
    {
        for (int i = 0; i < 9; i ++ ) puts(g[i]);
        return true;
    }

    if (g[x][y] != '.') return dfs(x, y + 1);

    for (int i = 1; i <= 9; i ++ )
        if (!row[x][i] && !col[y][i] && !cell[x / 3][y / 3][i])
        {
            row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = true;
            g[x][y] = i + '0';
            if (dfs(x, y + 1)) return true;
            g[x][y] = '.';
            row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = false;
        }

    return false;
}

int main()
{
    for (int i = 0; i < 9; i ++ )
    {
        cin >> g[i];
        for (int j = 0; j < 9; j ++ )
            if (g[i][j] != '.')
            {
                int t = g[i][j] - '0';
                row[i][t] = col[j][t] = cell[i / 3][j / 3][t] = true;
            }
    }

    dfs(0, 0);

    return 0;
}
```
#####  AcWing 1612. 最大正方形
```cpp
#include <iostream>

using namespace std;

const int N = 1010;

int n, m;
int f[N][N];

int main()
{
    scanf("%d%d", &n, &m);

    int res = 0;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            int w;
            scanf("%d", &w);
            if (w)
            {
                f[i][j] = min(f[i - 1][j], min(f[i][j - 1], f[i - 1][j - 1])) + 1;
                res = max(res, f[i][j]);
            }
        }

    printf("%d\n", res * res);

    return 0;
}
```
#####  AcWing 52. 数组中出现次数超过一半的数字
```cpp
class Solution {
public:
    int moreThanHalfNum_Solution(vector<int>& nums) {
        int value, count = 0;
        for (auto x : nums)
            if (!count) value = x, count ++ ;
            else
            {
                if (x == value) count ++ ;
                else count -- ;
            }

        return value;
    }
};
```
#####  AcWing 901. 滑雪
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 310;
int h[N][N],n,m;
int f[N][N];
int dx[4] = { 0,0,-1,1 }, dy[4] = { 1,-1,0,0 };
int dp(int x, int y)
{
    if (f[x][y] != -1)return f[x][y];          //如果这里被遍历过一次，就直接返回
    f[x][y] = 1;                                    //要么就开始，最低就是上下左右都走不了，就是1
    for (int i = 0; i < 4; i++)                //四个方向
    { 
        int a = x + dx[i], b = y + dy[i];
        if (a >=1 && a <= n && b>=1&&b <= m && h[a][b] < h[x][y])
            f[x][y] = max(f[x][y], dp(a,b) + 1);
    }
    return f[x][y];
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            scanf("%d", &h[i][j]);
    memset(f, -1, sizeof(f));
    int res = 0;
    for (int i = 1; i<= n; i++)
        for (int j = 1; j <= m; j++)
            res = max(res, dp(i, j));
    printf("%d\n", res);
    return 0;
}
```

### 第十讲

#####  AcWing 730. 机器人跳跃问题
```cpp
#include <iostream>

using namespace std;

const int N = 100010;

int n;
int h[N];

bool check(int e)
{
    for (int i = 1; i <= n; i ++ )
    {
        e = e * 2 - h[i];
        if (e >= 100000) return true;
        if (e < 0) return false;
    }

    return true;
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++ ) cin >> h[i];

    int l = 0, r = 100000;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    cout << r << endl;

    return 0;
}
```
#####  AcWing 845. 八数码
```cpp
#include <iostream>
#include <queue>
#include <unordered_map>

using namespace std;

unordered_map<string, int> d;

int bfs(string start)
{
    string end = "12345678x";

    if (start == end) return 0;
    queue<string> q;
    q.push(start);
    d[start] = 0;

    int dx[] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
    while (q.size())
    {
        auto t = q.front();
        q.pop();

        int x, y;
        for (int i = 0; i < 9; i ++ )
            if (t[i] == 'x')
                x = i / 3, y = i % 3;

        for (int i = 0; i < 4; i ++ )
        {
            string state = t;
            int a = x + dx[i], b = y + dy[i];
            if (a >= 0 && a < 3 && b >= 0 && b < 3)
            {
                swap(state[a * 3 + b], state[x * 3 + y]);
                if (d.count(state) == 0)
                {
                    d[state] = d[t] + 1;
                    if (state == end) return d[state];
                    q.push(state);
                }
            }
        }
    }

    return -1;
}

int main()
{
    string start, state;
    char c;
    while (cin >> c)
    {
        start += c;
        if (c != 'x') state += c;
    }

    int cnt = 0;
    for (int i = 0; i < 8; i ++ )
        for (int j = i + 1; j < 8; j ++ )
            if (state[i] > state[j])
                cnt ++ ;

    if (cnt % 2) puts("-1");
    else cout << bfs(start) << endl;

    return 0;
}
```
#####  AcWing 167. 木棒
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 70;


int n;
int sticks[N];
bool st[N];
int sum, length;

bool dfs(int u, int cur, int start)
{
    if (u * length == sum) return true;
    if (cur == length) return dfs(u + 1, 0, 0);

    for (int i = start; i < n; i ++ )
    {
        if (st[i]) continue;
        int l = sticks[i];
        if (cur + l <= length)
        {
            st[i] = true;
            if (dfs(u, cur + l, i + 1)) return true;
            st[i] = false;
        }

        if (!cur || cur + l == length) return false;

        int j = i + 1;
        while (j < n && sticks[j] == l) j ++ ;
        i = j - 1;
    }

    return false;
}

int main()
{
    while (cin >> n, n)
    {
        sum = length = 0;
        for (int i = 0; i < n; i ++ )
        {
            int l;
            cin >> l;
            sticks[i] = l;
            sum += l;
            length = max(length, l);
        }

        sort(sticks, sticks + n, greater<int>());

        memset(st, 0, sizeof st);
        while (true)
        {
            if (sum % length == 0 && dfs(0, 0, 0))
            {
                cout << length << endl;
                break;
            }
            length ++ ;
        }
    }

    return 0;
}
```
#####  AcWing 731. 毕业旅行问题
```cpp
#include <cstring>
#include <iostream>

using namespace std;

const int N = 20;

int n;
int w[N][N];
int f[1 << N][N];

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            cin >> w[i][j];

    memset(f, 0x3f, sizeof f);
    f[1][0] = 0;

    for (int i = 1; i < 1 << n; i += 2)
        for (int j = 0; j < n; j ++ )
            if (i >> j & 1)
                for (int k = 0; k < n; k ++ )
                    if (i - (1 << j) >> k & 1)
                        f[i][j] = min(f[i][j], f[i - (1 << j)][k] + w[k][j]);

    int res = 0x3f3f3f3f;
    for (int i = 1; i < n; i ++ ) res = min(res, f[(1 << n) - 1][i] + w[i][0]);

    cout << res << endl;

    return 0;
}
```
#####  AcWing 45. 之字形打印二叉树
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> get_val(vector<TreeNode*> level)
    {
        vector<int> res;
        for (auto &u : level)
            res.push_back(u->val);
        return res;
    }

    vector<vector<int>> printFromTopToBottom(TreeNode* root) {
        vector<vector<int>>res;
        if (!root) return res;
        vector<TreeNode*>level;
        level.push_back(root);
        res.push_back(get_val(level));
        bool zigzag = true;
        while (true)
        {
            vector<TreeNode*> newLevel;
            for (auto &u : level)
            {
                if (u->left) newLevel.push_back(u->left);
                if (u->right) newLevel.push_back(u->right);
            }
            if (newLevel.size())
            {
                vector<int>temp = get_val(newLevel);
                if (zigzag)
                    reverse(temp.begin(), temp.end());
                res.push_back(temp);
                level = newLevel;
            }
            else break;
            zigzag = !zigzag;
        }
        return res;
    }
};
```
#####  AcWing 46. 二叉搜索树的后序遍历序列
```cpp
class Solution {
public:

    vector<int> seq;

    bool verifySequenceOfBST(vector<int> sequence) {
        seq = sequence;
        return dfs(0, seq.size() - 1);
    }

    bool dfs(int l, int r)
    {
        if (l >= r) return true;
        int root = seq[r];
        int k = l;
        while (k < r && seq[k] < root) k ++ ;
        for (int i = k; i < r; i ++ )
            if (seq[i] < root)
                return false;
        return dfs(l, k - 1) && dfs(k, r - 1);
    }
};
```

### 第十一讲

#####  AcWing 48. 复杂链表的复刻
```cpp
时间 O(n)，额外空间 O(n)
/**
 * Definition for singly-linked list with a random pointer.
 * struct ListNode {
 *     int val;
 *     ListNode *next, *random;
 *     ListNode(int x) : val(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *copyRandomList(ListNode *head) {
        if (!head) return head;
        unordered_map<ListNode*, ListNode*> pos;

        pos[NULL] = NULL;
        for (auto p = head; p; p = p->next)
            pos[p] = new ListNode(p->val);

        for (auto p = head; p; p = p->next)
        {
            pos[p]->next = pos[p->next];
            pos[p]->random = pos[p->random];
        }

        return pos[head];
    }
};
时间 O(n)，额外空间 O(1)
/**
 * Definition for singly-linked list with a random pointer.
 * struct ListNode {
 *     int val;
 *     ListNode *next, *random;
 *     ListNode(int x) : val(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *copyRandomList(ListNode *head) {
        for (auto p = head; p;)  // 在每个点后面添加一个它的复制
        {
            auto np = new ListNode(p->val);
            auto next = p->next;
            p->next = np;
            np->next = next;
            p = next;
        }

        // 复制random指针
        for (auto p = head; p; p = p->next->next)
            if (p->random)
                p->next->random = p->random->next;

        // 分离两个链表
        auto dummy = new ListNode(-1);
        auto cur = dummy;
        for (auto p = head; p; p = p->next)
        {
            cur->next = p->next;
            cur = cur->next;
            p->next = p->next->next;
        }

        return dummy->next;
    }
};
```
#####  AcWing 680. 剪绳子
```cpp
#include <iostream>

using namespace std;

const int N = 100010;

int n, m;
int l[N];

bool check(double length)
{
    int s = 0;
    for (int i = 0; i < n; i ++ )
    {
        s += l[i] / length;
        if (s >= m) return true;
    }

    return false;
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ ) cin >> l[i];

    double l = 0, r = 1e9;
    while (r - l > 1e-4)
    {
        double mid = (l + r) / 2;
        if (check(mid)) l = mid;
        else r = mid;
    }

    printf("%.2lf\n", r);

    return 0;
}
```
#####  AcWing 1645. 不同的二叉搜索树
```cpp
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1010, MOD = 1e9 + 7;

int n;
int f[N];

int main()
{
    cin >> n;

    f[0] = 1;
    for (int i = 1; i <= n; i ++ )
        for (int j = 0; j < i; j ++ )
            f[i] = (f[i] + (LL)f[j] * f[i - 1 - j]) % MOD;

    cout << f[n] << endl;

    return 0;
}
```
#####  AcWing 415. 栈
```cpp
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 40;

int n;
LL C[N][N];

int main()
{
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j <= i; j ++ )
            if (!j) C[i][j] = 1;
            else C[i][j] = C[i - 1][j] + C[i - 1][j - 1];

    cin >> n;
    cout << C[n * 2][n] / (n + 1) << endl;

    return 0;
}
```
#####  AcWing 50. 序列化二叉树
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string res;
        dfs_s(root, res);
        return res;
    }

    void dfs_s(TreeNode *root, string &res)
    {
        if (!root) {
            res += "null ";
            return;
        }
        res += to_string(root->val) + ' ';
        dfs_s(root->left, res);
        dfs_s(root->right, res);
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        int u = 0;
        return dfs_d(data, u);
    }

    TreeNode* dfs_d(string data, int &u)
    {
        //if (u == data.size()) return NULL;
        int k = u;
        while (data[k] != ' ') k ++ ;
        if (data[u] == 'n') {
            u = k + 1;
            return NULL;
        }
        int val = 0, sign = 1;
        if (u < k && data[u] == '-') sign = -1, u ++ ;
        for (int i = u; i < k; i ++ ) val = val * 10 + data[i] - '0';
        val *= sign;
        u = k + 1;
        auto root = new TreeNode(val);
        root->left = dfs_d(data, u);
        root->right = dfs_d(data, u);
        return root;
    }
};
```
#####  AcWing 60. 礼物的最大价值
```cpp
class Solution {
public:
    int getMaxValue(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<int>> f(n + 1, vector<int>(m + 1));
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= m; j ++ )
                f[i][j] = max(f[i - 1][j], f[i][j - 1]) + grid[i - 1][j - 1];
        return f[n][m];
    }
};
```

### 第十二讲

#####  AcWing 1051. 最大的和
```cpp
#include <iostream>

using namespace std;

const int N = 50010, INF = 1e9;

int n;
int w[N], g[N], h[N];

int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        cin >> n;
        for (int i = 1; i <= n; i ++ ) cin >> w[i];
        g[0] = -INF;
        for (int i = 1, s = 0; i <= n; i ++ )
        {
            s = max(s, 0) + w[i];  // s 就是 f[i]
            g[i] = max(g[i - 1], s);
        }

        h[n + 1] = -INF;
        for (int i = n, s = 0; i; i -- )
        {
            s = max(s, 0) + w[i];
            h[i] = max(h[i + 1], s);
        }

        int res = -INF;
        for (int i = 1; i < n; i ++ ) res = max(res, g[i] + h[i + 1]);

        cout << res << endl;
    }

    return 0;
}
```
#####  AcWing 1026. 乘积最大
```cpp
#include <iostream>

using namespace std;

typedef long long LL;

int n, k;
string num;

LL dfs(int u, int s, LL v, LL p)
{
    if (u == n)
    {
        if (s == k + 1) return p;
        return -1;
    }
    else
    {
        v = v * 10 + num[u] - '0';
        return max(dfs(u + 1, s, v, p),  // 在第u位后面不加乘号
            dfs(u + 1, s + 1, 0, p * v));  // 在第u位后面加乘号
    }
}

int main()
{
    cin >> n >> k >> num;

    cout << dfs(0, 0, 0, 1) << endl;

    return 0;
}
```
#####  AcWing 1698. 余数的最大值
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 34;

int n, m;
int w[N];

void dfs(int u, int k, int s, vector<int> &way)
{
    if (u == k) way.push_back(s);
    else
    {
        dfs(u + 1, k, s, way);
        dfs(u + 1, k, (s + w[u]) % m, way);
    }
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ ) cin >> w[i];

    vector<int> A, B;
    dfs(0, n / 2, 0, A);
    dfs(n / 2, n, 0, B);

    sort(A.begin(), A.end());
    sort(B.begin(), B.end());

    int res = (A.back() + B.back()) % m;
    for (int i = 0, j = B.size() - 1; i < A.size(); i ++ )
    {
        while (j >= 0 && A[i] + B[j] >= m) j -- ;
        if (j >= 0) res = max(res, (A[i] + B[j]) % m);
    }

    cout << res << endl;

    return 0;
}
```

#####  AcWing 1025. 开餐馆
```cpp
#include <iostream>

using namespace std;

const int N = 110;

int n, k;
int f[N], p[N], m[N];

int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        cin >> n >> k;
        for (int i = 1; i <= n; i ++ ) cin >> m[i];
        for (int i = 1; i <= n; i ++ ) cin >> p[i];

        for (int i = 1, maxf = 0, j = 0; i <= n; i ++ )
        {
            while (m[i] - m[j + 1] > k)
            {
                j ++ ;
                maxf = max(maxf, f[j]);
            }
            f[i] = maxf + p[i];
        }

        int res = 0;
        for (int i = 1; i <= n; i ++ ) res = max(res, f[i]);

        cout << res << endl;
    }

    return 0;
}
```
#####  AcWing 1028. 复制书稿
```cpp
#include <iostream>

using namespace std;

const int N = 510;

int n, m;
int w[N], L[N], R[N];

bool check(int sum)
{
    int s = 0, cnt = 1;
    R[cnt] = n;
    for (int i = n; i; i -- )
    {
        if (s + w[i] <= sum) s += w[i];
        else
        {
            L[cnt] = i + 1;
            cnt ++ ;
            R[cnt] = i;
            s = w[i];
        }
    }
    L[cnt] = 1;

    return cnt <= m;
}

int main()
{
    cin >> n >> m;

    int l = 0, r = 1e9;
    for (int i = 1; i <= n; i ++ )
    {
        cin >> w[i];
        l = max(l, w[i]);
    }

    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    check(r);

    for (int i = m; i; i -- ) cout << L[i] << ' ' << R[i] << endl;

    return 0;
}
```
#####  AcWing 1090. 绿色通道
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 50010;

int n, m;
int w[N];
int q[N], f[N];

bool check(int limit)
{
    int hh = 0, tt = 0;
    for (int i = 1; i <= n; i ++ )
    {
        if (q[hh] < i - limit - 1) hh ++ ;
        f[i] = f[q[hh]] + w[i];
        while (hh <= tt && f[q[tt]] >= f[i]) tt -- ;
        q[ ++ tt] = i;
    }

    for (int i = n - limit; i <= n; i ++ )
        if (f[i] <= m)
            return true;
    return false;
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ) cin >> w[i];

    int l = 0, r = n;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    printf("%d\n", r);

    return 0;
}
```

### 第十三讲 

#####  AcWing 1099. 仙岛求药
```cpp
#include <iostream>
#include <cstring>
#include <queue>

#define x first
#define y second

using namespace std;

typedef pair<int,int> PII;

const int N = 310;

int n, m;
char g[N][N];
int dist[N][N];

int bfs(PII start)
{
    queue<PII> q;
    q.push(start);

    memset(dist, -1, sizeof dist);
    dist[start.x][start.y] = 0;

    int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};
    while (q.size())
    {
        auto t = q.front();
        q.pop();

        for (int i = 0; i < 4; i ++ )
        {
            int x = t.x + dx[i], y = t.y + dy[i];
            if (x < 0 || x >= n || y < 0 || y >= m) continue;
            if (g[x][y] == '#') continue;
            if (dist[x][y] != -1) continue;

            dist[x][y] = dist[t.x][t.y] + 1;
            if (g[x][y] == '*') return dist[x][y];
            q.push({x, y});
        }
    }

    return -1;
}

int main()
{
    while (cin >> n >> m, n || m)
    {
        for (int i = 0; i < n; i ++ ) cin >> g[i];

        PII start;
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < m; j ++ )
                if (g[i][j] == '@')
                    start = {i, j};

        cout << bfs(start) << endl;
    }

    return 0;
}
```
#####  AcWing 1102. 移动骑士
```cpp
#include <iostream>
#include <cstring>
#include <queue>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 310;

int n, m;
int dist[N][N];

int bfs(PII start, PII end)
{
    if (start == end) return 0;

    queue<PII> q;
    q.push(start);

    memset(dist, -1, sizeof dist);
    dist[start.x][start.y] = 0;

    int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};
    int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};
    while (q.size())
    {
        auto t = q.front();
        q.pop();

        for (int i = 0; i < 8; i ++ )
        {
            int x = t.x + dx[i], y = t.y + dy[i];
            if (x < 0 || x > n || y < 0 || y > n) continue;
            if (dist[x][y] != -1) continue;
            dist[x][y] = dist[t.x][t.y] + 1;
            if (end == make_pair(x, y)) return dist[x][y];
            q.push({x, y});
        }
    }

    return -1;
}

int main()
{
    int T;
    cin >> T;

    while (T -- )
    {
        cin >> n;
        PII start, end;
        cin >> start.x >> start.y;
        cin >> end.x >> end.y;

        cout << bfs(start, end) << endl;
    }

    return 0;
}
```
#####  AcWing 1103. 棋盘游戏
```cpp
#include <iostream>
#include <cstring>
#include <queue>

using namespace std;

const int N = 1 << 16;

int dist[N];

int input()
{
    int state = 0;
    for (int i = 0; i < 16; i ++ )
    {
         char c;
         cin >> c;
         if (c == '1') state += 1 << i;
    }
    return state;
}

void bit_swap(int &state, int x, int y)
{
    int a = state >> x & 1, b = state >> y & 1;
    state -= a << x, state -= b << y;
    state += a << y, state += b << x;
}

int bfs(int start, int end)
{
    if (start == end) return 0;

    queue<int> q;
    q.push(start);

    memset(dist, -1, sizeof dist);
    dist[start] = 0;

    int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};
    while (q.size())
    {
        int t = q.front();
        q.pop();

        for (int i = 0; i < 4; i ++ )
            for (int j = 0; j < 4; j ++ )
                for (int k = 0; k < 4; k ++ )
                {
                    int x = i + dx[k], y = j + dy[k];
                    if (x >= 0 && x < 4 && y >= 0 && y < 4)
                    {
                        // 交换(i, j)和(x, y)两个格子中的棋子
                        int state = t;
                        bit_swap(state, i * 4 + j, x * 4 + y);

                        if (dist[state] == -1)
                        {
                            dist[state] = dist[t] + 1;
                            if (state == end) return dist[state];
                            q.push(state);
                        }
                    }
                }
    }

    return -1;
}

int main()
{
    int start = input();
    int end = input();

    cout << bfs(start, end) << endl;

    return 0;
}
#####  AcWing 1111. 字母
```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 30;

int n, m;
char g[N][N];
bool st[N];
int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};

int dfs(int x, int y)
{
    int u = g[x][y] - 'A';
    st[u] = true;

    int sum = 0;
    for (int i = 0; i < 4; i ++ )
    {
        int a = x + dx[i], b = y + dy[i];
        if (a >= 0 && a < n && b >= 0 && b < m)
        {
            int t = g[a][b] - 'A';
            if (!st[t]) sum = max(sum, dfs(a, b));
        }
    }

    st[u] = false;
    return sum + 1;
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ ) cin >> g[i];

    cout << dfs(0, 0) << endl;

    return 0;
}
```
#####  AcWing 1114. 棋盘问题
```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 10;

int n, k;
char g[N][N];
bool st[N];

int dfs(int u, int s)
{
    if (s == k) return 1;
    if (u == n) return 0;

    int res = dfs(u + 1, s);
    for (int i = 0; i < n; i ++ )
        if (g[u][i] == '#' && !st[i])
        {
            st[i] = true;
            res += dfs(u + 1, s + 1);
            st[i] = false;
        }

    return res;
}

int main()
{
    while (cin >> n >> k, n != -1)
    {
        for (int i = 0; i < n; i ++ ) cin >> g[i];

        cout << dfs(0, 0) << endl;
    }

    return 0;
}
```
#####  AcWing 75. 和为S的两个数字
```cpp
class Solution {
public:
    vector<int> findNumbersWithSum(vector<int>& nums, int target) {
        unordered_set<int> S;
        for (auto x : nums)
        {
            if (S.count(target - x)) return {x, target - x};
            S.insert(x);
        }
    }
};
```

### 第十四讲

#####  AcWing 1254. 找树根和孩子
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;
bool st[N];  // 每个点是否存在父节点
vector<int> g[N];

int main()
{
    cin >> n >> m;

    for (int i = 0; i < m; i ++ )
    {
        int father, son;
        cin >> father >> son;
        st[son] = true;
        g[father].push_back(son);
    }

    // 找根节点
    for (int i = 1; i <= 1000; i ++ )
        if (st[i] || g[i].size())
        {
            if (!st[i])
            {
                cout << i << endl;
                break;
            }
        }

    int p = 1;
    for (int i = 2; i <= 1000; i ++ )
        if (g[i].size() > g[p].size())
            p = i;

    cout << p << endl;
    sort(g[p].begin(), g[p].end());

    for (auto x : g[p]) cout << x << ' ';
    cout << endl;

    return 0;
}
```
#####  AcWing 1255. 医院设置
```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 110, M = N * 2, INF = 1e9;

int n;
int cnt[N];
int h[N], e[M], ne[M], idx;

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

int dfs(int u, int father, int dist)
{
    int sum = cnt[u] * dist;

    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (j == father) continue;
        sum += dfs(j, u, dist + 1);
    }

    return sum;
}

int main()
{
    cin >> n;

    memset(h, -1, sizeof h);
    for (int i = 1; i <= n; i ++ )
    {
        int l, r;
        cin >> cnt[i] >> l >> r;
        if (l) add(i, l), add(l, i);
        if (r) add(i, r), add(r, i);
    }

    int res = INF;
    for (int i = 1; i <= n; i ++ ) res = min(res, dfs(i, -1, 0));

    cout << res << endl;

    return 0;
}
```
#####  AcWing 1256. 扩展二叉树
```cpp
#include <iostream>

using namespace std;

string pre, in, post;
int k;

void dfs()
{
    char r = pre[k ++ ];
    if (r == '.') return;

    dfs();
    in += r;  // 中序遍历
    dfs();
    post += r;  // 后序遍历
}

int main()
{
    cin >> pre;
    dfs();
    cout << in << endl << post << endl;
    return 0;
}
```
#####  AcWing 1764. 修塔游戏
```cpp
#include <iostream>

using namespace std;

const int N = 10010;

int n, k;
int c[N], s[N];

int main()
{
    scanf("%d%d", &n, &k);

    int max_cnt = 0;
    for (int i = 0; i < n; i ++ )
    {
        int h;
        scanf("%d", &h);
        c[h] ++ ;
        max_cnt = max(max_cnt, c[h]);
    }

    for (int i = 1; i <= 10000; i ++ )
        s[i] = s[i - 1] + i * c[i];

    if (max_cnt >= k) puts("0");
    else
    {
        int res = 2e9;
        for (int i = 1, cnt = 0; i <= 10000; i ++ )
        {
            int left = cnt * i - s[i - 1];
            int right = s[10000] - s[i] - (n - cnt - c[i]) * i;
            if (cnt + c[i] >= k) res = min(res, left - (cnt + c[i] - k));
            if (n - cnt >= k) res = min(res, right - (n - cnt - k));

            res = min(res, left + right - (n - k));
            cnt += c[i];
        }

        printf("%d\n", res);
    }

    return 0;
}
```
#####  AcWing 1120. 埃及分数
```cpp
#include <iostream>
#include <vector>

using namespace std;

typedef long long LL;

vector<int> ans, path;

LL gcd(LL a, LL b)
{
    return b ? gcd(b, a % b) : a;
}

void dfs(LL x, LL y, int last, int t)
{
    LL d = gcd(x, y);
    x /= d, y /= d;

    if (!t)
    {
        if (!x)
        {
            if (ans.empty() || ans.back() > path.back()) ans = path;
        }

        return;
    }

    int down = max(last, (int)((y + x - 1) / x));
    int up = y * t / x;

    for (int i = down; i <= up; i ++ )
    {
        path.push_back(i);
        dfs(i * x - y, y * i, i + 1, t - 1);
        path.pop_back();
    }
}

int main()
{
    int a, b;
    cin >> a >> b;

    int t = 1;
    while (true)
    {
        dfs(a, b, 1, t);
        if (ans.size()) break;
        t ++ ;
    }

    for (auto x : ans) cout << x << ' ';
    return 0;
}
```
#####  AcWing 79. 滑动窗口的最大值
```cpp
class Solution {
public:
    vector<int> maxInWindows(vector<int>& nums, int k) {
        vector<int> res;
        deque<int> q;
        for (int i = 0; i < nums.size(); i ++ ) {
            while (q.size() && q.front() <= i - k) q.pop_front();
            while (q.size() && nums[q.back()] <= nums[i]) q.pop_back();
            q.push_back(i);
            if (i >= k - 1) res.push_back(nums[q.front()]);
        }
        return res;
    }
};
```

### 第十五讲

#####  AcWing 1318. 取石子游戏
```cpp
#include <iostream>

using namespace std;

int main()
{
    int n, k;
    cin >> n >> k;

    if (n % (k + 1)) puts("1");
    else puts("2");

    return 0;
}
```
#####  AcWing 1302. 矩阵 A × B
```cpp
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 110;

LL A[N][N], B[N][N], C[N][N];

int main()
{
    int n, m, p;
    cin >> n >> m;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            cin >> A[i][j];

    cin >> p;
    for (int i = 0; i < m; i ++ )
        for (int j = 0; j < p; j ++ )
            cin >> B[i][j];

    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < p; j ++ )
            for (int k = 0; k < m; k ++ )
                C[i][j] += A[i][k] * B[k][j];

    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < p; j ++ ) cout << C[i][j] << ' ';
        cout << endl;
    }

    return 0;
}
```
#####  AcWing 1262. 鱼塘钓鱼
```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 110;

int a[N], d[N], l[N];
int spend[N];

int get(int i)
{
    return max(0, a[i] - d[i] * spend[i]);
}

int work(int n, int T)
{
    memset(spend, 0, sizeof spend);

    int res = 0;
    for (int i = 0; i < T; i ++ )
    {
        int t = 1;
        for (int j = 1; j <= n; j ++ )
            if (get(j) > get(t))
                t = j;

        res += get(t);
        spend[t] ++ ;
    }

    return res;
}

int main()
{
    int n, T;
    cin >> n;
    for (int i = 1; i <= n; i ++ ) cin >> a[i];
    for (int i = 1; i <= n; i ++ ) cin >> d[i];
    for (int i = 1; i < n; i ++ ) cin >> l[i], l[i] += l[i - 1];
    cin >> T;

    int res = 0;
    for (int i = 1; i <= n; i ++ ) res = max(res, work(i, T - l[i - 1]));

    cout << res << endl;

    return 0;
}
```
#####  AcWing 1274. 奶牛排队
```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 50010, M = 16;

int n, Q;
int h[N];
int f[N][M], g[N][M];
int log[N];

int main()
{
    scanf("%d%d", &n, &Q);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &h[i]);

    for (int i = 1; i <= n; i ++ )
        while (1 << log[i] + 1 <= i)
            log[i] ++ ;

    for (int j = 0; 1 << j <= n; j ++ )
        for (int i = 1; i + (1 << j) - 1 <= n; i ++ )
            if (!j) f[i][j] = g[i][j] = h[i];
            else
            {
                f[i][j] = max(f[i][j - 1], f[i + (1 << j - 1)][j - 1]);
                g[i][j] = min(g[i][j - 1], g[i + (1 << j - 1)][j - 1]);
            }

    while (Q -- )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        int t = log[r - l + 1];
        int maxh = max(f[l][t], f[r - (1 << t) + 1][t]);
        int minh = min(g[l][t], g[r - (1 << t) + 1][t]);

        printf("%d\n", maxh - minh);
    }

    return 0;
}
```
#####  AcWing 1306. 迷路
```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 110, MOD = 2009;

int n, T;
char w[N][N];
int f[N][N], F[N][N], A[N][N];

void mul(int C[][N], int A[][N], int B[][N])
{
    static int R[N][N];
    memset(R, 0, sizeof R);

    for (int i = 0; i < n * 9; i ++ )
        for (int j = 0; j < n * 9; j ++ )
            for (int k = 0; k < n * 9; k ++ )
                R[i][j] = (R[i][j] + A[i][k] * B[k][j]) % MOD;

    memcpy(C, R, sizeof R);
}

void qmi()
{
    while (T)
    {
        if (T & 1) mul(F, F, A);
        mul(A, A, A);
        T >>= 1;
    }
}

int main()
{
    cin >> n >> T;
    for (int i = 0; i < n; i ++ ) cin >> w[i];

    f[0][0] = 1;
    for (int j = 1; j <= 8; j ++ )
        for (int i = 0; i < n; i ++ )
            for (int k = 0; k < n; k ++ )
            {
                int d = w[k][i] - '0';
                if (d)
                    f[i][j] = (f[i][j] + f[k][j - d]) % MOD;
            }

    // 初始化 F[0]
    for (int j = 0, k = 0; j < 9; j ++ )
        for (int i = 0; i < n; i ++, k ++ )
            F[0][k] = f[i][j];

    for (int j = 1; j <= 8; j ++ )
        for (int i = 0; i < n; i ++ )
            A[j * n + i][(j - 1) * n + i] ++ ;

    for (int i = 0; i < n; i ++ )
        for (int k = 0; k < n; k ++ )
        {
            int d = w[k][i] - '0';
            if (d)
            {
                // f[k][j + 9 - d]
                A[(9 - d) * n + k][8 * n + i] ++ ;
            }
        }

    qmi();

    cout << F[0][n - 1] << endl;

    return 0;
}
```
#####  AcWing 89. a^b
```cpp
#include <iostream>

using namespace std;

int main() {
    int a, b, p;
    cin >> a >> b >> p;

    int res = 1 % p;
    while (b) {
        if (b & 1) res = (long long)res * a % p;
        a = (long long)a * a % p;
        b >>= 1;
    }

    cout << res << endl;

    return 0;
}
```

### 第十六讲

#####  AcWing 1768. H 指数
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
int a[N];

int main()
{
    cin >> n;
    for(int i = 0; i < n; i ++ ) cin >> a[i];
    sort(a, a + n);

    for (int i = n; i >= 0; i -- )
        if (a[n - i] >= i)
        {
            cout << i << endl;
            break;
        }

    return 0;
}
```
#####  AcWing 1769. H 指数 II
```cpp
class Solution {
public:
    int hIndex(vector<int>& citations) {
        int n = citations.size();

        int l = 0, r = n;
        while (l < r)
        {
            int mid = l + r + 1 >> 1;
            if (citations[n - mid] >= mid) l = mid;
            else r = mid - 1;
        }

        return r;
    }
};
```
#####  AcWing 1158. H指数
```cpp
#include <iostream>
#include <cstring>
#include <queue>

using namespace std;

int main()
{
    int T;
    scanf("%d", &T);

    for (int cases = 1; cases <= T; cases ++ )
    {
        printf("Case #%d: ", cases);

        priority_queue<int, vector<int>, greater<int>> heap;

        int n;
        scanf("%d", &n);

        int res = 0;
        while (n -- )
        {
            int x;
            scanf("%d", &x);

            if (x > res) heap.push(x);
            while (heap.size() && heap.top() <= res) heap.pop();
            if (heap.size() > res) res ++ ;

            printf("%d ", res);
        }

        puts("");
    }

    return 0;
}
```
#####  AcWing 1108. 读书
```cpp
#include <iostream>
#include <cstring>

using namespace std;

typedef long long LL;

const int N = 100010;

int n, m, q;
int p[N], r[N];

int main()
{
    int T;
    scanf("%d", &T);

    for (int cases = 1; cases <= T; cases ++ )
    {
        scanf("%d%d%d", &n, &m, &q);

        memset(p, 0, sizeof p);
        memset(r, 0, sizeof r);

        for (int i = 0; i < m; i ++ )
        {
            int x;
            scanf("%d", &x);
            p[x] = 1;
        }

        for (int i = 0; i < q; i ++ )
        {
            int x;
            scanf("%d", &x);
            r[x] ++ ;
        }

        LL res = 0;
        for (int i = 1; i <= n; i ++ )
            for (int j = i; j <= n; j += i)
                if (!p[j])
                    res += r[i];

        printf("Case #%d: %lld\n", cases, res);
    }

    return 0;
}
```
#####  AcWing 558. 乘积三元组
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 7010, M = 200010;

int n;
int a[N];
int s[M];

int main()
{
    int T;
    scanf("%d", &T);

    for (int cases = 1; cases <= T; cases ++ )
    {
        scanf("%d", &n);
        for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);

        sort(a, a + n);

        memset(s, 0, sizeof s);

        LL res = 0;
        int not_zero = 0;
        for (int i = n - 1; i >= 0 && a[i] > 0; i -- )  // 枚举Ay
        {
            not_zero ++ ;
            for (int j = 0; j < i; j ++ )  // 枚举Ax
                if ((LL)a[i] * a[j] < M)
                    res += s[a[i] * a[j]];
            s[a[i]] ++ ;
        }

        int zero = n - not_zero;
        res += (LL)zero * (zero - 1) * (zero - 2) / 6;  // 0 * 0 = 0
        res += (LL)not_zero * zero * (zero - 1) / 2;  // 0 * A = 0

        printf("Case #%d: %lld\n", cases, res);
    }

    return 0;
}
```
#####  AcWing 1060. 墙的重建
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110, M = 1010;

int n, m;
int h[N], s[M];
int f[N][N], g[N][N];

int main()
{
    int T;
    scanf("%d", &T);

    for (int cases = 1; cases <= T; cases ++ )
    {
        scanf("%d%d", &n, &m);
        for (int i = 1; i <= n; i ++ ) scanf("%d", &h[i]);

        for (int i = 1; i <= n; i ++ )
        {
            memset(s, 0, sizeof s);
            for (int j = i, maxs = 0; j <= n; j ++ )
            {
                s[h[j]] ++ ;
                maxs = max(maxs, s[h[j]]);
                g[i][j] = j - i + 1 - maxs;
            }
        }

        memset(f, 0x3f, sizeof f);
        memset(f[0], 0, sizeof f[0]);

        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= m + 1; j ++ )
                for (int k = 0; k < i; k ++ )
                    f[i][j] = min(f[i][j], f[k][j - 1] + g[k + 1][i]);

        printf("Case #%d: %d\n", cases, f[n][m + 1]);
    }

    return 0;
}
```
#####  AcWing 53. 最小的k个数
```cpp
class Solution {
public:
    vector<int> getLeastNumbers_Solution(vector<int> input, int k) {
        priority_queue<int> heap;
        for (auto x : input)
        {
            if (heap.size() < k || heap.top() > x) heap.push(x);
            if (heap.size() > k) heap.pop();
        }
        vector<int> res;
        while (heap.size()) res.push_back(heap.top()), heap.pop();
        reverse(res.begin(), res.end());
        return res;
    }
};
```

### 第十七讲

#####  AcWing 591. 国家领导者
```cpp
#include <iostream>
#include <cstring>
#include <unordered_set>

using namespace std;

bool cmp(string a, string b)
{
    unordered_set<char> A, B;
    for (auto c : a)
        if (c != ' ')
            A.insert(c);
    for (auto c : b)
        if (c != ' ' )
            B.insert(c);

    if (A.size() != B.size()) return A.size() > B.size();

    return a < b;
}

int main()
{
    int T;
    cin >> T;

    for (int C = 1; C <= T; C ++ )
    {
        int n;
        cin >> n;

        getchar();  // 过滤掉第一行的回车
        string leader;
        while (n -- )
        {
            string name;
            getline(cin, name);

            if (cmp(name, leader)) leader = name;
        }

        printf("Case #%d: %s\n", C, leader.c_str());
    }

    return 0;
}
```
#####  AcWing 587. 吃蛋糕
```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 10010;

int f[N];

int main()
{
    int T;
    cin >> T;


    for (int C = 1; C <= T; C ++ )
    {
        int n;
        cin >> n;  // 背包容量

        memset(f, 0x3f, sizeof f);
        f[0] = 0;

        for (int i = 1; i * i <= n; i ++ )
            for (int j = i * i; j <= n; j ++ )
                f[j] = min(f[j], f[j - i * i] + 1);

        printf("Case #%d: %d\n", C, f[n]);
    }

    return 0;
}
```
#####  AcWing 561. 大按钮
```cpp
Trie O(TPN)
#include <iostream>
#include <cstring>

using namespace std;

typedef long long LL;

const int N = 5010;

int n;
int tr[N][2], idx;
bool is_end[N];
char str[55];

void insert()
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] == 'B' ? 0 : 1;
        if (tr[p][u] == 0) tr[p][u] = ++ idx;
        p = tr[p][u];
    }

    is_end[p] = true;
}

LL dfs(int u, int d)
{
    if (is_end[u]) return 1ll << (n - d);

    LL res = 0;
    for (int i = 0; i < 2; i ++ )
        if (tr[u][i])
            res += dfs(tr[u][i], d + 1);

    return res;
}

int main()
{
    int T;
    scanf("%d", &T);

    for (int C = 1; C <= T; C ++ )
    {
        int p;
        scanf("%d%d", &n, &p);

        memset(is_end, 0, sizeof is_end);
        memset(tr, 0, sizeof tr);
        idx = 0;

        for (int i = 0; i < p; i ++ )
        {
            scanf("%s", str);
            insert();
        }

        LL res = (1ll << n) - dfs(0, 0);

        printf("Case #%d: %lld\n", C, res);
    }

    return 0;
}
哈希表 O(TPN2)
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unordered_set>

using namespace std;

typedef long long LL;

const int N = 110;

int main()
{
    int T;
    scanf("%d", &T);
    for (int cases = 1; cases <= T; cases ++ )
    {
        int n, p;
        scanf("%d%d", &n, &p);

        string strs[N];
        for (int i = 0; i < p; i ++ ) cin >> strs[i];
        sort(strs, strs + p);

        unordered_set<string> S;

        LL res = 1ll << n;

        for (int i = 0; i < p; i ++ )
        {
            string a;

            bool exists = false;
            for (int j = 0; j < strs[i].size(); j ++ )
            {
                a += strs[i][j];
                if (S.count(a))
                {
                    exists = true;
                    break;
                }
            }

            if (!exists) res -= 1ll << n - strs[i].size();
            S.insert(strs[i]);
        }

        printf("Case #%d: %lld\n", cases, res);
    }

    return 0;
}
```
#####  AcWing 571. 数学编码器
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 10010, MOD = 1e9 + 7;

int a[N];
int p[N];

int main()
{
    int T;
    scanf("%d", &T);

    p[0] = 1;
    for (int i = 1; i < N; i ++ ) p[i] = p[i - 1] * 2 % MOD;

    for (int C = 1; C <= T; C ++ )
    {
        int n;
        scanf("%d", &n);
        for(int i = 0; i < n; i ++ ) scanf("%d", &a[i]);

        sort(a, a + n);

        int res = 0;
        for (int i = 0; i < n; i ++ )
            res = (res + (LL)a[i] * (p[i] - p[n - 1 - i])) % MOD;

        printf("Case #%d: %d\n", C, res);
    }

    return 0;
}

```
#####  AcWing 623. 投票
```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 2010;

int n, m;
double f[N][N];

int main()
{
    int T;
    scanf("%d", &T);

    for (int C = 1; C <= T; C ++ )
    {
        scanf("%d%d", &n, &m);

        memset(f, 0, sizeof f);
        f[1][0] = (double)n / (n + m);
        for (int i = 1; i <= n; i ++ )
            for (int j = 0; j < i; j ++ )
            {
                f[i + 1][j] += f[i][j] * (n - i) / (n + m - i - j);
                f[i][j + 1] += f[i][j] * (m - j) / (n + m - i - j);
            }

        printf("Case #%d: %.8lf\n", C, f[n][m]);
    }

    return 0;
}
```
#####  AcWing 578. 去观光
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 2010;

int n, Ts, Tf;
LL f[N][N];
struct Bus
{
    int s, f, d;
}bus[N];

LL get_off(int t, int i)
{
    int s = bus[i - 1].s, f = bus[i - 1].f, d = bus[i - 1].d;

    int x = (t - s + f - 1) / f;
    x = max(x, 0);

    LL go_on_t = s + (LL)x * f;
    return go_on_t + d;
}

int main()
{
    int T;
    scanf("%d", &T);

    for (int C = 1; C <= T; C ++ )
    {
        scanf("%d%d%d", &n, &Ts, &Tf);
        for (int i = 1; i < n; i ++ )
        {
            int s, f, d;
            scanf("%d%d%d", &s, &f, &d);
            bus[i] = {s, f, d};
        }

        memset(f, 0x3f, sizeof f);
        f[1][0] = 0, f[1][1] = Ts;

        for (int i = 2; i <= n; i ++ )
            for (int j = 0; j <= i; j ++ )
            {
                f[i][j] = get_off(f[i - 1][j], i);
                if (i < n) f[i][j] = min(f[i][j], get_off(f[i - 1][j - 1], i) + Ts);
            }

        int k = n - 1;
        while (k >= 0 && f[n][k] > Tf) k -- ;

        printf("Case #%d: ", C);
        if (k < 0) puts("IMPOSSIBLE");
        else printf("%d\n", k);
    }

    return 0;
}
```
#####  AcWing 80. 骰子的点数
```cpp
class Solution {
public:
    vector<int> numberOfDice(int n) {
        vector<vector<int>> f(n + 1, vector<int>(n * 6 + 1));
        f[0][0] = 1;
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= i * 6; j ++ )
                for (int k = 1; k <= min(j, 6); k ++ )
                    f[i][j] += f[i - 1][j - k];

        vector<int> res;
        for (int i = n; i <= n * 6; i ++ ) res.push_back(f[n][i]);
        return res;
    }
};
```


### 第十八讲 

#####  AcWing 687. 扫雷
```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 310;

int n;
char str[N][N];
int g[N][N];

void dfs(int a, int b)
{
    int t = g[a][b];
    g[a][b] = -1;
    if (t) return;

    for (int x = a - 1; x <= a + 1; x ++ )
        for (int y = b - 1; y <= b + 1; y ++ )
            if (x >= 0 && x < n && y >= 0 && y < n && g[x][y] != -1)
                dfs(x, y);
}

int main()
{
    int T;
    scanf("%d", &T);

    for (int C = 1; C <= T; C ++ )
    {
        scanf("%d", &n);
        for (int i = 0; i < n; i ++ ) scanf("%s", str[i]);

        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < n; j ++ )
                if (str[i][j] == '*') g[i][j] = -1;
                else
                {
                    g[i][j] = 0;
                    for (int x = i - 1; x <= i + 1; x ++ )
                        for (int y = j - 1; y <= j + 1; y ++ )
                            if (x >= 0 && x < n && y >= 0 && y < n && str[x][y] == '*')
                                g[i][j] ++ ;
                }

        int res = 0;
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < n; j ++ )
                if (g[i][j] == 0)
                {
                    res ++ ;
                    dfs(i, j);
                }

        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < n; j ++ )
                if (g[i][j] != -1)
                    res ++ ;

        printf("Case #%d: %d\n", C, res);
    }

    return 0;
}
```
#####  AcWing 562. 壁画
```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 5000010;

int n;
char str[N];
int s[N];

int main()
{
    int T;
    scanf("%d", &T);

    for (int C = 1; C <= T; C ++ )
    {
        scanf("%d%s", &n, str + 1);
        for (int i = 1; i <= n; i ++ ) s[i] = s[i - 1] + str[i] - '0';

        int k = (n + 1) / 2;
        int res = 0;
        for (int i = k; i <= n; i ++ ) res = max(res, s[i] - s[i - k]);

        printf("Case #%d: %d\n", C, res);
    }

    return 0;
}

```
#####  AcWing 595. 夏洛克和括号
```cpp
#include <iostream>
#include <cstring>

using namespace std;

typedef long long LL;

int main()
{
    int T;
    cin >> T;

    for (int C = 1; C <= T; C ++ )
    {
        int l, r;
        cin >> l >> r;
        int k = min(l, r);

        printf("Case #%d: %lld\n", C, (LL)k * (k + 1) / 2);
    }

    return 0;
}
```
#####  AcWing 620. 安全区
```cpp
#include <iostream>
#include <cstring>

using namespace std;

typedef long long LL;

const int N = 3010;

int n, m, k;
int s[N][N];
int f[N][N];

int main()
{
    int T;
    scanf("%d", &T);

    for (int C = 1; C <= T; C ++ )
    {
        scanf("%d%d%d", &n, &m, &k);

        memset(s, 0, sizeof s);
        for (int i = 0; i < k; i ++ )
        {
            int x, y;
            scanf("%d%d", &x, &y);
            s[x + 1][y + 1] = 1;
        }

        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= m; j ++ )
                if (s[i][j])
                    f[i][j] = 0;
                else
                    f[i][j] = min(f[i - 1][j - 1], min(f[i - 1][j], f[i][j - 1])) + 1;

        LL res = 0;
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= m; j ++ )
                res += f[i][j];

        printf("Case #%d: %lld\n", C, res);
    }

    return 0;
}
```
#####  AcWing 628. 美丽的数
```cpp
#include <iostream>
#include <cstring>

using namespace std;

typedef long long LL;

int check(LL n, LL b, int k)
{
    LL res = 1;
    for (int i = 0; i < k; i ++ )
    {
        if (res > (n - 1) / b) return 1;
        res = res * b + 1;
    }

    if (res == n) return 0;
    return -1;
}

int main()
{
    int T;
    cin >> T;

    for (int C = 1; C <= T; C ++ )
    {
        LL n;
        cin >> n;

        for (int k = 63; k; k -- )
        {
            LL l = 2, r = n;
            while (l < r)
            {
                LL mid = l + r >> 1;
                if (check(n, mid, k) >= 0) r = mid;
                else l = mid + 1;
            }

            if (check(n, r, k) == 0)
            {
                printf("Case #%d: %lld\n", C, r);
                break;
            }
        }
    }

    return 0;
}
```
#####  AcWing 76. 和为S的连续正数序列
```cpp
class Solution {
public:
    vector<vector<int> > findContinuousSequence(int sum) {
        vector<vector<int>> res;
        for (int i = 1, j = 1, s = 1; i <= sum / 2; i ++ )
        {
            while (s < sum) s += ++ j;
            if (s == sum && j - i > 0)
            {
                vector<int> line;
                for (int k = i; k <= j; k ++ ) line.push_back(k);
                res.push_back(line);
            }
            s -= i;
        }
        return res;
    }
};
```

### 第十九讲
#####  AcWing 647. 懒惰拼字赛
```cpp
#include <iostream>
#include <cstring>
#include <set>

using namespace std;

typedef long long LL;

const int N = 1010, mod = 1e9 + 7;

int n;
char str[N];

int main()
{
    int T;
    cin >> T;

    for (int C = 1; C <= T; C ++ )
    {
        cin >> str;
        n = strlen(str);

        int res = 1;
        for (int i = 0; i < n; i ++ )
        {
            set<char> S;
            for (int j = max(0, i - 1); j <= min(n - 1, i + 1); j ++ )
                S.insert(str[j]);

            res = (LL)res * S.size() % mod;
        }

        printf("Case #%d: %d\n", C, res);
    }

    return 0;
}
```

#####  AcWing 627. 排灯节照明
```cpp
#include <iostream>
#include <cstring>

using namespace std;

typedef long long LL;

const int N = 110;

char str[N];

LL calc(LL n)
{
    int k = strlen(str + 1);

    LL tot = 0;
    for (int i = 1; i <= k; i ++ )
        if (str[i] == 'B')
            tot ++ ;

    tot *= n / k;

    for (int i = 1; i <= n % k; i ++ )
        if (str[i] == 'B')
            tot ++ ;

    return tot;
}

int main()
{
    int T;
    cin >> T;

    for (int C = 1; C <= T; C ++ )
    {
        cin >> str + 1;
        LL l, r;
        cin >> l >> r;

        printf("Case #%d: %lld\n", C, calc(r) - calc(l - 1));
    }

    return 0;
}
```
#####  AcWing 631. Googol字符串
```cpp
#include <iostream>
#include <cstring>

using namespace std;

typedef long long LL;

int f(int n, LL k)
{
    LL len = (1ll << n - 1) - 1;
    if (k <= len) return f(n - 1, k);
    if (k == len + 1) return 0;
    return 1 - f(n - 1, len + 1 - (k - len - 1));
}

int main()
{
    int T;
    cin >> T;

    for (int C = 1; C <= T; C ++ )
    {
        LL k;
        cin >> k;

        printf("Case #%d: %d\n", C, f(63, k));
    }

    return 0;
}
```
#####  AcWing 643. 动态网格
```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 110;

int n, m;
char g[N][N];
bool st[N][N];
int dx[] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

void dfs(int a, int b)
{
    st[a][b] = true;

    for (int i = 0; i < 4; i ++ )
    {
        int x = a + dx[i], y = b + dy[i];
        if (x >= 0 && x < n && y >= 0 && y < m && g[x][y] == '1' && !st[x][y])
            dfs(x, y);
    }
}

int work()
{
    memset(st, 0, sizeof st);

    int cnt = 0;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            if (g[i][j] == '1' && !st[i][j])
            {
                dfs(i, j);
                cnt ++ ;
            }

    return cnt;
}

int main()
{
    int T;
    cin >> T;

    for (int C = 1; C <= T; C ++ )
    {
        cin >> n >> m;
        for (int i = 0; i < n; i ++ ) cin >> g[i];

        int k;
        cin >> k;

        printf("Case #%d:\n", C);
        while (k -- )
        {
            char op;
            cin >> op;

            if (op == 'Q') printf("%d\n", work());
            else
            {
                int x, y, z;
                cin >> x >> y >> z;
                g[x][y] = '0' + z;
            }
        }
    }

    return 0;
}
```
#####  AcWing 695. 劣马
```cpp
#include <iostream>
#include <cstring>
#include <unordered_map>
#include <vector>

using namespace std;

int m;
unordered_map<string, vector<string>> g;
unordered_map<string, int> color;

bool dfs(string u, int c)
{
    color[u] = c;

    for (auto e : g[u])
        if (color.count(e))
        {
            if (color[e] == c) return false;
        }
        else if (!dfs(e, 1 - c)) return false;

    return true;
}

bool check()
{
    for (auto item : g)
    {
        string u = item.first;
        if (color.count(u) == 0 && !dfs(u, 0))
            return false;
    }

    return true;
}

int main()
{
    int T;
    cin >> T;
    for (int C = 1; C <= T; C ++ )
    {
        int m;
        cin >> m;

        g.clear();
        color.clear();

        while (m -- )
        {
            string a, b;
            cin >> a >> b;
            g[a].push_back(b);
            g[b].push_back(a);
        }

        if (check()) printf("Case #%d: Yes\n", C);
        else printf("Case #%d: No\n", C);
    }

    return 0;
}
```
#####  AcWing 592. 雨
```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 55;

int n, m;
int h[N][N];
bool st[N][N];

struct Cell
{
    int f;
    int x, y;

    bool operator> (const Cell &t) const
    {
        return f > t.f;
    }
};

int main()
{
    int T;
    scanf("%d", &T);

    for (int C = 1; C <= T; C ++ )
    {
        scanf("%d%d", &n, &m);
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= m; j ++ )
                scanf("%d", &h[i][j]);

        priority_queue<Cell, vector<Cell>, greater<Cell>> heap;

        memset(st, 0, sizeof st);
        for (int i = 1; i <= n; i ++ )
        {
            st[i][1] = st[i][m] = true;
            heap.push({h[i][1], i, 1});
            heap.push({h[i][m], i, m});
        }

        for (int i = 1; i <= m; i ++ )
        {
            st[1][i] = st[n][i] = true;
            heap.push({h[1][i], 1, i});
            heap.push({h[n][i], n, i});
        }

        int res = 0;
        int dx[] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
        while (heap.size())
        {
            auto t = heap.top();
            heap.pop();

            for (int i = 0; i < 4; i ++ )
            {
                int x = t.x + dx[i], y = t.y + dy[i];
                if (x && x <= n && y && y <= m && !st[x][y])
                {
                    st[x][y] = true;
                    if (h[x][y] < t.f) res += t.f - h[x][y];
                    heap.push({max(h[x][y], t.f), x, y});
                }
            }
        }

        printf("Case #%d: %d\n", C, res);
    }

    return 0;
}
```
#####  AcWing 72. 平衡二叉树
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:

    bool ans = true;

    bool isBalanced(TreeNode* root) {
        dfs(root);
        return ans;
    }

    int dfs(TreeNode *root)
    {
        if (!root) return 0;
        int left = dfs(root->left), right = dfs(root->right);
        if (abs(left - right) > 1) ans = false;
        return max(left, right) + 1;
    }
};
```

### 第二十讲
#####  AcWing 703. 数独检查
```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 40;

int n, m;
int a[N][N];
bool st[N];

bool check_row()
{
    for (int i = 0; i < m; i ++ )
    {
        memset(st, 0, sizeof st);
        for (int j = 0; j < m; j ++ )
        {
            int t = a[i][j];

            if (t < 1 || t > m) return false;
            if (st[t]) return false;
            st[t] = true;
        }
    }

    return true;
}

bool check_col()
{
    for (int i = 0; i < m; i ++ )
    {
        memset(st, 0, sizeof st);
        for (int j = 0; j < m; j ++ )
        {
            int t = a[j][i];
            if (t < 1 || t > m) return false;
            if (st[t]) return false;
            st[t] = true;
        }
    }

    return true;
}

bool check_cell()
{
    for (int x = 0; x < m; x += n)
        for (int y = 0; y < m; y += n)
        {
            memset(st, 0, sizeof st);
            for (int dx = 0; dx < n; dx ++ )
                for (int dy = 0; dy < n; dy ++ )
                {
                    int t = a[x + dx][y + dy];
                    if (t < 1 || t > m) return false;
                    if (st[t]) return false;
                    st[t] = true;
                }
        }

    return true;
}

int main()
{
    int T;
    cin >> T;

    for (int C = 1; C <= T; C ++ )
    {
        cin >> n;
        m = n * n;

        for (int i = 0; i < m; i ++ )
            for (int j = 0; j < m; j ++ )
                cin >> a[i][j];

        if (check_row() && check_col() && check_cell()) printf("Case #%d: Yes\n", C);
        else printf("Case #%d: No\n", C);
    }

    return 0;
}
```
#####  AcWing 697. 蒙斯特
```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 110;

int n;
string cards[N];

int main()
{
    int T;
    cin >> T;

    for (int C = 1; C <= T; C ++ )
    {
        cin >> n;
        getchar();
        for (int i = 0; i < n; i ++ ) getline(cin, cards[i]);

        int res = 0;
        // 插入排序
        for (int i = 1; i < n; i ++ )
            if (cards[i] < cards[i - 1])
            {
                for (int j = i; j; j -- )
                    if (cards[j] < cards[j - 1])
                        swap(cards[j], cards[j - 1]);
                res ++ ;
            }

        printf("Case #%d: %d\n", C, res);
    }

    return 0;
}
```
#####  AcWing 698. 读电话号码
```cpp
#include <iostream>
#include <cstring>
#include <sstream>
#include <vector>

using namespace std;

string nums[] = {
    "zero", "one", "two", "three", "four",
    "five", "six", "seven", "eight", "nine",
};

string cnts[] = {
    "", "", "double", "triple", "quadruple",
    "quintuple", "sextuple", "septuple", "octuple",
    "nonuple", "decuple"
};

void print(string s)
{
    for (int i = 0; i < s.size(); i ++ )
    {
        int j = i + 1;
        while (j < s.size() && s[j] == s[i]) j ++ ;

        int len = j - i;
        if (len >= 2 && len <= 10) cout << cnts[len] << ' ' << nums[s[i] - '0'] << ' ';
        else if (len > 10)
        {
            for (int k = 0; k < len; k ++ )
                cout << nums[s[i] - '0'] << ' ';
        }
        else cout << nums[s[i] - '0'] << ' ';

        i = j - 1;
    }
}

int main()
{
    int T;
    cin >> T;

    for (int C = 1; C <= T; C ++ )
    {
        string s, seq;
        cin >> s >> seq;

        vector<int> len;
        string str;
        stringstream ssin(seq);
        while (getline(ssin, str, '-')) len.push_back(stoi(str));

        printf("Case #%d:  ", C);

        int start = 0;
        for (int l : len)
        {
            print(s.substr(start, l));
            start += l;
        }

        puts("");
    }

    return 0;
}
```
#####  AcWing 696. 哈默队长
```cpp
#include <iostream>
#include <cmath>

#define PI acos(-1)

using namespace std;

int main()
{
    int T;
    cin >> T;

    for (int C = 1; C <= T; C ++ )
    {
        double v, d;
        cin >> v >> d;
        double g = 9.8;

        double l = 0, r = 45;
        while (r - l > 1e-8)
        {
            double mid = (l + r ) / 2;
            if (v * v * sin(2 * mid / 180 * PI) / g >= d) r = mid;
            else l = mid;
        }

        printf("Case #%d: %.8lf\n", C, r);
    }

    return 0;
}
```
#####  AcWing 1109. 等式
```cpp
#include <iostream>
#include <cstring>

using namespace std;

typedef long long LL;

const int N = 1010;

int n;
LL m;
LL a[N];
LL s[60][2];

LL get_min(int i)
{
    LL res = 0;
    for (int k = i; k >= 0; k -- )
        res += min(s[k][0], s[k][1]);
    return res;
}

int main()
{
    int T;
    cin >> T;

    for (int C = 1; C <= T; C ++ )
    {
        cin >> n >> m;
        for (int i = 0; i < n; i ++ ) cin >> a[i];

        memset(s, 0, sizeof s);
        for (int i = 0; i < 50; i ++ )
            for (int j = 0; j < n; j ++ )
                if (a[j] >> i & 1)
                    s[i][0] += 1ll << i;
                else
                    s[i][1] += 1ll << i;

        LL res = 0, sum = 0;

        if (get_min(49) > m) res = -1;
        else
        {
            for (int i = 49; i >= 0; i -- )
                if (sum + get_min(i - 1) + s[i][1] <= m)
                {
                    res += 1ll << i;
                    sum += s[i][1];
                }
                else
                    sum += s[i][0];
        }

        printf("Case #%d: %lld\n", C, res);
    }

    return 0;
}
```
#####  AcWing 914. 樱桃网
```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 100010;

int n, m;
int p[N];

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    int T;
    scanf("%d", &T);

    for (int C = 1; C <= T; C ++ )
    {
        scanf("%d%d", &n, &m);

        for (int i = 1; i <= n; i ++ ) p[i] = i;

        int k = 0;
        while (m -- )
        {
            int a, b;
            scanf("%d%d", &a, &b);
            if (find(a) != find(b))
            {
                p[find(a)] = find(b);
                k ++ ;
            }
        }

        printf("Case #%d: %d\n", C, k * 1 + (n - 1 - k) * 2);
    }

    return 0;
}
```
#####  AcWing 78. 左旋转字符串
```cpp
class Solution {
public:
    string leftRotateString(string str, int n) {
        reverse(str.begin(), str.end());
        reverse(str.begin(), str.begin() + str.size() - n);
        reverse(str.begin() + str.size() - n, str.end());
        return str;
    }
};
```
