### 3.7　过程

**小点1**

- 当函数执行时需要的存储空间大于寄存器空间时，就会借用栈上的存储空间。
- main函数在调用子函数时，要把返回地址存到栈中，子函数调用结束后，就接着把栈中的返回地址弹出来，接着运行main函数。
- 当一个函数的参数多于6个时，多余的参数要通过栈来传递。
- 用栈来传递参数时，存储数据的大小都是以8个字节的倍数分配空间。
- 用栈来保存局部变量时，局部变量不需要8字节对齐

**小点2**

- C中的取地址符`&`返回的是内存地址，所以一定要保存在内存中。
- 保存到内存中进行参数传输时，要求每个参数大小为8字节的倍数，即要求相对`%rsp`的偏移量为8的倍数
- 不会显示地操作程序计数器寄存器`%rip`，没有指令可以对其操作，只能通过类似`call`或`ret`间接对其操作。
- 栈顶指针`%rsp`是随着函数运行不断变化的。
- 函数可以假设“被调用者保存寄存器”的值是不变的，而可以用“调用者保存寄存器”来保存临时值。
- 某个函数要永久使用的值，要么保存在“被调用者保存寄存器”中，要么保存在内存中。
- 当函数需要使用“被调用者保存寄存器”时，就直接将其`push`到栈中，使用过后再`pop`重置。
- 无论是“被保存的寄存器”还是“局部变量”以及“参数构造区”，一开始如何申请这些区域，后面使用完后还会逆向地通过`%rsp`将这些区域释放掉，这是动态的过程，使得一个函数运行完时，`%rsp`指向的就是返回地址，就能直接通过`ret`返回到调用者的断点处。

![img](pics/v2-15dd017291dfe33b74be5595980a06ea_720w.jpg)

- 进入一个函数时，首先将要使用的“被调用者保存寄存器”`push`到栈中，然后**通过`%rsp`来申请一段固定大小的空间**，用来存放局部变量和参数构造区，最后再释放申请的空间。

#### 3.7.1　运行时栈

##### 栈帧：

- 当函数需要的存储空间超出寄存器能够存放的大小，或者调用别的函数需要保存额外数据时，就会在栈上分配一个空间，这个空间称为函数的**栈帧（Stack Frame）**。

- 相对的，当某个函数的所有局部变量都能保存在寄存器中，并且不会调用任何的函数时，就无需开辟该函数的栈帧了。
- 当给一个函数创建栈帧时，编译器会给函数分配所需的**定长**的栈帧，在函数开始时就分配好后就不会改变了，所以栈顶指针`%rsp`就知道当函数返回时，需要释放多少空间。而有些函数需要变长的栈帧。

注意：栈顶的栈帧对应了正在运行的函数。

- 所以每个函数的栈帧就作为栈的基本元素，来起到函数调用时先进后出的效果，会在栈中保存之前所有还未返回的函数的栈帧，将之前的函数先挂起。这里提供了`PUSH`和`POP`指令对栈进行操作，也可以直接对栈顶指针`%rsp`进行操作。

注意：因为未返回的函数都会在内存中保存自己的栈帧，而栈的空间是有限的，所以当调用过多时，会造成栈的溢出。

#### 3.7.2　转移控制

当函数P调用函数Q运行时：
   - 由于x86-64只提供6个寄存器来传递函数输入值，所以当函数P传递给函数Q的参数多于6个时，需要函数P在自己的栈帧中存储好这些输入参数。
   - 会先将返回地址压入栈中，表明当函数Q返回时，要从函数P中的哪个位置继续执行，这个作为P的栈帧的一部分。

- 函数Q运行时：函数Q会扩展当前栈的边界，分配函数Q的栈帧所需的空间，可以用来保存寄存器的值、分配局部变量空间，为函数Q调用其他函数设置参数。

- 函数Q返回时：释放分配给函数Q的栈帧，并且让程序计数器调用返回地址，继续从函数P的断点处继续执行。

![img](pics/v2-91464005565bfbada7e8b74dd7f87528_720w.jpg)

#### 3.7.3　数据传送

**被保存的寄存器**

被调用者保存寄存器：%rbx、%rbp和%r12~%r15。这部分寄存是由被调用者，即Q保存的。
调用者保存寄存器：除了上面的寄存器外，都属于被调用者保存寄存器。
注意：当函数P调用函数Q时，“被调用者保存寄存器”就会保存在函数Q的栈帧中，所以当函数Q返回时，这部分寄存器会被重置为函数P使用时的状态。而其他寄存器的值是需要函数P自己保存的，所以函数P需要自己开辟局部变量区域来保存其他寄存器的值。


#### 3.7.4　栈上的局部存储

**局部变量**

当函数需要保存的数据不多时，就会将数据保存在“被调用者保存寄存器”中。但是以下情况必须保存在内存中，该部分称为该函数的局部变量：

- “被调用者保存寄存器”不足以保存所有的本地数据
- 当一个局部变量使用取地址符&时，指的是返回该变量在内存中的地址，就必须将其保存在内存中。
- 当局部变量是数组或结构时。

#### 3.7.5　寄存器中的局部存储空间

**参数构造区**

- 主要任务：函数P必须能够向函数Q传递一个或多个参数，而函数Q必须能够向函数P返回一个值。    
- 在函数间传递数据，主要通过寄存器进行，x86-64提供了6个用于传递参数的寄存器，根据参数的顺序，需要放入特定的寄存器中。x86-64将寄存器%rax作为函数返回值的寄存器。
- 如果某个函数要传递超过6个参数的话，就需要将第7个到第n个参数保存在栈中，然后通过栈顶指针%rsp进行索引其中第7个参数在栈顶位置。要求每个参数的大小要为8字节的倍数。这部分区域称为参数构造区

![img](pics/v2-94244742aede5e0d6d534c688470168f_720w.jpg)

![img](pics/v2-0168d4ce0a8c42624861130fe1c98b62_720w.jpg)

由于栈顶还要保存一个8字节的返回地址，所以第7个参数的地址为`8(%rsp)`，如果第7个元素大小不超过8字节，则第8个元素的地址为`16(%rsp)`，以此类推。

注意：这些寄存器只能用来保存整数或指针类型。

#### 3.7.6　递归过程

**返回地址**

主要任务：在进入函数Q的时候，程序计数器要设置为Q的代码的起始位置。从函数Q返回时，要把程序计数器设置为P中调用Q后面那条指令的地址，即从P中的断点处继续执行。

x86-64提供了一组指令来完成上述操作

![img](pics/v2-a5bb83c1e8f8e735e89d0d3cf0f1f507_720w.jpg)

注意：在64位操作系统中，返回地址是64位8字节的。

- 1.（被保存的寄存器）函数P将要使用的“被调用者保存寄存器”通过push保存在函数的栈帧中。
- 2.（局部变量）如果函数P使用了“调用者保存寄存器”，就需要将其保存在栈中，才能调用函数Q。并且函数P根据需要申请空间来保存其他局部变量。
- 3.（参数构造区）函数P将参数保存在寄存器中，如果超过6个参数，就申请空间保存到内存中。
- 4.（返回地址）函数P使用call指令调用函数Q，会将call的下一行指令的地址压入栈中，并将程序计数器指向函数Q的第一条指令的地址。
当函数Q运行时会随着使用动态申请和释放局部变量，当函数Q运行完时，首先使用栈“被调用者保存寄存器”的值，然后使用ret指令返回将程序计数器设置为栈顶的返回地址，最后将栈顶的返回地址弹出。

### 3.8　数组分配和访问

- 指针进行加减运算时会根据指针类型选择加的基数。
- 当（定长）二维数组A的某行和（定长）二维数组B的某列进行内积运算时，c语言的实验是一个循环，汇编语言的优化指令就是条件加跳转，首先记录下A行的首地址，B列的首地址和尾地址，相乘之后放到一个寄存器中，再移动到下一个要相乘的数，直到B列地址与尾地址相同。

- 当你声明了一个数组，你既为它分配了空间，并且创建了一个允许进行指针运算的数组名称。而当你声明一个指针时，你所分配的只有指针本身的空间。
- 当程序要用一个常数作为数维度或者缓冲区大小时，最好通过`#define`声明将这个常数与一个名字联系起来，后面就一直使用这个名字代替常数的数值。
- 在`struct`和`union`中的对象，都是保存在内存中的。
- 定义结构体时，按照对象K值的大小，**从大到小声明**，可以减少填充的空间，节省整个结构体的大小。


#### 3.8.1　基本原则

对于数据类型`T`和整形常量`N`，声明一个数组变量`A`：

```c
T A[N];
```

主要经历两个步骤：

1. 根据数据类型`T`的大小`L`字节，先在内存空间中分配一个大小为`L*N`的连续空间；
2. 将`A`作为这个连续内存空间的起始指针，即A的值`xA`就是该内存空间的起始地址。

注意：当你声明了一个数组，你既为它分配了空间，并且创建了一个允许进行指针运算的数组名称。而当你声明一个指针时，你所分配的只有指针本身的空间，所以如果没有初始化指针，直接对其进行解引用可能会出现错误。

#### 3.8.2　指针运算

看下**数组和指针的区别：**

```text
int A1[3];
int *A2;
int *A3[3];
int (*A4)[3];
```

- `sizeof(A1)`为12，返回的是数组内保存的全部元素大小； `sizeof(*A1)`为4，返回的是第一个元素的大小，即`int`的大小。而`sizeof(A2)`为8，返回的只是指针的大小；`sizeof(*A2)`为4，返回的也是`int`的大小。
- 如果没有对`A2`进行初始化，直接调用`*A2`可能会报错，因为它没有指向合理的对象。而`*A1`不可能出错，因为创建数组时，已经为他分配好了空间。
- `A3`声明了大小为3的数组，每个元素的类型为`int *`，所以`sizeof(A3)`为24，因为数组内有3个元素，每个元素都是指针，大小为8。而`sizeof(*A3)`为8，因为`A3`的第一个元素是一个指针，大小就为8。而`sizeof(**A3)`为4，它表示的是数组中第一个指针指向的`int`，所以是4。因为`A3`首先声明的是一个数组，所以它会自动分配好数组的空间，所以`*A3`不会是空指针，但是它里面保存的是指针，所以`**A3`可能会是空指针。
- `A4`定义了一个指向大小为3的`int`数组的指针。所以`sizeof(A4)`为8，只是一个单纯的指针的大小；`sizeof(*A4)`为12，它表示`A4`指向的数组的大小。而`sizeof(**A4)`为4，它表示`A4`指向的数组的第一个元素。 因为这里只是单纯声明了一个指针，所以`*A4`和`**A4`都可能是空指针。

综上：假设数据大小为L，起始地址x保存在%rdx，索引i保存在%rcx中，索引偏移量通过func(i)计算得到，则：

通过索引偏移量func(i)计算内存地址的偏移量L*func(i)=Ai+B
获取内存地址的汇编代码为lea_ B(%rdx, %rcx, A), %_。获得数据的汇编代码为mov_ B(%rdx, %rcx, A), %_。

#### 3.8.3　嵌套的数组

```c
T D[R][C]
```

其中，`R`是行数，`C`是列数。

在内存中，这种二维数组是按照“行优先”的形式保存在内存中的，即先按顺序保存`D[0]`的`C`个元素，然后再紧接着保存`D[1]`的`C`个元素，以此类推。

![img](pics/v2-c0a90df9cb0c7a2f5cd411cc3049e3a7_720w.jpg)

所以当该数组的起始地址为`x`，`T`的大小为`L`时，`D[i][j]`的地址为`x+L(Ci+j)`。类似一元数组，我们也可以很容易地通过“比例变址寻址”的方式进行索引。

![img](pics/v2-4a8e5a38ef03df9ab12abbddfdb02bea_720w.jpg)

#### 3.8.4　定长数组

当我们使用`#define`定义一个变量`N`为常量后，再用`N`来确定数组大小，则该数组是一个定长数组，这里展示一个`-O1`时GCC采用的优化。

对于以下代码：

![img](pics/v2-7481364d7aecbeeddaa020e344906611_720w.jpg)

我们首先看它经过优化后的C代码

![img](pics/v2-002541eca8d7602526e4b5270c99f4f8_720w.jpg)

可以发现这里省略了变量`j`，并且将所有数组引用都转换成了指针间的引用，避免了索引`A[i][j]`要计算乘法`A+L(Ci+j)`的巨大损耗。

对应的汇编代码为

![img](pics/v2-b050bab6298929b6818d2c5e85222ea4_720w.jpg)

#### 3.8.5　变长数组

ISO-C99允许数组的维度为表达式，在数组被分配时才计算出来，例如

```c
int A[exp1][exp2];
```

只要求`exp1`和`exp2`定义在上面那个声明之前。

对比下定长数组和变长数组在索引时汇编代码的区别

- 定长数组

```c
typedef int fix_matrix[5][3];
int fix_ele(fix_matrix A, long i, long j){
  return A[i][j];
}
```

对应的汇编代码为

```text
fix_ele:
  leaq (%rsi, %rsi, 2), %rax    #compute 3i
  leaq (%rdi, %rax, 4), %rax    #compute A+12i
  movl (%rax, %rdx, 4), %eax    #read fomr M[A+12i+4j]
  ret
```

- 变长数组

```c
int var_ele(int n, int A[n][n], long i, long j){
  return A[i][j];
}
```

对应的汇编代码为

```text
var_ele:
  imulq %rdx, %rdi             #compute ni
  leaq  (%rsi, %rdi, 4), %rax  #compute A+4ni
  movl  (%rax, %rcx, 4), %eax  #read from M[A+4ni+4j]
  ret
```

看汇编代码可以发现以下区别：

- 增加了参数n，使得寄存器的使用改变了。
- 用了乘法指令来计算`ni`，而不是用`leaq`来计算`3i`，乘法会导致无法避免的性能损失,因此定长的性能会更好。


### 3.9　异质的数据结构

#### 3.9.1　结构

用`struct`声明创建一个**数据类型**，具有以下特点：

- **定义：**可以将不同类型的对象聚合到一个对象中，并使用名字来引用结构中的各个组成部分。
- **存储：**结构的所有组成部分都存放在内存中一段连续的区域内，指向结构的**指针**是结构第一字节的地址。
- **获得元素：**编译器会维护关于每个结构类型的信息，了解每个字段的偏移量，由此作为内存引用指令的唯一，来对结构元素进行引用。

由此就将4个对象包装到了结构类型`rec`中了，这些对象大小依次为4、4、8和8字节，它的存储是按顺序连续地排列在内存空间中的

![img](pics/v2-28b1202b608edd2413e0a2e37797af5d_720w.png)

我们同样可以声明嵌套的结构体

```c
struct prob{
  int *p;
  struct {
    int x;
    int y;
  }s;
  struct prob *next;
};
```

其在内存中的分布为

![img](pics/v2-6248100e7a248106f9b04961fd3594ef_720w.png)

注意：结构体分配地址空间时，对不同类型的值的起始地址有固定的要求，例如占8个字节的数据类型，起始地址必须是8的倍数，因此如果按顺序排列不满足，就会在前面或者后面插空（为了满足结构体数组，也即是末尾地址要满足下一个结构体首元素的起始地址）直到满足起始地址要求。

#### 3.9.2　联合

用union声明创建一个数据类型，具有以下特点：

- 定义：允许以多种类型来引用一个对象。
- 存储：保存在公共的一块内存中，通过不同对象的类型来赋予这块内存不同的含义。内存大小为最大字段的大小。

![img](pics/v2-3e4853108b0748c61e29d5da70597e29_720w.jpg)

主要具有以下应用情况：

- 如果我们事先知道两个不同字段是互斥的，就能将其定义在一个union中，就能节省内存空间。
- 访问相同位模式下不同数据类型的值。

联合体可以不同的类型共享同样的空间，一般很少用，但例如强制类型转换时，就可以定义联合体以一种类型存储，另一种类型访问。

struct和union的区别：struct为每个对象分配了单独的内存空间，而union分配了共用的内存空间。    
什么时候用union什么时候用struct：当你要信息同时存在时，就需要分配到不同的内存中，就要用struct，否则用union。    

计算struct和union嵌套的数据类型的内存分布：    
- 如果是包裹在struct内的，就按顺序按照对象大小依次排列下来
- 如果是包裹在union内的，就看最大的对象大小，直接分配一块内存就行
