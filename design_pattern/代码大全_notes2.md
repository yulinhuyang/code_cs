# 第三部分 变量

## 第10章 使用变量的一般事项

利用构建活动来填补需求和架构中存在的细小间隙是一种行之有效的做法;但把蓝图设计得精细到已经能完全展现出所有的细节则实在是一种低效的方法
尽量缩小变量的作用域，尽量缩短变量的生存时间 ——Tacey

基础数据类型：见图
 
核对表（使用数据的一般事项）

初始化变量
* 每一个子程序都检查其输入参数的正确性了吗？
* 变量声明位置靠近变量第一次使用的位置吗？
* 尽可能地在声明变量的同时初始化变量了吗？
* 如果无法同时声明和初始化变量，有没有在靠近第一次使用变量的位置声明变量？
* 计数器和累加器经过了适当的初始化了吗？如果需要再一次使用，之前重新初始化了吗？
* 适当的重新初始化“需要重复执行的代码里的变量”了吗？
* 代码在通过编译器编译的时候是不是没有警告信息？（你启用了所有可用的警告选项了吗？）
* 如果你用的语言允许隐式声明，你为此可能引发的问题做好补偿措施了吗？
* 一次性初始化所有具名常量：可用可执行代码初始化之

使用数据的其他事项
* 如果可能，所有变量都被定义为具有最小的作用域了吗？
* 各变量的引用点都尽可能集中在一起了吗？对同一变量的两次相邻引用，或者变量的整个生命周期都这样做了吗？
* 控制结构符合数据类型吗？
* 所有生命的变量都用到了吗？
* 变量都在合适的时间绑定了吗？——也就是说，你有意识地在晚期绑定所带来的灵活性和增加的复杂度之间做出平衡了吗？
* 每个变量都有且仅有一项用途吗？
* 每个变量的含义都很明确且没有隐含含义吗？


要点
* 数据初始化过程很容易出错，使用上面初始化方法来避免由于非预期的初始化值而造成的错误。
* 最小化每个变量的作用域。把同一变量的引用点集中在一起。把变量限定在子程序或类的范围之内。避免使用全局数据。
* 把使用相同变量的语句尽可能集中在一起
* 早起绑定会减低灵活性，但有助于减小复杂度。晚期绑定可以增加灵活性，同时增加复杂度
* 把每个变量用于唯一用途

## 第11章 变量名的力量

为变量取好的名字和高效编程同样重要
变量名要完全、准确地描述出该变量所代表的的事物
变量名的适宜长短和变量的作用域相关，越局部的变量，变量名越短（如循环变量）

常用对仗词： 见图
 
核对表（变量命名）

命名的一般注意事项
* 名字完整并准确地表带了变量所代表的含义吗？
* 名字反映了显示世界的问题而不是编程语言方案吗？
* 名字足够长，可以让你无需苦苦思索吗？
* 如果有计算值限定符，它被放在名字的最后吗？
* 名字中用Count或者Index来代替Num了吗？

为特定类型的数据命名
* 循环下表的名字有意义吗（如果循环的长度超过了一两行代码或者出现了全套循环，那么就应该是i、j或者k以外的其他名字）？
* 所有的“”临时“”变量都重新命以更有意义的名字了吗？
* 当布尔变量的值为真时，变量名能准确表达其含义吗？
* 枚举类型的名字中含有能够表示其类别的前缀和后缀了吗？例如，把Color_用于Clolor_Red、Color_Blue了吗？
* 具名常量是根据它所代表的抽象实体而不是他说代表的数字来命名了吗?

命名规则
* 规则能够区分局部数据、类的数据和全局数据吗？
* 规则能够区分类型名、具名常量、枚举类型和变量名吗？
* 规则能够在编译器不强制检测只读参数的语言里标识出子程序中的输入参数吗？
* 规则尽可能的与语言的标准规则兼容吗？
* 名字为了可读性而加以格式化吗？

短名字
* 代码用了长名字吗（除非有必要使用短名字）？
* 是否避免只为了省一个字符而缩写名字的情况？
* 所有单词的缩写方式都一致吗？
* 名字能够读出来吗？
* 避免使用容易被看错或者读错的名字吗？
* 在缩写对照表里对短名字做出说明吗？

常见命名问题：你应该避免使用：
* 容易让人误解的名字
* 有相近含义的名字
* 只有一两个字符不同的名字
* 发音相近的名字
* 包含数字的名字
* 为了缩短而故意拼错的名字
* 英语中经常拼错的名字吗
* 与标准库子程序名或者预定义变量名冲突的名字
* 过于随意的名字
* 含有难读的字符的名字
要点
* 好的变量名是提高程序可读性的一项关键要素。对特殊种类的变量，比如循环下表和状态变量，需要加以特殊的考虑
* 名字要尽可能的具体。那些台模糊或者太通用以至于能够用于多种目的的名字通常都是很不好的
* 命名规则应该能够区分局部数据、类数据和全局数据。他们还应该可以区分类型名、具名常量、枚举类型名字和变量名。
* 无论哪种类型项目，你都应该采用某种变量命名规则。你所采用的规则的种类取决于你的程序的规模，以及项目成员的人数。
* 现代编程语言很少需要用到缩写。如果你真的要是用缩写，请使用项目缩写词典或者标准前缀来帮助理解缩写
* 代码阅读的次数远远多于编写的次数。确保你所取得名字更侧重于阅读方便而不是编写方便

##第12章  基本数据类型

核对表：基本数据类型

数值概论
* 代码中避免使用神秘数值
* 代码考虑了除零错误了吗？
* 类型转换很明显吗？
* 如果在一条语句中存在两个不同类型的变量，那么这条语句会想你期望的那样求值吗？
* 代码避免了混合类型比较吗？
* 程序编译时没有警告信息吗？

整数
* 使用整数除法的表达式能按预期的那样工作吗？
* 整数表达式避免整数溢出问题吗？

浮点数
* 代码避免了对数量级相差巨大的数字做加减运算吗？
* 代码系统地阻止了舍入错误的发生吗？
* 代码避免对对浮点数做灯亮比较吗？

字符和字符串
* 代码避免使用神秘字符串和神秘字符了吗？
* 使用字符串时避免了off-by-one错误了吗？
* C代码吧字符串指针和字符数组区别对待了吗？
* C代码遵循了把字符串声明为CONTANT+1长度了吗？
* C代码在适当的时候用字符数组来代替指针了吗？
* C代码吧字符串初始化为NULL来避免无终端的字符串了吗？
* C代码用strncpy()代替strcpy()吗？strncat()和strncmp()呢？

布尔变量
* 程序用额外的布尔变量来说明条件判断了吗？
* 程序用额外的布尔变量来简化条件判断了吗？

枚举类型
* 程序用枚举类型而非具名常量来提高可读性、可靠性、和可修改性了吗？
* 当变量的用法不能仅用true和false表示的时候，程序用枚举类型取代布尔变量吗？
* 针对枚举类型的测试检测了非法数值吗？
* 把枚举类型的第一项条目保留为“非法“了吗？

具名常量
* 程序用具名常量而不是神秘数值来声明数据和表示循环界限了吗？
* 具名常量的使用一致吗？——没有在有些位置使用具名常量又在其它位置使用文字量？

数组
* 所有的数组下标都没有超出数组边界吗?
* 数组引用没有出现off-by-one错误吗？
* 所有多维数组的下标的顺序都正确吗？
* 在嵌套循环里，把正确的变量用于数组下标来避免循环下标串话了吗？

创建类型
* 程序对每一种可能变化的数据分别采用不同的类型吗？
* 类型名是以该类型所表示的显示世界实体为导向，而不是以编程语言类型为导向吗？
* 类型名的描述性足以强，可以帮助解释数据声明吗？
* 你避免重新定义预定义类型吗？
* 与简单的重定义一个类型相比，你考虑过创建一个新类吗?

要点
* 使用特定的数据类型就意味着要记住适用于各个类型的很多独立的原则。用本章的核对表来确认你已经对常见问题做了考虑。
* 如果你的语言支持，创建自定义类型会使得你的程序更容易修改，并更具有自描述性
* 当你用typedef或者其等价方式创建了一个简单类型的时候，考虑是否更应该创建一个新的类


## 第13章  不常见的数据类型


只有万不得已时才使用全局数据
！！！就近原则！！！注释紧随代码，变量紧随使用它们的地方 ——Tacey

访问器子程序的优势
* 你获得了对数据的集中控制
* 你可以确保对变量的所有引用都得到了保护
* 自动获取信息隐藏的普遍益处
* 访问器子程序可以很容易转变为抽象数据类型

**如何使用访问器子程序**
* 要求所有的代码通过访问器子程序来存储数据：比如，所有全局以g_开头，除了访问器，其他代码都不得访问
* 不要把所有的全局数据都扔在一处：尽量把全局数据和访问器子程序打包到适合的类里面
* 用锁定来控制对全局变量的访问：锁定要求使用或者更新一个全局变量值之前，该变量必须被签出，完成使用之后再签入。（加锁）
* 在访问器子程序里构建一个抽象层
* 对一项数据的所有访问都应该在同一个层次上（操作一致性）

降低全局数据的风险：
* 创建一种命名规则来突出全局变量
* 为全部的全局变量创建一份注释良好的清单
* 不要用全局变量来存放中间结果
* 不要把所有的数据都放在一个大对象中并导出传递，以说明你没有使用全局变量

核对表（使用不常见数据类型的注意事项）

结构体
* 你使用结构体而不是使用单纯的变量来组织和操作相关的数据吗？
* 你考虑创建一个类来代替使用结构体吗？

**全局数据**
* 所有的变量是否都是局部的或者是类范围的？除非绝对必要才是全局的？
* 变量的命名规则能把局部数据、类数据和全局数据区分开吗？
* 你对所有的全局变量都加以文档说明吗？
* 避免使用伪全局数据，即被四处传递且包含有杂乱数据的巨大对象吗？
* 用访问子程序来取代全局数据吗？
* 把访问子程序和数据组织到类里面吗？
* 访问器子程序提供了一个在底层数据类型实现之上的抽象层吗？
* 所有相关的访问器子程序都位于同一抽象层吗？

**指针**
* 把指针操作隔离在子程序里吗？
* 指针引用合法吗？或者说指针有可能成为空悬指针吗？
* 代码在使用指针之前检查他的有效性吗？
* 在使用指针所指向的变量之前检查其有效性吗？
* 指针用完后被设置为空值吗？
* 就可读性而言，代码用了所有需要使用的指针变量吗？
* 链表中的指针是按正确的顺序加以释放吗？
* 程序分配了一片保留的内存后备区域，一遍在耗尽内存的时候能够优雅地退出吗？
* 是不是在没有其他方法可用的情况下最终才使用指针的？

**要点**
* 结构体可以使得程序更简单、更容易理解，以及更容易维护
* 每当你打算使用结构体的时候，考虑采用类是不是会工作的更好。
* 指针很容易出错。用访问子程序或类以及防御式编程实践来保护自己的代码。
* 避免使用全局变量，不只是因为它们危险，还是因为你可以用其他更好的方法取代它们。
* 如果你不得不使用全局变量，那么就通过访问子程序来使用它。访问器子程序能为你带来全局变量所能带来的一切优点，还有一些额外的好处。


# 第四部分：语句

## 第14章：组织直线型代码

核对表（组织直线型代码）
* 代码使得语句之间的依赖关系变得明显吗？（顺序相关型）
* 子程序的名字使得依赖关系变得明显吗？
* 子程序的参数使得依赖关系变得明显吗？
* 如果依赖关系不明确，你是否用注释进行了说明？
* 你用“内务管理变量”来检查代码中关键位置的顺序依赖关系了吗？
* 代码容易按照自上而下的顺序阅读吗？
* 相关的语句被组织在一起吗？
* 把相对d独立的语句组放进各自的子程序里吗？
要点
* 组织直线型代码的最主要原则是按照依赖关系进行排列
* 可以用好的子程序名、参数列表、注释以及——如果代码足够重要——内务管理变量来让依赖关系变得更明显。
* 如果代码之间没有顺序依赖关系，那就设法使相关的语句尽可能接近。

## 第15章：使用条件语句

核对表（使用条件语句）
if-then 语句
* 代码的正常路径清晰吗？
* if-then测试对等量分支的处理方式正确吗？
* 使用了else字句并加以说明吗？
* else字句用的对吗？
* 用对了if和else子句，即没把他们用反？
* 需要执行的正常情况是位于if而不是else子句里吗？

if-then-else-if子句
* 把复杂的判断封装到布尔函数调用里了吗？
* 先判断最常见的情况了吗？
* 判断包含所有的情况吗？
* if-then-else-if是最佳实现吗？比case语句还要好吗？

case语句
* case子句排序得有意义吗？
* 每种情况的操作简单吗？必要的时候调用了其他子程序吗？
* case语句检测的时一个真实的变量，而不是一个只为了滥用case语句而刻意制造变量吗？
* 默认子句用得合法吗？
* 用默认子句来检测和报告意料之外的情况了吗？
* 在C、C++或者Java里，每一个case的末尾都有一个break吗？

要点
* 对于简单的if-else语句，请注意if子句和else子句的顺序，特别是用它来处理大量错误的时候。要确认正常的情况是清晰的。
* 对于if-then-else语句串和case语句，选择一种最利于阅读的排序
* 为了捕捉错误，可以使用case语句中的default子句（默认子句），或者使用if-then-else语句串中的最后那个else子句
* 各种控制结构并不是生来平等的。请为代码的每个部分选用最合适的控制结构
------》表驱动

## 第16章：控制循环

核对表（循环）

循环的选择和创建
* 在核实的情况下用while循环取代for循环了吗？
* 循环是由内到外创建的吗？

进行入循环
* 是从循环头部进入的循环吗？
* 初始化代码是否直接位于循环前面吗？
* 循环是无限循环或者事件循环吗？它的结构是否清晰？
* 避免使用像for i=1 通9999这样的代码？
* 如果这是一个C+_+、C或者Java中的for循环，那么循环头留给循环控制代码了吗？

循环的内部
* 循环是否用了"()"或其等价物来括上循环体，以防止因修改不当而出错吗？
* 循环体内有内容吗？他是非空的吗?
* 把内务处理集中地放在循环开始或者循环结束处了吗？
* 循环像定义良好的子程序那样只执行了一件操作吗？
* 循环短得足以一目了然？
* 循环的潜逃层次不多于3层吗？
* 把长循环的内容提取成单独的子程序吗？
* 如果循环很长，那么它非常清晰吗？

循环下标
* 如果这是一个for循环，那么其中的代码有没有随意修改循环下标值？
* 是否把重要的循环下标值保存在另外的变量里，而不是在循环体外使用该循环下标？
* 循环下标是序数类型（整数）或者枚举类型——而不是浮点类型吗？
* 循环下标的名字有意义吗？
* 循环避免了下标串话问题吗？

退出循环
* 循环在所有可能的条件下都能终止吗？
* 如果建立了某种安全计数器标准，循环使用安全计数器了吗？
* 循环的退出条件清晰吗？
* 如果使用了break或者continue，那么他们用对了吗?

要点
* 循环很复杂，保持循环简单讲有助于别人阅读你的代码
* 保持循环简单的技巧包括：避免使用怪异的循环、减少嵌套层次、让入口和出口一目了然，把内务操作代码放在一起
* 循环下标很容易被滥用。因此命名要准确，并且要把它们各自仅用于一个用途
* 仔细地考虑循环，确认他在每一种情况下都能运行正常，并且在所有可能的条件下都能退出


## 第17章：不常见的控制结构

核对表（不常见的控制结构）
return
* 每一个子程序都尽在有必要的时候才使用return吗？
* 使用return有助于增强可读性吗？

递归
* 递归子程序中包含了停止递归的代码吗？
* 子程序用安全计数器来确保子程序能停下来吗？
* 递归只位于一个子程序里面吗？
* 子程序的递归深度处于程序栈容量可以满足的限度内吗？
* 递归是实现子程序的最佳方法吗？他要浩宇简单的迭代吗？

goto
是否只有在万不得已的时候才是用goto？如果用了goto，是否仅仅是出于增强可读性和可维护性？
* 如果出于效率因素而是用的goto，那么对这种效率上的提升做出衡量并加以说明了吗？
* 一个子程序里最多只用了一个goto标号吗？
* 所有的goto都向前跳转而不是向后跳转吗？
* 所有的goto标号都用到了吗？

要点
* 多个return可以增强子程序的可读性和可维护性，同时可以避免产生很深的嵌套逻辑。但使用它的时候要多加小心。
* 递归能够很优雅的解决一小部分问题。对他的使用要倍加小心。
* 在少数情况下，goto是编写可读性和可维护性代码的最佳方法。但这种情况非常罕见。除非万不得已，不要使用goto

## 第18章：表驱动法

表驱动法是一种编程模式（scheme）——从表里面查找信息而不使用逻辑语句（if、case）。事实上，凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。在适当的情况下，采用表驱动法会比复杂的逻辑代码更简单、更容易修改，而且效率更高。
表驱动法必须要解决的两个问题：

1、如何从表中查询条目：
* 直接访问
* 索引访问
* 阶梯访问

2、表里应该存什么：
* data
* action/action ref

灵活的消息格式：metadata+core logic code based on config

核对表（表驱动法）

* 你考虑过把表驱动法作为复杂逻辑的替换方案吗？
* 你考虑过把表驱动法作为复杂继承结构的替换方案吗？
* 你考虑过把表数据存储在外部并在运行期间读入，以便在不修改代码的情况下就可以改变这些数据吗？
* 如果无法用一种简单的数组索引去访问表，那么你把计算访问键值的功能提取成单独的子程序，而不是在代码中重复地计算键值吗？

要点
* 表提供了一种复杂的逻辑和继承结构的替换方案。如果你发现自己对某个应用程序的逻辑或者继承树关系感到困惑，那么问问自己它是否可以通过一个查询表来加以优化
* 使用表的两大关键决策：1、如何访问表；2、表中存放什么
--》状态机

## 第19章：一般控制问题

布尔：除了最简单、要求语句按照顺序执行的控制结构之外，所有的控制结构都依赖于布尔表达式的求值

见图

**嵌套**

减少嵌套层次的技术列表：
* 重复判断一部分条件
* 转换成if-then-else
* 转换成case语句
* 把深层嵌套的代码提取城单独的子程序
* 使用对象和多态派分
* 用状态变量重写代码
* 用防卫子句来退出程序，从而使得代码的主要路径更为清晰
* 使用异常
* 完全重新设计深层嵌套的代码

**结构化编程**

结构化编程的核心思想：一个应用程序应该单一入口、单一出口。

其中涉及到的关键词有：break,continue、throw、catch、return

结构化编程的三个组成部分：顺序、选择、迭代

复杂度
 
核对表（控制结构相关事宜）

* 表达式中用的时true和false而不是1、0吗？
* 布尔值和true以及false作比较是隐式进行的吗？
* 对数值作比较是显示进行的吗？
* 有没有通过增加新的布尔变量、使用布尔函数和决策表来简化表达式？
* 布尔表达式是肯定形式表达的吗？
* 括号匹配吗？
* 在需要用括号来明确的地方都是用了括号了吗？
* 把逻辑表达式全括起来了吗？
* 判断是按照数轴顺序编写的吗？
* 如果适当的话。Java中的判断用的时a.equals(b)方式，而不是用a==b方式？
* 空语句表述的明显吗？
* 用重新判断部分条件、转换成if-then-else或case语句、或把嵌套代码独立成单独子程序、换用一种更面向对象的设计或者其他改进方法来简化嵌套语句？
* 如果一个子程序的决策点超过10个，那么能提出不重新设计的理由吗？

要点

* 使布尔表达式简单可读，将非常有助于提高你的代码质量
* 深层次的嵌套使得子程序变得难以理解。所幸的时，你可以相对容易的避免这么做
* 结构化编程是一种简单并且仍然适用的思想：你可以通过把顺序、选择和循环三者组合起来而开发任何程序
* 将复杂度降低到最低水平是编写高质量代码的关键

 







