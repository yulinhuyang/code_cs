**第1章　整洁代码**　

1.1　要有代码　

1.2　糟糕的代码　

1.3　混乱的代价　

1.3.1　华丽新设计　

1.3.2　态度　

1.3.3　迷题　

1.3.4　整洁代码的艺术　

1.3.5　什么是整洁代码　

1.4　思想流派　

1.5　我们是作者　

1.6　童子军军规　

1.7　前传与原则　

1.8　小结　

1.9　文献　

**第2章　有意义的命名**　

2.1　介绍　

2.2　名副其实　

2.3　避免误导　

2.4　做有意义的区分　

2.5　使用读得出来的名称　

2.6　使用可搜索的名称　　

2.7　避免使用编码　

2.7.1　匈牙利语标记法　

2.7.2　成员前缀　

2.7.3　接口和实现　

2.8　避免思维映射　

2.9　 类名　

2.10　方法名　

2.11　别扮可爱　

2.12　每个概念对应一个词　

2.13　别用双关语　

2.14　使用解决方案领域名称　

2.15　使用源自所涉问题领域的名称　

2.16　添加有意义的语境　

2.17　不要添加没用的语境　

2.18　最后的话　

**第3章　函数**　

3.1　短小　

3.2　只做一件事　

3.3　每个函数一个抽象层级　

3.4　switch语句　

3.5　使用描述性的名称　

3.6　函数参数　

3.6.1　一元函数的普遍形式　

3.6.2　标识参数　

3.6.3　二元函数　

3.6.4　三元函数　

3.6.5　参数对象　

3.6.6　参数列表　

3.6.7　动词与关键字　

3.7　无副作用　

3.8　分隔指令与询问　

3.9　使用异常替代返回错误码　　

3.9.1　抽离Try/Catch代码块　

3.9.2　错误处理就是一件事　

3.9.3　Error.java依赖磁铁　

3.10　别重复自己　

3.11　结构化编程　

3.12　如何写出这样的函数　

3.13　小结　

3.14　SetupTeardownIncluder程序　　

3.15　文献　

**第4章　注释**　

4.1　注释不能美化糟糕的代码　

4.2　用代码来阐述　

4.3　好注释　

4.3.1　法律信息　

4.3.2　提供信息的注释　

4.3.3　对意图的解释　

4.3.4　阐释　　

4.3.5　警示　

4.3.6　TODO注释　

4.3.7　放大　

4.3.8　公共API中的Javadoc　

4.4　坏注释　

4.4.1　喃喃自语　

4.4.2　多余的注释　

4.4.3　误导性注释　

4.4.4　循规式注释　

4.4.5　日志式注释　　

4.4.6　废话注释　

4.4.7　可怕的废话　

4.4.8　能用函数或变量时就别用注释　

4.4.9　位置标记　

4.4.10　括号后面的注释　

4.4.11　归属与署名　

4.4.12　注释掉的代码　

4.4.13　HTML注释　

4.4.14　非本地信息

4.4.15　信息过多　

4.4.16　不明显的联系　

4.4.17　函数头　

4.4.18　非公共代码中的Javadoc　

4.4.19　范例　

4.5　文献　

**第5章　格式**　

5.1　格式的目的　

5.2　垂直格式　

5.2.1　向报纸学习　

5.2.2　概念间垂直方向上的区隔　　

5.2.3　垂直方向上的靠近

5.2.4　垂直距离

5.2.5　垂直顺序

5.3　横向格式　

5.3.1　水平方向上的区隔与靠近

5.3.2　水平对齐　

5.3.3　缩进　

5.3.4　空范围　

5.4　团队规则　

5.5　鲍勃大叔的格式规则　

**第6章　对象和数据结构**　

6.1　数据抽象　

6.2　数据、对象的反对称性　

6.3　得墨忒耳律　

6.3.1　火车失事　

6.3.2　混杂　

6.3.3　隐藏结构　

6.4　数据传送对象　

6.5　小结　

**第7章　错误处理**　

7.1　使用异常而非返回码　

7.2　先写Try-Catch-Finally语句　

7.3　使用不可控异常　

7.4　给出异常发生的环境说明　

7.5　依调用者需要定义异常类　

7.6　定义常规流程　

7.7　别返回null值　

7.8　别传递null值　

7.9　小结　　

7.10 文献　

**第8章　边界**　

8.1　使用第三方代码　

8.2　浏览和学习边界　

8.3　学习log4j　

8.4　学习性测试的好处不只是免费　

8.5　使用尚不存在的代码　

8.6　整洁的边界　

8.7　文献　

**第9章　单元测试**　

9.1　TDD三定律　　

9.2　保持测试整洁　

9.3　整洁的测试　

9.3.1　面向特定领域的测试语言　

9.3.2　双重标准　

9.4　每个测试一个断言　

9.5　F.I.R.S.T

9.6　小结　

9.7　文献　

**第10章　类**　

10.1　类的组织　

10.2　类应该短小　

10.2.1　单一权责原则　

10.2.2　内聚　

10.2.3　保持内聚性就会得到许多短小的类　

10.3　为了修改而组织　

10.4　文献　

**第11章　系统**　

11.1　如何建造一个城市　

11.2　将系统的构造与使用分开　

11.2.1　分解main　

11.2.2　工厂　

11.2.3　依赖注入　

11.3　扩容　

11.4　Java代理　

11.5　纯Java AOP框架　

11.6　AspectJ的方面　

11.7　测试驱动系统架构　　

11.8　优化决策　

11.9　明智使用添加了可论证价值的标准　

11.10 系统需要领域特定语言　

11.11 小结　

11.12 文献　

**第12章　迭进**　

12.1　通过迭进设计达到整洁目的　

12.2　简单设计规则1：运行所有测试　　

12.3　简单设计规则2～4：重构　

12.4　不可重复　

12.5　表达力　

12.6　尽可能少的类和方法　

12.7　小结　

12.8　文献　

**第13章　并发编程**　

13.1　为什么要并发　　

13.2　挑战　

13.3　并发防御原则　

13.3.1　单一权责原则　

13.3.2　推论：限制数据作用域　

13.3.3　推论：使用数据复本　

13.3.4　推论：线程应尽可能地独立　

13.4　了解Java库　

13.5　了解执行模型　

13.5.1　生产者-消费者模型　　

13.5.2　读者-作者模型　

13.5.3　宴席哲学家　

13.6　警惕同步方法之间的依赖　

13.7　保持同步区域微小　

13.8　很难编写正确的关闭代码　

13.9　测试线程代码　

13.9.1　将伪失败看作可能的线程问题　

13.9.2　先使非线程代码可工作　

13.9.3　编写可插拔的线程代码　

13.9.4　编写可调整的线程代码　

13.9.5　运行多于处理器数量的线程　　

13.9.6　在不同平台上运行　

13.9.7　装置试错代码　

13.9.8　硬编码　

13.9.9　自动化　

13.10　小结　

13.11　文献　

**第14章　逐步改进**　

14.1　Args的实现　　

14.2　Args：草稿　

14.2.1　所以我暂停了　

14.2.2　渐进　

14.3　字符串参数　

14.4　小结　

**第15章　JUnit内幕**　

15.1　JUnit框架　

15.2　小结　　

**第16章　重构SerialDate**　

16.1　首先，让它能工作　

16.2　让它做对　

16.3　小结　

16.4　文献　

**第17章　味道与启发**　

17.1　注释　

17.2　环境　

17.3　函数　

17.4　一般性问题　

17.5　Java　　

17.6　名称　

17.7　测试　

17.8　小结　

17.9　文献　

附录A　并发编程II　

A.1　客户端/服务器的例子　

A.1.1　服务器　

A.1.2　添加线程代码　　

A.1.3　观察服务器端　

A.1.4　小结　

A.2　执行的可能路径　

A.2.1　路径数量　

A.2.2　深入挖掘　

A.2.3　小结　

A.3　了解类库　

A.3.1　Executor框架　

A.3.2　非锁定的解决方案　

A.3.3　非线程安全类　

A.4　方法之间的依赖可能破坏并发代码　　

A.4.1　容忍错误　

A.4.2　基于客户代码的锁定　

A.4.3　基于服务端的锁定　

A.5　提升吞吐量　

A.5.1　单线程条件下的吞吐量　

A.5.2　多线程条件下的吞吐量　

A.6　死锁　

A.6.1　互斥　

A.6.2　上锁及等待　

A.6.3　无抢先机制　

A.6.4　循环等待　

A.6.5　不互斥　

A.6.6　不上锁及等待　

A.6.7　满足抢先机制　

A.6.8　不做循环等待　

A.7　测试多线程代码　

A.8　测试线程代码的工具支持　

A.9　小结　

A.10 教程：完整代码范例　

A.10.1　客户端/服务器非线程代码　

A.10.2　使用线程的客户端/服务器代码　


