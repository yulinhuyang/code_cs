# 第五部分：代码改善

## 第20章：软件质量概述

**软件质量特性：**

* 外
* 正确性
* 可用性
* 效率
* 可靠性
* 完整性
* 适应性
* 精确性
* 健壮性

* 内
* 可维护性
* 灵活性
* 可移植性
* 可重用性
* 可读性
* 可测试
* 可理解性

见图
 
提高生产效率和改善质量的最佳途径就是减少花在这种代码返工上的时间，无论返工的代码时由需求、设计改变还是调试引起的。

核对表（质量保证计划）
* 是否确定出对于项目至关重要的特定质量特性了？
* 是否让其他人意识到项目的质量目标了？
* 是否能够区分质量的外在特性和内在特性
* 是否考虑过某些特性在与其他特性相互制约或者相互促进的具体方式？
* 在软件开发的每一个阶段，项目是否要求针对不同错误类型使用不同的错误检测技术
* 项目计划中是否有计划有步骤的保证了软件在开发各阶段的质量？
* 是否使用了某种质量评估方法，并由此确定质量是改善了还是下降了？
* 管理层是否能理解为了质量保证在前期消耗额外成本，目的就是在项目后期减少成本？

要点
* 开发高质量代码最终并没有要求你付出更多，只是你需要对资源进行重新分配，以地梁的成本来防止缺陷发生，从而避免代价高昂的修正工作
* 并非所有的质量保证目标都可以全部实现。明确哪些目标是你希望达到的，并就这些目标和团队成员进行沟通。
* 没有任何一种错误检测方法能够解决全部问题，测试本身并不是排除错误的最有效方法。成功的质量保证计划应该使用多种不同的技术来检查各种不同类型的错误
* 在构建期间应该使用一些有效的质量保证技术，但在这之前，一些具有同样强大功能的质量保证技术也是必不可少的。错误发现的越早，它与其他代码的纠缠就越少，由此造成的损失也越小
* 软件领域的质量保证是面向过程的。软件开发与制造业一样，在这里并不存在会影响最终产品的重复阶段，因此，最终产品的重量所受到开发软件所用的过程控制。

## 第21章：协同构建


-》结对编程
-》 正式检查
结对编程
成功运用结对编程的关键：
* 用编码规范来支持结对编程
* 不要让结对编程编程旁观
* 不要强迫在简单的问题上使用结对编程
* 有规律的对结对人员和分配的工作任务进行轮换
* 鼓励双方跟上对方的步伐
* 确认两个人都能够看到显示器
* 不要强迫程序员与自己关系紧张的人组队
* 避免新手组合，两人之间至少有一个有结对编程的经历
* 指定一个组长

结对编程的好处：
* 能够使人在压力之下保持更好的状态
* 能够改善代码质量
* 缩短进度时间表
* 指导初级程序员，培养集体归属感

核对表（有效的结对编程）
* 是否已经有一个编码规范，以便让程序员始终把经历集中在编程，而不是编码风格的讨论上
* 结对双方是否都积极参与
* 是否避免了滥用结对编程，而是选择那些能够从中获得好处的工作进行结对编程
* 是否有规律的对人员和工作任务进行轮换
* 结对编程是否在开发速度和个性方面互相匹配
* 是否有一个组长专注于项目管理以及与项目外其他人沟通

正式检查

核查表（有效的详查）
* 你是否有一个核对表，能让评论员将注意力集中于曾经发生过的问题的领域
* 你是否专注于找出错误，而不是修正他们？
* 你是否考虑制定某些视角或者场景，以帮助评论员在准备工作的时候集中注意力
* 你是否给与评论员足够的时间在详查会议之前进行准备，是否每一个人都做了准备
* 是否每一个参与者都扮演一个明确的角色——主持人、评论员以及记录员等
* 会议是否以某种高校的速度进行？
* 会议是否限制在两个小时以内
* 是否所有的详查会议的参与者都接受了如何进行详查的针对性培训，是否主持人接受了有关主持技巧方面的针对性培训？
* 是否将每次详查所发现的错误数据都收集起来，使你能调查本组织以后使用的核对表
* 是否收集了准备速度和详查速度方面的数据，以便你去优化以后的准备和详查工作
* 是否每次详查中都被指派下去的活动都被正确的跟进了，无论是通过主持人自己还是一次重新详查
* 管理层是否理解他们不应该参与详查会议
* 是否有一个用于保证修正正确性的跟进计划

要点
* 协同开发实践往往能比测试发现更多的缺陷，并且更有效率
* 协同开发实践所发现错误的类型通常跟测试所发现的不同，这意味着你需要同时使用详查和测试来保证你软件的质量
* 正式检查通过运用核对表、准备工作、明确定义角色以及对方法的持续改善，将缺陷侦测的相率提升至最高。他往往能比走查发现更多的缺陷
* 通常，结对编程拥有和详查相同的成本，并能产生质量相当的代码。当需要缩短开发周期的时候，结对编程就非常有价值。相对于单独工作而说，有些开发人员更喜欢结对工作
* 正式检查可以应用在除代码之外的很多工作成果上，例如需求、设计以及测试用例等等。
* 走查和代码阅读是详查的替代方案。代码阅读更富有弹性，能有效地利用每个人的时间

## 第22章：开发者测试

自动化测试：http://robotframework.org/
HTTP接口测试：POSTMAN

测试：
* 单元测试（unit testing）
* 组件测试 （component tetsing）
* 集成测试 （integration testing）
* 回归测试 （regression Testing）：重复执行以前的测试用例
* 系统测试 （System testing）：终！

两大类：
* 黑盒
* 白盒：开发者关注
错误类型：
 
核对表（测试用例）
* 类和子程序所对应的的每一项需求是否都有相应的测试用例
* 类和子程序所对应的每一个设计元素是否都有相应的测试用例？
* 每行代码是否被至少一个测试用例所测试？你是否通过计算测试到每行代码所需的最少测试用例数量来验证这一点
* 所有已定义-已使用路径是否至少被一个测试用例测试过了？
* 是否测试过那些不太可能正确的数据流模式，例如已定义--已定义、已定义-已退出以及已定义-已销毁？
* 是否有一张常见错误列表，并据此编写测试用例以检测过去经常出现的错误？
* 所有的简单便捷是否已经测试过了：最大、最小以及off-one
* 是否测试了组合便捷——即，多个输入数据的组合导致输出数据过小或者过大
* 测试用例是否检查了数据类型错误，例如一个薪水记账程序里的雇员数量是负数
* 是否测试了那些中规中矩的典型数值
* 是否测试了最小正常形式
* 是否测试了最大正常形式
* 是否检查了与旧数据的兼容性？以及是否对旧硬件、旧操作系统版本以及其他旧版软件的接口进行了测试
* 测试用例是否容易手工检验？
要点
* 开发人员测试是完整测试策略的一个关键部分。独立测试也很重要
* 同编码之后写测试用例相比较，编码开始之前编写测试用例,工作量和花费的时间差不多，但是后者可以缩短缺陷-侦测-调试-修正这一周期
* 及时考虑到了各种可用的测试手段，测试仍然只是良好软件质量计划的一部分。高质量的开发方法至少和测试一样重要，这包括尽可能减少需求和设计阶段的缺陷。在检测错误方面，协同开发的成效至少与测试相当。这些方法所检测错误的类型也各不相同
* 你可以根据各种不同的思路来产生很多测试用例，这些思路包括基础测试、数据流分析、便捷分析、错误数据类型以及正确数据类型等。你还可以通过猜测错误的方式得到更多的测试用例。
* 错误往往集中在少数几个容易出错的类和子程序上。找出这部分代码，重新设计和编写他们。
* 测试数据本身出错的密度往往比被测试的代码还高。查找这种错误完全是浪费时间，又不能对代码有所改善，因此测试数据里面的错误更加让人烦恼。要像修改代码一样小心地开发测试用例，这样才能避免产生这种问题。
* 自动化测试总体来说是有用的，也是进行回归测试的基础
* 从长远来看，改善测试过程的最好办法就是将其规范化，并对其进行评估，然后用从评估中获得的经验来改善这个过程。

## 第23章：调试

泛调试步骤：
* 通过可重复的实验搜集数据
* 根据相关数据的统计构造一个假说
* 设计一个实验来验证或者反证这个假说
* 证明或者反证假说
* 根据需要重复进行上面的步骤

寻找缺陷的有效方法：
* 将错误状态稳定下来
* 确定错误的来源
* 收集产生缺陷的相关数据
* 分析所搜集的数据，并构造对缺陷的假设
* 确定怎样去证实或证伪这个假设，可以对程序进行测试或是通过代码
* 按照2确定的方法对假设做出最终结论
* 修补缺陷
* 对所修补的地方进行测试
* 查找是否还有类似的错误

核对表（关于调试的建议）
寻找缺陷的方法
* 使用所有可用数据来构造你的假设
* 不断提炼产生错误的测试用例
* 在自己的单元测试suit中测试代码
* 借助可以获得的任何工具
* 用不同的方式重现错误
* 通过产生更多的数据来构造更多的假设
* 利用证伪假设的测试结果
* 用头脑风暴的方式找出可能的假设
* 在桌上放一个笔记本，把需要尝试的事情列出来
* 缩小被怀疑有问题的代码区域
* 对之前出现问题的类和子程序保持警惕
* 检查最近修改的代码
* 扩展被怀疑有问题的代码区域
* 采用增量集成
* 检查常见的缺陷
* 和其他人一起讨论你的问题
* 抛开问题休息一下
* 在使用快速安葬调试法的时候，要设置一个时间上限
* 列出所有的蛮力调试方法，逐条应用

解决语法错误的方法
* 不要太信任编译器信息中给出的行号
* 不要太信任编译器信息
* 不要太信任编译器所给出的第二条出错信息
* 分而治之，各个击破
* 使用具有语法分析功能的编辑器来找出位置错误的注释和引号

修正缺陷的方法
* 在动手之前先理解程序
* 理解整个程序而非具体问题
* 验证对错误的分析
* 放松一下
* 要保存最初的源代码
* 治本，而非治标
* 只有当理由充分地时候才去修改代码
* 一次只做一个动作
* 检查自己所做的修订
* 添加单元测试来暴露代价中的缺陷
* 找出类似的缺陷

调试的一般方法
* 你是否会把调试看做是能让你更好的理解程序、错误、代码质量和解决问题方法的良机
* 你是否会避免采用随机尝试查找错误或迷信式的调试方法
* 你是否假设错误是你自己造成的
* 你是否使用了科学的方法将间歇性的错误稳定下来？
* 你是否使用了科学的方法来寻找缺陷
* 你在寻找缺陷的时候会使用多种不同的方法吗？还是每次都是用相同的方法？
* 你会验证你的修改是否正确吗？
* 你会在调试中使用编译器警告信息、执行性能分析、利用测试框架和交互式调试方法吗？

要点
* 调试同整个软件开发的成败息息相关。最好的解决之道是使用科学的方法来避免缺陷的产生。然而，花点时间来提高自己的调试技能还是很划算的，因为优秀和拙劣的调试表现之间的差距至少是10:1
* 要想成功，系统化的查找和改正错误的方法直观重要。要专注于你的调试工作，让每一次测试都能让你朝着正确的方向前进一步。要是用科学的调试方法。
* 在动手解决问题之前，要理解问题的根本。胡乱猜测错误的来源和随机修改将会让你的程序陷入比刚开始调试时更糟糕的境地
* 将编译器警告级别设置为最严格，把警告信息所报告的错误都改正。如果你忽略了明显的错误，那么要改正那些微妙的错误就会非常麻烦
* 调试工具对软件开发而言是强有力的支持手段。找出这些工具并加以应用，当然，请记得在调试的时候开动脑筋。

## 第24章 重构

神话：一个管理很完善的软件项目，应该首先以系统化的方法进行需求开发，
定义一份严谨的列表来描述程序的功能。设计完全遵循需求，并且完成得相当仔
细，这样就让程序员的代码编写工作能够从头至尾饩线型地工作。这也表明绝大
多数代码117欠编写后就己完美，测试通过即可被抛到脑后。如果这样的神话是真
的，那么代码被修改的唯一时机就是在软件维护阶段，而这一阶段只会在系统的
最初版本交付用户之后。
现实情况：在初始开发阶段，代码会有实质性的进化。在初始的代码编写过
程中，就会出现很多剧烈的改变，如同在代码维护阶段可以看到的那样。根据项
目的规模不同，典型的项目花在编码、调试和单元测试上的时间会占到整个项目
的30%到65%不等〔请阅第27章“程序规模对构建的影响”〕。如果代码编写和
单元测试能够一帆风顺，这两个阶段所占整个项目时间的比例不会超过20%到30%。即
使是管理完善的项目，每个月都有大约1/4的需求发生变化。需求的变
化将不可避免地导致相关代码的改变一釘时是实质性的代码改变。

核对表（重构的理由）
* 代码重复
* 子程序太长
* 循环太长或者嵌套太深
* 类的内聚性太差
* 类的接口和抽象层次不一致
* 参数表中的参数太多
* 类的内部修改往往局限于某个部分
* 需要对多个类进行并行修改
* 对继承体系的并行修改
* 需要对多个case语句进行并行修改
* 相关的数据项只是被放在一起，没组织到类中
* 成员函数更多的使用了其他类的功能，而非自身类的
* 过于依赖基本数据类型
* 一个类不做什么事
* 一连串传递流浪数据的子程序
* 中间人对象什么也不干
* 某个类同其他类关系过于密切
* 子程序的命名太差
* 数据成员被设置为公用
* 派生类仅仅使用了基类的一小部分成员函数
* 用注释来掩饰拙劣的代码
* 使用了全局变量
* 在子程序调用前使用设置代码，调用前使用收尾代码
* 程序包含的某些代码似乎在将来某个时候才会被用到

核对表（重构总结）
数据级的重构
* 用具名常量来代替神秘数值
* 用更明确或者更具信息量的名字来重命名变量
* 将表达式内敛化
* 用函数来代替表达式
* 引入中间变量
* 将多用途变量转换为多个单一用途变量
* 使用局部变量实现局部用途而不是使用参数
* 将基础数据类型转化为类
* 将一组类型码转化为类或是枚举类型
* 将一组类型码转化为含派生类的类
* 将数组转化为对象
* 封装群集
* 用数据类替代传统记录

语句级的重构
* 分解布尔表达式
* 将复杂的布尔表达式转换为命名精确的布尔函数
* 将条件语句中不同部分中的重复代码合并
* 使用break或return而不是循环控制变量
* 在嵌套的if-then-else语句中一旦知道结果就立刻退出，而不是仅仅赋一个返回值
* 用多态来代替条件语句（尤其是重复地case语句）
* 创建并使用空对象代替对空值得检测

子程序级的重构
* 提取子程序
* 将子程序代码内联化
* 将冗长的子程序转化为类
* 用简单的算法替代复杂算法
* 增加参数
* 减少参数
* 将查询操作同修改操作区分开来
* 合并功能相似的子程序，并用参数来区分他们
* 通过传递不同的参数使子程序体现不同的功能
* 传递整个对象而非特定的成员
* 传递特定的成员而非整个对象
* 封装向下转型操作

类实现的重构
* 将值对象改为引用对象
* 将引用对象改为值对象
* 用数据初始化来代替虚函数
* 改变成员函数或数据的位置
* 将特定的代码提出生成派生类
* 将相似的代码合并起来放到基类中

类接口的重构
* 将某成员子程序放到另一个类中
* 将一个类转化成两个
* 删除某个类
* 隐藏委托关系
* 去掉中间人
* 用委托代替继承
* 用继承代替委托
* 引入外部子程序
* 引入扩展类
* 封装暴露在外的成员变量
* 对不能修改的成员去掉Set（）函数
* 隐藏在类的外部不会使用的成员函数
* 封装不会用到的成员函数
* 如果基类和派生类的代码实现相似，将二者合一

系统级的重构
* 为无法控制的数据创建明确的索引源
* 将单向类联系改为双向类联系
* 将双向类联系改为单向类联系
* 使用工厂函数而非简单的构造函数
* 使用异常代替错误代码，或者反其道而行之

核对表（安全的重构）
* 每一改变都是系统改变策略的一部分吗？
* 在重构之前，你保存了初始代码了吗？
* 你是否保持较小的重构步伐？
* 你是否同一时间只处理一项重构？
* 在重构时你是否把要做得事情一条条列出来了吗？
* 你是否设置了一个停车场，把你在重构时所想到的任何东西记录下来？
* 在每次重构后你会重新测试吗？
* 如果所做的修改非常复杂，或者影响到了关键代码，你会重新检查这些修改吗？
* 你是否考虑过特定重构的风向，并以此来调整你的重构方法？
* 你所做的修改是提升还是降低了程序的内在质量？
* 你是否避免了将重构作为先写后改的代名词，或者作为拒绝重写拙劣代码的托词？

要点
* 修改是程序医生都要面对的事情，不仅包括最初的开发阶段，还包括首次发布之后
* 在修改中软件的质量要么改进，要么恶化。软件烟花的首要法则就是代码演化应当提升程序的内在质量
* 重构成功之关键在于程序员应该学会关注那些标志着代码需要重构的众多的警告或“代码臭味”
* 重构成功的另一个要素是程序员应当掌握大量特定的重构方法
* 重构成功的最后要点在于要有安全重构的策略。一些重构方法会比其他重构方法要好。
* 开发阶段的重构时提升程序质量的最佳时机，因为你可以立刻让刚产生的改变梦想编程现实。请珍惜这些开发阶段的天赐良机。
--》《重构，改善既有代码的设计》

## 第25章 代码调整策略

如果对代码调整能否有助于提高某个程序的性能心存疑虑，按照以下的步骤去做：
1.	用设计良好的代码来开发软件，从而使程序易于理解和修改。
2.	如果程序性能很差。
* a.保存代码的可运行版本，这样你才能回到“最近的已知正常状态”；
* b.对系统进行分析测量，找出热点；
* c.判断性能拙劣是否源于设计、数据类型或算法上的缺陷，确定是否应该做代码调整，如果不是，请跳回到第一步；
* d.对步骤c屮所确定的瓶颈代码进行调整；
* e.每次调整后都对性能提升进行测量；
* f.如果调整没有改进代码的性能，就恢复到步骤a保存的代码（通常而言,超过一半的调整尝试都只能稍微改善性能其至造成性能恶化）。
3.	重复步骤2。

核对表（代码调整策略）
程序整体性能
* 你是否考虑通过修改需求来提高性能
* 你是否考虑通过修改程序的设计来提高性能？
* 你是否考虑通过修改类的设计来提高性能
* 你是否考虑过减少程序同操作系统的交互从而提高性能？
* 是否考虑过避免I/O操作以提高性能？
* 是否考虑使用编译型语言替代解释型语言以提高性能？
* 是否考虑过使用编译器优化选项来提髙性能？
* 是否考虑过使用不同的硬件來提高性能？
* 是否仅仅将代码调整看做是解决问题的最后一招？

代码调整方法
* 在开始调整代码之前，程序是完全正确的么？
* 在调整之前是否测量过性能瓶颈在什么地方？
* 是否记录了每一次修改所产生的效果？
* 如果没有带来预期的性能提高，你是否放弃了所做的代码调整改变？
* 你是否对每一个性能瓶颈进行不止一次的修改尝试一一也就是说，你是在反复进行代码调整么？

要点
* 性能只是软件整体质量的一个方面，通常不是最重要的。精细的代码调整也只是实现整体性能的一种方法，通常也不是决定性的。相对于代码本身的效率而言，程序的架构、细节设计以及数据结构和算法选对程序的运行速度和资源占用的影响通常会更人。
* 定量测量是实现性能最优化的关键。定量测最需要找出能真正决定程序性能的部分，在修改之后，应当通过重复测量来明确修改是提高还是降低了软件的性能。
* 绝大多数的程序都有那么一小部分代码耗费了绝大部分的运行时间。如果没有测量，你不会知道是哪一部分代码。
* 代码调整需要反复尝试，这样才能获得理想的性能提髙。
* 为性能优化工作做好准备的最佳方式就是在最初阶段编写清晰的代码，从而使代码在后续丄作中易于理解和修改。

## 第26章 代码调整技术

核对表（代码调整方法）
同时改善代码执行速度和规模
* 用査询表替换复杂逻辑。
* 合并循环
* 使用整型变量而非浮点变量。
* 在编译时初始化数据。
* 使用正确的常量类型。
* 预先计算结果。
* 删除公共子表达式。
* 将关键子程序代码转化为某种低级语言代码。

仅仅提高代码执行速度
* 在知道答案后就停止执行判断。
* 根据各种情况的出现频率子句排序。
* 比较相似逻辑结构的性能。
* 使用惰性求值
* 将循环中的if判断转到外部。
* 展开循环。
* 将循环内部所做的工作减少到最低限度。
* 在査找循环中使用哨兵。
* 把执行最为频繁的循环放在嵌套循环的最里面。
* 减轻内层循环的强度。
* 将多维数组改为一维数组。
* 最大限度减少数组索引。
* 为数据类型扩充索引。
* 对频繁使用的值进行缓存。
* 利用代数恒等式。
* 降低逻辑和数学表达式的强度。
* 注意系统调用。
* 用内联子程序重写代码。

要点
* 优化结果在不同的语言、编译器和环境下有很大差异。如果没有对每一次的优化进行测量，你将无法判断优化到底是帮助还是损害了这个程序。
* 第一次优化通常不会是最好的。即使找到了效果很不错的，也不要停下扩大战果的步伐。
* 代码调整这一话题有点类似于核能，.富有争议，甚至会让人冲动。一些人认为代码调整损害了代码可读性和可维护性，他们绝对会将其弃之不用。其他人则认为只要有适当的安全保陣，代码调整对程序是有益的。如果你决定使用上述的调整方法，请务必谨慎行事。






