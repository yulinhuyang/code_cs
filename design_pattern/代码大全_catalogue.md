前言

鸣谢

核对表目录

表目录

图目录

**第1部分 打好基础**

**第1章 欢迎进入软件构建的世界**

1.1 什么是软件构建

1.2 软件构建为何如此重要

1.3 如何阅读本书

关键点

**第2章 用隐喻来更充分地理解软件开发**

2.1 隐喻的重要性

2.2 如何使用软件隐喻

2.3 常见的软件隐喻

软件中的书法：写作代码

软件的耕作法：培植系统

软件的牡蛎养殖观点：系统生长

软件构建：建造软件

应用软件技术：智慧工具箱

组合各个隐喻

更多资源

关键点

**第3章 三思而后行：前期准备**

3.1 前期准备的重要性

前期准备适用于现代软件项目吗

准备不周全的诱因

关于开始构建之前要做前期准备的绝对有力且简明的论据

3.2 辨明你所从事的软件的类型

迭代开发法对前期准备的影响

在序列式开发法和迭代式开发法之间做出选择

3.3 问题定义的先决条件

3.4 需求的先决条件

为什么要有正式的需求

稳定需求的神话

在构建期间处理需求变更

3.5 架构的先决条件

架构的典型组成部分

3.6 花费在前期准备上的时间长度

更多资源

关键点

**第4章 关键的“构建”决策**

4.1 选择编程语言

语言描述

4.2 编程约定

4.3 你在技术浪潮中的位置

“深入一种语言去编程”的例子

4.4 选择主要的构建实践方法

关键点

**第2部分 创建高质量的代码**

**第5章 软件构建中的设计**

5.1 设计中的挑战

设计是一个险恶的问题

设计是个了无章法的过程（即使它能得出清爽的成果）

设计就是确定取舍和调整顺序的过程

设计受到诸多限制

设计是不确定的

设计是一个启发式过程

设计是自然而然形成的

5.2 关键的设计概念

软件的首要技术任务：管理复杂度

理想的设计特征

设计的层次

5.3 设计构造块：启发式方法

寻找现实世界中的对象

形成一致的抽象

封装实现细节

当继承能简化设计时就继承

隐藏秘密（信息隐藏）

找出容易改变的区域

保持松散耦合

查阅常用的设计模式

其他的启发式方法

关于设计启发的总结*****

使用启发式方法的原则

5.4 设计实践

迭代

分而治之

自上而下和自下而上的设计方法

建立试验性原型

合作设计

要做多少设计才够？

记录你的设计成果

5.5 对流行的设计方法的评论

更多资源

软件设计，一般性问题

软件设计理论

设计模式

广义的设计

标准

关键点

**第6章 可以工作的类**

6.1 类的基础：抽象数据类型

需要用到ADT的例子

使用ADT的益处

更多的ADT示例

在非面向对象环境中用ADT处理多份数据实例

ADT和类

6.2 良好的类接口

好的抽象

良好的封装

6.3 有关设计和实现的问题

包含（“有一个……”的关系）

继承（“是一个……”关系）

成员函数和数据成员

构造函数

6.4 创建类的原因

应该避免的类

总结：创建类的理由

与具体编程语言相关的问题

6.6 超越类：包

更多资源

关键点

**第7章 高质量的子程序**

7.1 创建子程序的正当理由

似乎过于简单而没必要写成子程序的操作

总结：创建子程序的理由

7.2 在子程序层上设计

7.3 好的子程序名字

7.4 子程序可以写多长

7.5 如何使用子程序参数

7.6 使用函数时要特别考虑的问题

什么时候使用函数，什么时候使用过程

设置函数的返回值

7.7 宏子程序和内联子程序

宏子程序在使用上的限制

内联子程序

关键点

**第8章 防范式编程**

8.1 保护程序免遭无效输入数据的破坏

8.2 断言

建立自己的断言机制

使用断言的指导建议

8.3 错误处理技术

健壮性与正确性

高层次设计对错误处理方式的影响

8.4 异常

8.5 隔离程序以免遭由错误造成的损害

隔离区与断言的关系

8.6 辅助调试代码

不要自动地把产品版本的限制强加于开发版本之上

尽早引入辅助调试的手段

采用冒进式编程

计划移除调试辅助代码

8.7 确定在产品代码中该保留多少防范式代码

8.8 防范式编程时保持防范

其他资源

关键点

**第9章 伪代码编程过程**

9.1 创建类和子程序的步骤概述

创建一个类的步骤

创建子程序的步骤

9.2 伪代码

9.3 通过伪代码编程过程创建子程序

设计子程序

编写子程序

检查代码

收尾工作

根据需要重复上述步骤

9.4 伪代码编程过程之外的其他方案

关键点

**第3部分 变量**

**第10章 使用变量的一般事项**

10.1 数据认知

数据认知测试

有关数据类型的其他资源

10.2 轻松掌握变量定义

隐式声明

10.3 变量初始化原则

10.4 作用域

使变量引用局部化

尽可能缩短变量的“存活”时间

减小作用域的一般原则

有关缩小变量作用域的说明

10.5 持续性

10.6 绑定时间

10.7 数据类型和控制结构之间的关系

10.8 为变量指定单一用途

关键点

**第11章 变量名的力量**

11.1 选择好变量名的注意事项

最重要的命名注意事项

以问题为导向

最适当的名字长度

变量名字的效果范围

变量名字中的计算值限定词

变量名字中的常用反义词

11.2 为特定类型的数据命名

为循环索引命名

为状态变量命名

为临时变量命名

为布尔变量命名

为枚举类型命名

为常量命名

11.3 命名规则的力量

为什么要有规则？

何时采用命名规则

正式程度

11.4 非正式命名规则

语言无关规则的指导原则

语言相关规则的指导原则

混合语言编程的注意事项

命名规则示例

11.5 标准前缀

用户自定义类型缩写

语义前缀

标准前缀的优点

11.6 创建具备可读性的短名称

一般的缩写指导原则

语音缩写

有关缩写的评论

11.7 应该避免的名称

关键点

**第12章 基本数据类型**

12.1 使用数的普遍规则

12.2 整数

12.3 浮点数

12.4 字符和字符串

C中的字符串

12.5 布尔变量

12.6 枚举类型

如果你的语言里没有枚举类型

12.7 命名常量

12.8 数组

12.9 创建你自己的类型（类型别名）

为什么创建自己的类型的示例是用Pascal和Ada写的？

创建自定义数据类型的指导原则

关键点

**第13章 不常见的数据类型**

13.1 结构

13.2 指针

用来理解指针的例子

使用指针的一般技巧

C++指针

C指针

13.3 全局数据

与全局数据有关的常见问题

使用全局数据的理由

只有万不得已时才使用全局数据

用访问子程序来取代全局数据

如何降低使用全局数据的风险

其他资源

关键点

**第4部分 语句**

**第14章 组织直线型代码**

14.1 必须有明确顺序的语句

14.2 顺序无关的语句

使代码易于自上而下的阅读

把相关的语句组织在一起

关键点

**第15章 使用条件语句**

15.1 if语句

简单if-then语句

if-then-else语句串

15.2 case语句

为case选择最有效的排序

使用case语句的提示

关键点

**第16章 控制循环**

16.1 选择循环的种类

什么时候使用while循环

什么时候用带退出的循环

何时使用for循环

何时使用foreach循环

16.2 循环控制

进入循环

处理好循环体

退出循环

检查端点

使用循环变量

循环应该有多长

16.3 轻松创建循环——由内而外

16.4 循环和数组的关系

关键点

**第17章 不常见的控制结构**

17.1 子程序中的多个返回

17.2 递归

递归的例子

使用递归的技巧

17.3 goto

反对goto的论点

支持goto的观点

关于goto的虚假辩论

错误处理和goto

goto和在else子句中的共享代码

goto使用原则总结

17.4 对不常见控制结构的看法

其他资源

关键点

**第18章 表驱动方法**

18.1 表驱动方法使用总则

使用表驱动方法的两个问题

18.2 直接访问表

示例：一个月中的天数（Days-in-Month）

示例：保险费率

例子：灵活的消息格式（Flexible-Message-Format）

构造查询键值

18.3 索引表访问（Indexed Access Tables）

18.4 阶梯访问表

18.5 表查询的其他示例

关键点

**第19章 一般控制问题**

19.1 布尔表达式

用true和false做布尔判断

简化复杂的表达式

编写肯定形式的布尔表达式

用括号使布尔表达式更清晰

理解布尔表达式是如何求值的

按照数轴的顺序编写数值表达式

与0比较的指导原则

布尔表达式的常见问题

19.2 复合语句（块）

19.3 空语句

19.4 驯服危险的深层嵌套

对减少嵌套层次的技术的总结

19.5 编程基础：结构化编程

结构化编程的三个组成部分

19.6 控制结构与复杂度

复杂度的重要性

降低复杂度的一般原则

其它类型的复杂度

关键点

**第5部分 代码改善**

**第20章 软件质量概述**

20.1 软件质量的特性

20.2 改善软件质量的技术

开发过程

设置目标

20.3 不同质量保障技术的相对效能

缺陷检测率

找出缺陷的成本

修正缺陷的成本

20.4 什么时候进行质量保证工作

20.5 软件质量的普遍原理

推荐读物

相关标准

关键点

**第21章 协同构造**

21.1 协同开发实践概要

协同构造是其他质量保证技术的补充

协同构造有利于传授公司文化以及编程专业知识

集体所有权适用于所有形式的协同构造

在构造前后都应保持协作

21.2 结对编程

成功运用结对编程的关键

结对编程的好处

21.3 正式检查

你期望检查能够带来什么结果

检查中的人员角色

检查的一般步骤

检查中的自尊心

检查和代码大全

检查总结

21.4 其他类型的协同开发实践

走查

代码阅读

大型演示

协同构造技术的比较

参考资料

结对编程

检查

相关标准

关键点

**第22章 开发者测试**

22.1 开发者测试在软件质量中的角色.. 500

构造中测试

22.2 推荐的开发者测试方法

先测试还是后测试

开发者测试的局限性

22.3 测试技巧锦囊

不完整的测试

结构化的基础测试

数据流测试

等价类划分

猜测错误

边界值分析

几类坏数据

几类好数据

采用容易手工检查的测试用例

22.4 典型错误

哪些类包含最多的错误？

错误的分类

不完善的构造过程引发错误所占的比例

你期望能发现多少错误

测试本身的错误

22.5 测试支持工具

为测试各个类构造脚手架

Diff工具

测试数据生成器

覆盖率监视器

数据记录器/日志记录器

符号调试工具

系统干扰器

错误数据库

22.6 改善测试过程

有计划的测试

重新测试（回归测试）

自动化测试

22.7 保留测试记录

个人测试记录

推荐读物

测试

测试脚手架

测试优先的开发

相关标准

关键点

**第23章 调 试**

23.1 调试概述

调试在软件质量中所扮演的角色

调试效率的巨大差异

让你有所收获的缺陷

一种效率低下的调试方法

23.2 寻找缺陷

科学的调试方法

寻找缺陷的一些小建议

语法错误

23.3 修正缺陷

23.4 调试中的心理因素

心理取向如何导致调试时的盲目

“心理距离”在调试中的作用

23.5 调试工具——明显的和不那么明显的.. 557

源代码比较工具

编译器的警告消息

扩展的语法和逻辑检查

执行性能分析器

测试框架

调试器

其它资源

关键点

**第24章 重构**

24.1 软件进化的类型

软件进化的哲学

24.2 重构简介

重构的理由

拒绝重构的理由

24.3 特定的重构

数据级的重构

语句级的重构

子程序级重构

类实现的重构

类接口的重构

系统级重构

24.4 安全的重构

不宜重构的情况

24.5 重构策略

推荐读物

关键点

**第25章 代码调整策略**

25.1 性能概述

质量特性和性能

性能和代码调整

25.2 代码调整简介

Pareto法则

一些无稽之谈

何时调整代码

编译器优化

25.3 蜜糖和哥斯拉

常见的低效率之源

常见操作的相对效率

25.4 性能测量

性能测量应当精确

25.5 反复调整

25.6 代码调整方法总结

推荐读物

算法和数据类型

关键点

第26章 代码调整方法

26.1 逻辑

在知道答案后停止判断

按照出现频率来调整判断顺序

相似逻辑结构之间的性能比较

用查找表替代复杂表达式

使用惰性求值

26.2 循环

将判断外提（Unswitching）

合并循环

展开

尽可能减少再循环内部做的工作

哨兵值

把最忙的循环放在最内层

削减强度

26.3 数据变换

使用整型数而不是浮点数

数组维度尽可能少

尽可能减少数组引用

使用辅助索引

使用缓存机制

26.4 表达式

利用代数恒等式

削弱运算强度

编译时初始化

小心系统函数

使用正确的常量类型

预先算出结果

删除公共子表达式

26.5 子程序

将函数重写为内联

26.6 用低级语言重写代码

26.7 变得越多，事情反而更没变

推荐读物

关键点

**第6部分 系统考虑**

**第27章 程序规模对“构筑”的影响**

27.1 交流和规模

27.2 项目规模的范围

27.3 项目规模对错误的影响

27.4 项目规模对生产率的影响

27.5 项目规模对开发活动的影响

活动比例和项目规模

程序、产品、系统和系统产品

方法论和规模

额外资源

关键点

第28章 管理“构筑”

28.1 鼓励良好的编码实践

设定标准的考虑事项

鼓励良好的编码实践的技术

本书的角色

28.2 配置管理

什么是配置管理？

需求变更和设计变更

软件代码变更

工具版本

机器配置

备份计划

有关配置管理的额外资源

28.3 评估“构筑”进度表

评估的方法

评估“构筑”的工作量

对进度的影响

评估与控制

如果你落后了该怎么办

有关软件评估的额外资源

28.4 度量

有关软件度量的额外资源

28.5 把程序员当人看

程序员们怎样花费时间？

性能差异与质量差异

信仰问题

物理环境

有关“把程序员当人看”的额外资源

28.6 管理你的管理者

有关管理构造的额外资源

相关标准

关键点

**第29章 集成**

29.1 集成方式的重要性

29.2 集成频率——阶段式集成还是增量集成

阶段式集成

增量集成

增量集成的益处

29.3 增量集成的策略

自顶向下集成

自底向上集成

三明治集成

风险导向的集成

功能导向的集成

T-型集成

集成方法小结

29.4 Daily Build与冒烟测试

哪种项目能用daily build过程？

持续集成

额外资源

关键点

**第30章 编程工具**

30.1 设计工具

30.2 源代码工具

编辑

分析代码质量

重构源代码

Version Control

数据词典

30.3 可执行码工具

产生目标码

除错

测试

代码微调

30.4 工具导向的环境

30.5 打造你自己的编程工具

项目特有的工具

脚本

30.6 工具幻境

额外资源

关键点

**第7部分 软件工艺**

**第31章 布局与风格**

31.1 基本原则

布局的极端情况

格式化的基本原理

人和计算机对程序的解读

好布局有什么用？

把布局作为一种信仰

良好布局的目标

31.2 布局技术

空白区

括号

31.3 布局风格

纯块结构

模仿纯块结构

使用begin - end对（大括号）指定块边界

行尾布局

哪种风格最优？

31.4 控制结构的布局

格式化控制结构块的要点

其他考虑

31.5 单条语句的布局

语句长度

用空格使语句显得清楚

格式化后续行

每行仅写一条语句

数据声明的布局

31.6 注释的布局

31.7 子程序的布局

31.8 类的布局

类接口的布局

类实现的布局

文件和程序布局

更多资源

关键点

**第32章 自说明代码**

32.1 外部文档

32.2 编程风格作文档

32.3 注释或不注释

32.4 高效注释之关键

注释种类

高效注释

最佳注释量

32.5 注释技术

注释单行

注释代码段

注释数据声明

注释控制结构

注释子程序

注释类、文件和程序

32.6 IEEE标准

软件质量保证标准

更多资源

关键点

第33章 个人性格

33.1 个人性格是否和本书话题无关

33.2 聪明和谦虚

33.3 求知欲

33.4 诚实

33.5 交流与合作

33.6 创造力和纪律

33.7 偷懒

33.8 不像你想象中那样起作用的性格

矜持

经验

编程狂人

33.9 习惯

更多资源

关键点

**第34章 软件开发艺术的有关问题**

34.1 克服复杂性

34.2 精选编程过程

34.3 为人写程序，其次才是为机器

34.4 以所用语言编程，但思路不受其约束.. 843

34.5 借助规范集中注意力

34.6 基于问题域编程

将程序划分为不同层次的抽象

34.7 “当心落石”

34.8 反复，再反复

34.9 不要顽固不化

判断

折中主义

试验

关键点

**第35章 何处有更多信息**

35.1 关于软件创建的信息

35.2 创建之外的话题

综述资料

软件工程综览

其他注释过的参考书目

35.3 期刊

初级程序员杂志

高级程序员杂志

专题出版物

35.4 软件开发者的读书计划

入门级

熟练级

精通级

35.5 参加专业组织

参考文献




