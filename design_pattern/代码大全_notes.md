
# 第一部分：打好基础

## 第一章：欢迎进入软件构建的世界

首先要明确开发计算机软件是一个复杂的工程，并不比建设高楼大厦简单。这项活动和传统的土木工程类有相似的部分，也有迥然不同的地方。

主要有下面的几种活动（根据进程推动顺序）：

- 定义问题
- 需求分析
- 规划构建
- 软件架构/高层设计
- 详细设计
- 编码与调试
- 单元测试
- 集成测试
- 系统测试
- 部署/分发及保障维护
	
《代码大全》主要关注的是构建这部分：

软件构建是软件开发的核心活动；构建活动是每个项目中位移一项必不可少的工作

软件构建的主要活动包括：详细设计、编码、调试、集成、开发者测试（包括单元测试和集成测试）

构建也被称作“编码”和“编程”

构建活动的质量对软件的质量有着实质性的影响

最后，你对“如何进行构建”的理解程度，决定了你这名"程序员"的优秀程度


## 第二章：用隐喻来更充分地理解软件开发

	隐喻的价值绝不应该被低估。隐喻的优点在于其预期的效果：能被所有的人理解。不必要的沟通和误解也因此大为降低，学习与教授更为快速。实际上，隐喻是对概念进行内在化和抽象的一种途径，
	它让人在更高的层面上思考问题，从而避免低层次的错误。

隐喻是启示而不是算法，因此他们往往有一点随意。

隐喻把软件开发过程与其他你熟悉的活动联系在一起，帮助你更好地理解

有些隐喻比其他一些隐喻更贴切

通过把软件的构建过程比作是房屋的建设过程，我们可以发现，仔细的准备是必要的，而大型项目和小型项目之间也是有差异的

通过把软件开发中的实践比作是只会工具箱中的工具，我们发现，每位程序员都有许多工具，但并不存在任何一个能适用于所有工作的工具，因地制宜地选择正确工具是成为能有效编程的程序员的关键。

不同的隐喻彼此并不排斥，应当使用对你最有益处的某种隐喻组合。

隐喻是以一种类比的方法根据一种已知的“模型范式”去理解一种新的领域。这很符合人类认知新事物的思维习惯。但隐喻不是神话，更不是精确的真理，就像某个比喻一样只能在某一个局部进行双向的类比，未必就是全局最合适的。
（同时，注意比喻是有局部性的，不是全局可逆的）

## 第三章：三思而后行：前期准备

	问题定义只定义了问题是什么，而不涉及任何可能的解决方案。

	如果没有好的需求，你可能对问题有总体的把握，但却没有集中问题的特定方面。

	需求像水。如果冻结了，就容易在上面开展建设 ——无名氏 （经常性无法预期的需求变更会伤害项目的开发者，从而毁了项目）

	软件架构是软件设计的高层部分，适用于支撑更细节的设计的框架。

	离开了良好的软件架构，你可能瞄准了正确的问题，但却使用了错误的解决方案。也许完全不可能有成功的构建。

**架构的典型组成部分**

* 程序组织 （源代码层级）
* 主要的类 2/8原则 （基础占20%）
* 数据设计 （数据建模）
* 业务规则 （很有现实意义的重点）
* 用户界面设计 （用户使用的友好度）
* 资源管理
* 安全性（数据库连接、线程、句柄等） （甚至更广泛层面的权限管理）
* 性能
* 可伸缩性
* 互用性
* 国际化、本地化
* 输入输出
* 错误处理
* 容错性
* 架构的可行性
* 过渡工程
* 关于买和造的决策 （在现实情况下，买现成的方案也许是一种更优的选择，不可耻）
* 关于复用的决策
* 变更策略
* 架构的总体质量

**要点**

* 构建活动的准备工作的根本目标在于降低风险。要确认你的准备活动是在降低风险，而非增加风险
* 如果你想开发高质量的软件，软件开发过程必须由始至终关注质量。在项目初期关注质量，对产品质量的正面影响比在项目末期关注质量的一项要大
* 程序员的一部分工作是教育老板和合作者，告诉他们软件开发过程，包括在开始编程之前进行充分准备的重要性
* 你所从事的软件项目的类型对构建活动的前期准备有重大影响——许多项目应该是高度迭代的，某些应该是序列式的
* 如果没有明确的问题定义，那么你可能会在构建期间解决错误的问题
* 如果没有做完良好的需求分析工作，你可能没有察觉待解决的问题的重要细节。如果需求变更发生在构建之后的阶段，其代价是“在项目早期更改需求”的20-100倍。因此在开始编程之前，你要确认“需求“已经到位了
* 如果没有做完良好的架构设计，你可能会在构建期间用错误的方法解决正确的问题。架构变更的代价随着“为错误的架构编写的代码数量”增加而增加，因此，也要确认“”架构“”已经到位了。
* 理解项目的前期准备所采用的方法，并相应地选择构建方法。

**核对表**

架构核对表

针对各架构主题

* 程序的整体组织结构是否清晰？是否包含一个良好的架构全局观（及其理由）
* 是否确定了主要得到构造快（包括每个构造快的职责范围及与其他构造快的接口）
* 是否明确涵盖了“需求”中所列出的所有功能（每个功能对应的构造快不太多也不太少）
* 是否描述并论证了那些最关键的类
* 是否描述并论证了数据设计
* 是否详细定义了数据库的组织结构和内容
* 是否指出了所用关键的业务规则，并描述其对系统的影响？
* 是否描述了用户界面设计的策略‘
* 是否将用户界面模块化，使界面的变更不会影响程序其余部分
* 是否描述并论证了处理I/O的策略
* 是否估算了稀缺资源（如现成、数据库连接、句柄、网络带宽、存储及算力等）的使用量，是否描述并论证了资源管理的策略
* 是否描述了架构的安全需求
* 架构是否为每个类、每个子系统、每个模块功能域提出空间与时间预算
* 架构是否描述了如何达到可伸缩性
* 架构是否关注互操作性
* 是否描述了国际化本地化的策略 （这个要看具体的项目，比如一个团队内部使用的工具，完全没必要，但如果既往框架对此有支持而又没有明显的增加工作量也可以考虑其后续在这方面的扩展性）
* 是否提供了一套内聚的错误处理策略
* 是否规定了容错的方法
* 是否证实了系统各个部分的技术可行性
* 是否详细描述了过渡工程的方法
* 是否包含了必要的 买 vs. 造的决策
* 架构是否描述了如何加工复用的代码，使之符合其他架构目标？
* 是否将架构设计得能够适应和可能出现的变更
	
架构的总体质量

* 架构是否解决了全部的需求
* 有没有那个部分是过渡架构或欠架构？是否明确宣布了在这方面的预期指标
* 整个架构是否在概念上协调一致
* 顶层设计是否独立于用作实现它的机器和语言
* 是否说明了所有主要的决策和动机
* 你，作为一名实现该系统的程序员，是否对这个架构感觉良好？	

## 第四章：关键的“构建”决策

核对表：主要的构建实践

编码

* 你有没有确定多少设计工作将要预先进行，多少设计工作在键盘上进行（在编写代码的同事）？
* 你有没有规定诸如名称、注释、代码格式等“编码约定” （编码规范）
* 你有没有规定特定的由软件架构确定的编码实践，比如如何处理错误条件，如何处理安全性事项，对于类接口有哪些约定、可重用的代码遵循哪些标准，在编码实考虑多少性能因素
* 你有没有找到自己在技术浪潮中的位置，并相应调整自己的措施？如果必要，你是否知道如何“深入一种语言去编程”，而不受限于语言*（仅仅“在一种语言上编程”）

团队工作

* 你有没有定义一套集成工序——即，你有没有定义一套特定的步骤，规定程序员在把代码check in（签入）到主源码（代码库）中之前，必须履行这些步骤
* 程序员是结对编程、还是独自编程，或者这二者的某种组合

质量保证

* 程序员在编写代码之前，是否先为之编写测试用例 （测试驱动）
* 程序员会为自己的代码写单元测试吗？（无论先写还是后写）
* 程序员在check in 代码之前，会调用调试器但不追踪整个代码流程吗？
* 程序员在check in 代码之前，是否进行集成测试（integration-test）
* 程序员会复审（review）或检查别人的代码吗?	

工具

* 你是否选用了某种版本控制工具 （svn，git）
* 你是否选定了一种语言，以及语言的版本或编译器版本
* 你是否选择了某个编程框架（framework,如j2ee 、。net）,或者明确地决定不使用编程框架
* 你是否决定允许使用非标准的语言特性？（在使用非标准的情况下，要保证其整体迁移能力，比如hack了某一部分，要将其整体实现包括到项目内）
* 你是否选定并拥有了其他将要用到的工具——编辑器、重构工具、调试器、测试框架、语法检查器？

要点

-  每种编程语言都有其优点和弱点。要知道你使用的语言的明确优点和弱点
-  在开始编程之前，做好一些约定。“改变代码”使之符合这些“约定”是几乎不可能的
-  “构建的实践方法”的种类比任何单个项目能用到的要多。有意识地选择最适合你的项目的时间方法
-  问问你自己，你采用的编程实践是对你所用的编程语言的正确响应，还是受它的控制？清记得“深入一种语言去编程”，不要仅“在一种语言上编程”
-  你在技术浪潮中的位置决定了哪种方法是有效的——甚至是可能用到的。确定你在技术浪潮中的位置，并响应调整计划和预期目标



# 第二部分：创建高质量的代码

## 第五章：软件构建中的设计

无论是以何种方式来进行设计，小型项目也能和大型项目一样从精心的设计之中获益，而如果能认识到设计是一项明确的活动，你就更会获益匪浅。

设计过程充满了不确定性，因此设计技术也趋于探索性质

软件的首要技术使命：管理复杂度

**设计特征：**

* 最小复杂度
* 易于维护
* 松散耦合
* 可扩展性
* 可重用性
* 高扇入：大量的类使用某个给定的类
* 低扇出：一个类里少量/适量地使用其他的类
* 可移植性
* 精简性
* 层次性
* 标准技术：尽量少依赖外来的，尽量使用标准的、常用的
	
系统层设计图应该是无环图

抽象是一种能让你在关注某一概念的同时可以放心地忽略其中一些细节的能力——在不同的层次处理不同的细节。抽象的主要好处就在于它使得你能忽略无关的细节，抽象是我们用来得以处理现实世界中复杂度的一种重要手段

在设计一个类的时候，一项关键性的决策就是确定类的哪些特性应该对外可见，而哪些特性应该隐藏起来 （面向对象设计的原则）

信息隐藏中所说的秘密主要分为两大类：

* 隐藏复杂度，
* 隐藏变化源

把容易变化的地方隔离开来

* 业务规则
* 对硬件的依赖性
* 输入和输出
* 非标准的语言特性
* 困难的设计区域和构建区域
* 状态变量

**常用的设计模式**

* 抽象工厂(Absctruct Factory):通过制定对象组的种类而非对单个对象的类型来支持创建一组相关的对象
* 适配器（Adapter）:把一个类的接口转变成另一个接口
* 桥接（Bridge）：把接口和实现分离开来，使他们可以独立变化
* 组合（Composite）:创建一个包含其他同类对象的对象，使得客户端代码可以与最上层对象交互而无需考虑所有的细节对象
* 装饰器（Deractor）：给一个对象动态的添加职责，而无需为了每一种可能的职责配置情况去创建特定的子类（派生类）
* 外观（Facade）：为没有提供一致接口的代码提供一个一致的接口
* 工厂方法（Factory Method）：做特定基类的派生类的实例化时，除了在Factory Method内部之外均无需了解各派生对象的具体类型
* 观察者（Observer）:使一组相关对象相互同步，方法是让另一个对象负责：在这组对象中的任何一个发生改变时，由它把这种变化通知给这个组里的所有对象
* 单例模式(Singleton):为有且仅有一个实例的类提供一种全局访问的可能
* 策略(Strategy):定义一组算法或者行为，使得他们可以动态地相互替换
* 迭代方法（Iterator）：提供一个服务对象来顺序的访问一组元素中的各个元素
* 模板方法（Template Method）：定义一个操作的算法结构，但是把部分实现的细节留给子类（派生类）

设计模式的益处

* 设计模式通过提供抽象来减少复杂度
* 设计模式通过把常见解决方案的细节予以制度化来减少出错
* 设计模式通过提供多种设计方案而带来启发性价值
* 设计模式通过把设计对话提升到一个更高的层次上来简化交流


设计模式的陷阱

* 强迫让代码适用于某个模式
* 为了模式而模式


设计中启发式方法的总结：

* 寻找现实世界的对象
* 形成一致的抽象
* 封装实现细节
* 在可能的情况下继承
* 信息隐藏
* 找出容易改变的区域
* 保持松散的耦合
* 探寻通用的设计模式
* 高内聚性
* 构造分层结构
* 严格描述这类契约
* 分配职责
* 为测试而设计
* 避免失误
* 有意识地选择绑定时间
* 创建中央控制点
* 考虑蛮力
* 画一个图
* 保持设计模块化

**解决问题的方法**

	1 理解问题
	2 设计一个计划，找出现有数据和未知量之间的关系
	3 执行计划
	4.回顾

迭代、分而治之、自上而下（分解）、自下而上（合成）

**记录你的设计成果**

* 把设计文档插入到代码
* 用wiki来记录设计讨论和决策
* 写总结邮件
* 使用数码相机
* 保留设计挂图
* 使用CRC卡片
* 在适当的细节层创建UML图
	
**核对表：软件构造中的设计**

设计实践

* 你已经做过多少次迭代，并且从众多尝试结果中选择最佳的一种，而不是简单选择第一次尝试的结果吗
* 你尝试用多种方案来分解系统，以确定最佳方案吗？
* 你同时用自上而下和自下而上的方法来解决涉及到的问题吗？
* 为了解决某些特定的问题，你对系统中的风险部分或者不熟悉的部分创建过原型、写出数量最少的可抛弃的代码吗？
* 你的设计方案被其他人检查了吗（无论正确与否）？
* 你一直在展开设计，直到实施细节跃然纸上了吗？
* 你用某种适当的技术——比如说wiki、电子邮件、挂图、数码照片、UML、CRC卡片或者在代码里写注释——来保留设计成果吗？

**设计目标**

* 你的设计是否充分地处理了由系统架构层定义出并且推迟确定的事项？
* 你的设计被划分为层次吗？
* 你对把这一程序分解成为子程序、包、类的方式感到满意吗？
* 类与类之间的交互关系是否已经设计为最小化了？
* 类和子程序是否被设计为能够在其他的系统中重用？
* 程序是不是易于维护
* 设计是否精简？设计出来的每一部分都是绝对必要的吗？
* 设计中是否采用了标准的技术？是否避免了使用怪异且难以理解的元素？
* 整体而言，你的设计是否有助于最小化偶然性的和本质性的复杂度吗?

**要点**

* 软件的首要技术使命就是管理复杂度。以简单作为努力目标的设计方案对此最有帮助
* 简单性可以通过两种方式获取：一是减少在同一时间所关注的本质性复杂度的量；而是避免生成不必要的偶然的复杂度
* 设计是一种启发式的过程。固执于某一种单一方法会损害创新能力，从而损害你的程序
* 好的设计都是迭代的。你尝试设计的可能性越多，你的最终分设计方案就会变得越好、
* 信息隐藏是个非常有价值的概念。通过询问“我应该隐藏什么？”能够解决很多困难的设计问题	


## 第6章  可以工作的类

抽象数据类型是指一些数据以及对这些数据所进行的操作的集合

接口/API先行——Tacey

只有一个实例的类是值得怀疑的

不要创建任何并非绝对必要的继承结构

继承层次尽量限制在3层之内

如果可能，应该在所有的构造函数中初始化所有的数据成员（防御式编程实践）

优先使用深拷贝


**创建类的原因**

* 为现实世界中的对象建模
* 为抽象的对象建模
* 降低复杂度
* 隔离复杂度
* 隐藏实现细节
* 限制变动的影响范围
* 隐藏全局数据
* 让参数传递更顺畅
* 建立中心控制点
* 让代码更易于重用
* 为程序族做计划
* 把相关操作包装在一起
* 实现某种特定的重构

应该避免
* 避免创建万能类
* 消除无关紧要的类
* 避免用动词命名的类

超越类：包

核对表：类的质量

抽象数据类型

* 你是否把程序中的类都看作是抽象数据类型了？是否从这个角度评估它们的接口了？

**抽象**

* 类是否有一个中心目的
* 类的命名是否恰当？其名字是否表达了其中心目的？
* 类的接口是否展现了一致的抽象？
* 类的接口是否能够让人清除明白地知道该如何用它
* 类的接口是否足够抽象，使你能不必顾虑它是如何实现其服务的？你能把类当作做黑盒子吗？
* 类提供的服务是否足够完整，能让其他类无需动用其内部数据？
* 是否已从类中除去无关信息？
* 是否考虑过把类进一步分解为组件类？是否已尽可能将其分解？
* 在修改类时是否维持其接口的完整性

**封装**

* 是否把类的成员的可访问性降到最小？
* 是否避免暴露类中的数据成员
* 在编程语言所许可的范围内，类是否已尽可能地对其他类隐藏了自己的实现细节？
* 类是否避免对其使用者，包括其派生类会如何使用它做了假设？
* 类是否不依赖于其他类？他是松散耦合的吗？


## 第7章  高质量的子程序

子程序是为实现一个 特定的目的而编写的一个被调用的方法或过程

创建子程序的正当理由

* 降低复杂度
* 引入中间、易懂的抽象
* 避免代码重复
* 支持子类化
* 隐藏顺序
* 隐藏指针操作
* 提高可一致性
* 简化复杂的布尔判断
* 改善性能

除此之外，创建类的很多理由也是创建子程序的理由
* 隔离复杂度
* 隐藏实现细节
* 限制变化所带来的影响
* 隐藏全局数据
* 形成中央控制点
* 促成可重用代码
* 达到特定的重构目的

好的子程序名字
* 描述子程序所做的所有事情
* 避免使用无意义的、模糊或者表述不清的动词
* 不要仅通过数字来形成不同子程序名字
* 根据需要确定子程序名字的长度
* 给函数命名时要对返回值有所描述
* 给过程起名时使用语气强烈的动词加宾语的形式（面向对象语言中不需要宾语）
* 为常用操作确定命名规则

如何使用子程序参数
* 按照输入->修改->输出排列参数
* 如果几个子程序都用了类似的一些参数，应该让这些参数的排列顺序保持一致
* 使用所有的参数
* 把状态或出错变量放在最后
* 不要把子程序的参数用作工作变量
* 在接口中对参数的假定加以说明（不要等把子程序写完之后再回头去写注释/API先行）
* 把子程序的参数的个数限制在大约7个以内
* 为子程序传递容易维持其接口抽象的变量或对象
* （尽量）使用具名参数，使参数更加具有自我描述性
* 确保实际参数与形式参数相匹配

使用函数时要特别考虑的问题

函数是指有返回值的子程序；过程是指没有返回值的子程序（语义上）

设置函数的返回值
* 检查所有可能的返回路径
* 不要返回指向局部数据的引用或指针

核对表：高质量的子程序

大局事项

* 创建子程序的理由充分吗？
* 一个子程序中所有适用于单独提出的部分是不是已经被提出到单独的子程序中了
* 过程的名字是否用了强烈、清晰的“动词+宾语”词组？函数的名字是否描述了其返回值？
* 子程序的名字是否描述了它所做的全部事情？
* 是否给常用的操作建立了命名规则？
* 子程序是否具有强烈的功能上的内聚性？即它是否做且只做一件事。并且把它做得很好？
* 子程序之间是否有较松的耦合？子程序与其他程序之间的连接是否是小的、明确的、可见的和灵活的？
* 子程序的长度是否是由其功能和逻辑自然确定，而非遵循任何人为的编码标准？

参数传递事宜

* 整体来看，子程序的参数表是否表现出一种具有整体性且接口一致的接口抽象？
* 接口假定是否已在文档中说明？
* 子程序的参数个数是否没超过7个？
* 是否用到了每一个输入参数？
* 是否用到了每一个输出参数？
* 子程序是否避免了把输入参数用作工作变量
* 如果子程序是一个函数，那么他是否在所有可能的情况下都能返回一个合法的值？

要点

* 创建子程序最主要的目的是提高程序的可管理性，当然也有其他的一些好的理由。其中，节省代码空间只是一个次要的原因：提高可读性、可靠性和可修改性等原因都更重要一些‘
* 有时候，把一些简单的操作写成独立的子程序也非常有价值
* 子程序可以按照其内聚性分为很多类，而你应该让大多数子程序具有功能上的内聚性，这是最佳的一种内聚性
* 子程序的名字是它的质量指示器。如果名字糟糕但恰如其分，那就说明这个子程序设计得很差劲。如果名字糟糕而且又不准确，那么它就反映不出程序是干什么的。不管怎样，糟糕的名字意味着程序需要修改。
* 只有在某个子程序的主要目的是返回由其名字所描述的特定结果时，才应该使用函数
* 细心的程序员会非常谨慎的使用宏，而且只在万不得已的时候才用。


## 第8章 防御式编程

要点
* 最终产品代码中对错误的处理方式要比“垃圾进，垃圾出”复杂的多。
* 防御式编程技术可以让错误更容易发现、更容易修改，并减少错误对产品代码的破坏。
* 断言可以帮助人尽早发现错误，尤其是在大型系统和高可靠性的系统中，以及快速变化的代码中。
* 关于如何处理错误输入的决策是一项关键的错误处理决策，也是一项关键的高层设计决策。
* 异常提供了一种与代码正常流程角度不同错误处理手段。如果留心使用异常，它可以称为程序员们知识工具箱中的一项有益补充，同时也应该在异常和其他错误处理手段之间进行权衡比较。
* 针对产品代码的限制并不适用于开发中的软件。你可以利用这一优势在开发中添加有助于更快地排查错误的代码。

核对表 （防御式编程）

一般事宜
* 子程序是否保护自己免遭有害输入数据的破坏？
* 你用断言来说明编程假定吗？其中包括了前条件和后条件吗？
* 断言是否只是用来说明从不应该发生的情况？
* 你是否在架构或高层设计中规定了一组特定的错误处理技术？
* 你是否在架构或高层设计中规定了是让错误处理更倾向于健壮性还是正确性？
* 你是否建立了隔栏来遏制错误可能造成的破坏？是否减少了其他需要关注错误处理的代码的数量？
* 代码中用到的辅助调试的代码了吗？
* 如果需要启用或禁用添加的辅助助手的话，是否无须大动干戈？
* 在防御式编程时引入的代码量是否适宜——既不过多，也不过少？
* 你在开发阶段是否采用了进攻式编程来使错误难以被忽视？

异常
* 你在项目中定义了一套标准化的异常处理方案吗？
* 是否考虑过异常之外的其他替代方案？
* 如果可能的话，是否在局部处理了错误而不是把它当成一个异常抛到外部？
* 代码中是否避免了在构造函数和析构函数中抛出异常？
* 所有的异常是否都与抛出它们的子程序处于同一个抽象层次上？
* 每个异常是否都包含了关于异常发生的所有背景信息？
* 代码中是否没有使用空的catch语句？（或者如果使用空的catch语句确实很合适，那么明确说明了吗？）

安全事宜
* 检查有害输入数据的代码是否也检查了故意的缓冲区溢出，SQL注入、HTML注入、整数溢出以及其他恶意输入数据？
* 是否检查了所有的错误返回码？
* 是否捕获了所有异常？
* 出错消息中是否避免出现有助于攻击者攻入系统所需的信息

安全、断言、异常


## 第9章 伪代码编程过程

一个类的创建过程可以千变万化，但基本上都会以下图所示的顺序发生：
 
 
伪代码编程过程的替代方案
* 测试先行开发/测试驱动开发：在任何代码之前先要写出测试用例
* 重构：通过对代码进行一系列保持语义的变换和调整来提高代码的质量。
* 契约式设计：认为每一段程序都具有前条件和后条件，用断言来注解并验证前条件和后条件
* 东拼西凑

核对表（伪代码编程过程）
* 是否检查过已满足所有的先决条件？
* 定义好这个类要解决的问题了吗？
* 高层次的设计是否足够清晰？能给这个类和其中的每一个子程序起一个好名字吗？
* 考虑过该如何测试这个类及其中每一个子程序了吗？
* 关于效率的问题，你主要从稳定的接口和可读的实现这两个角度考虑吗？还是主要从满足资源和速度的预期目标的角度考虑过呢？
* 在标准函数库或其他代码库中寻找过可用的子程序或者组件了吗？
* 在参考书籍中查找过有用的算法了吗？
* 是否用详尽的伪代码设计好每一个子程序？
* 你在脑海里检查过伪代码吗？这些伪代码容易理解吗？
* 关注过那些可能会让你重返设计的警告信息了吗？（比如说关于全局数据的使用，一些看上去更适合放在另一个类或子程序中的操作等）
* 是否把伪代码正确地翻译成代码了？
* 你反复使用伪代码编程过程了吗？有没有根据需要把一些子程序拆分成更小的子程序？
* 在作出假定的时候有没有对它们加以说明？
* 已经删除掉那些冗余的注释了吗？
* 你是否采取了几次迭代中最好的那个结果？还是在第一次迭代之后就停止了？
* 你完全理解你的代码了吗？这些代码是否容易理解？

要点
* 创建类和子程序通常都是一个迭代的过程。在创建子程序的过程中获得的认识常常会反过来影响类的设计。
* 编写好的伪代码需要使用易懂的英语/自然语言/人话，要避免使用特定编程语言中才有的特性，同时要在意图的层面上写伪代码（即描述该做什么，而不是要怎么做）。
* 伪代码编程过程是一个行之有效的做详细设计的工具，它同时让编码工作更容易。伪代码会直接转化为注释，从而确保了注释的准确性与实用性。
* 不要只停留在你所想到的第一个设计方案上。反复使用伪代码作出多种方案，然后选出其中最佳的一种方案开始编码。
* 每一步完成后都要检查你的工作成果，还要鼓励其他人帮你来检查。这样你就会在投入精力最少的时候，用最低的成本发现错误。



