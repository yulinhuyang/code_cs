


https://refactoring.com/

https://refactoringguru.cn/


## 1  UML图 


四个视角：外部、交互、结构化、行为

静态：用（例）类与对象，组件部署

动态：顺序合作，搞活（动）状态

uml 4+1： 4： 逻辑视图、行为视图、实现视图、部署视图 + 1：用例视图 

4种关系：关联，泛化，依赖，实现 

### 1.1 常用图

需求（用例）-概要（类、对象、顺序合作、活动状态）--详细-编码-测试


#### 1.1.2 用例图

	参与者（角色）

	包含include，扩展extend，泛化（Generalization），箭头指小。


#### 1.1.3 类图

	箭头指向被的

	实现（---|> 虚线 箭头, 类与接口）、泛化（-|> 实线 箭头, 继承，子类继承父类，老师学生与借书者）的类。

	依赖（---> 使用，虚剪头）、关联（-> 引用，属性字段，平等，实剪头）

	聚合关系（<> -> 空菱剪头, 整体与个体，多个记录聚集）、组合关系（实菱形加剪头,整体与局部，如id），设计中先用空菱，后面根据需要涂黑成实菱

	类图中，箭（剪）头（不是菱形）指向内容或范围较小的类

	强弱关系: 泛化 > 实现 > 组合 > 聚合 > 关联 > 依赖，虚线更弱，空心更弱。

#### 1.1.4 动态图

	动态模型是描述系统的功能是如何完成的。

	顺序图: 消息时间顺序的交互图，角色 + 消息

		--> 横轴(各类角色轴) 纵轴(时间轴,类元角色生命线),消息(一个对象生命线到另一个对象生命线箭头),多个对象交互顺序。复杂场景下，可绘制多个典型场景顺序图。

	活动图：目标对象计算流程和工作流程建模，流程图
	
		--> 活动 + 活动流（控制流和数据流）+ 控制符（分支(decision/merge)、并发（fork/join））+ 泳道（不同活动分组），多个对象复杂流程活动分支处理。

	状态图: 系统元素的状态条件和响应,具有若干确定的状态，类的行为在这些状态下可以切换。

		--> 状态 + 事件 + 转换，初始态,结束态，特定对象不同状态。
		
		

## 2 设计模式

### 2.1 设计模式原则

正交四原则 ：最小化重复、分离变化、缩小依赖范围、向稳定方向依赖

solid 原则：

	单一职责原则（SRP) :一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中
	
	开闭原则（OCP):	一个软件实体应当对扩展开放，对修改关闭。模块可以在不被修改的前提下被扩展
	
	里氏替换原则（LSP）：派生的子类应该是可替换基类的
	
	接口隔离原则（ISP）：类不应该被迫依赖他们不使用的方法，也就是说一个接口应该拥有尽可能少的行为，它是精简的，也是单一的
	
	依赖倒转原则（DIP）：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象


依赖倒转:底层应依赖抽象。

### 2.2 创建型模式：

工厂模式：创建与使用分离

抽象工厂：一类产品族
	

类结构: 继承与实现

对象结构:关联与组合

### 2.3 结构型模式：

适配器模式:wraper现有接口转为需要的接口

外观模式:多个部件提供统一接口，简化对外接口


### 2.4 行为型模式：

类行为型（模板 解释器），对象行为型模式

观察者模式:一对多的依赖关系，一个对象变化，多个依赖他的对象得到通知并更新。降低耦合，建立触发机制。

责任链模式:所有请求处理者，记住前一对象对下一对象的处，新增行为拓展机制。

策略模式:一系列算法封装，彼此替换。


## 3  重构

### 3.1 重构原则

重构粒度:架构 模块  函数

事不过三，三则重构

时机: 新增功能，修复缺陷，代码评审

随时进行，为了做的更好 

两顶帽子: 新增功能或重构

一次只做一件事

测试保护、识别味道、采用手法、小步前进

小步前进，随时可用，随时可停，随时回退，修改就测试

测试用例:构造工作量、覆盖率、执行速度

大型重构:逆向工程

### 3.2 代码坏味道

	直观:风格、排版、函数、变量

	微观:字段定义不合理，函数功能单一

	宏观:类职责不单一，上帝类。

	简单设计四原则

#### 3.2.2 冗余与重复:

	重复代码：函数 extract method ，类 pullup method，差异部分用模板方法设计。
	
	过多注释（comments）:注释why，代码自己说明how和what
	
    夸夸其谈未来，过度设计:

#### 3.2.3 局部膨胀:

	过长参数列表:
	
		--->查询代替

		--> 入参封装成一个对象,多个同样入参函数可以封装成类。注意全局变量，静态变量等隐形参数。 
		
		---> 可以合并相关参数成结构体或类，引入参数对象；拆分函数(控制标记)。
       
	    ---> 构造函数有大量参数：生成器模式或将类分层为多个组成部分。

#### 3.2.4 耦合或结构不良：
	
	发散式变化：功能过多
	
	     --->按照不同变化方向进行拆分.
		 
		 ---->如果按步骤进行，可以拆分成多个阶段。
		 
	霰弹修改：遇到变化，需要在多个模块做很多小修改。
	
		--->将功能集中在一起，搬移函数或字段
		
		---> 内联函数或类，合并模块
		
	重复的switch：
	
		--->对象语言：多态，子类/状态/策略取代 类型码。
		
		--->过程：表驱动挂钩子；策略模式，控制和处理分离。
		
		N:1:N问题： 多个函数调 ————>1 个函数 ---> 多个分支。
		
		散布各处的相似switch问题:
		
	临时字段：
	
		---> 特殊阶段，成员函数传参用。可以封装成小类。


代码静态检查：binscope等

代码度量工具


### 3.3 重构手法

	
	重构手法---->基本手法--->基本操作（创建、替换）

	五大手法：抽（抽取方法）、替（内联方法）、组（抽取类）、改（重命名）、移（移动方法）
	
		内联方法（变量）：
		
	旧的不变，新的创建，一步替换，旧的再见
	
#### 3.3.2 简化语句

	移动语句：让相关联的语句一起出现。
	
	合并条件表达式：合并之后，提炼函数
	
	卫语句取代嵌套条件表达式：
	
		什么是卫语句: https://blog.csdn.net/wangpaiblog/article/details/114909737

			---->函数入口: if（cost < 0） return -1;
			
			---->卫语句（guard clauses）是一种改善嵌套代码的优化代码。将经过多级嵌套的代码使用卫语句优化之后，代码嵌套层数可以降低，因此改使用卫语句能降低代码的复杂程度。
			
			卫语句是通过对原条件进行逻辑分析，将某些要害（guard）条件优先作判断，从而简化程序的流程走向，因此称为卫语句。

#### 3.3.3 重组函数
	
	内联函数：以函数实现代替调用函数的地方，消除间接性

	查询与修改分开：将有无副作用分开

	移除标记参数：直接调用对应函数项，各个分支对应的新函数。

	

#### 3.3.4 重组数据
	
	
	拆分变量：多次赋值的变量承担多个职责，需要进行拆分。

	提炼类：不同职责代码拆分，或多个类合并。
	
	内联类：消除间接性，先委托调用，再搬移。
	

	类继承体系：

		成员搬移：

			函数上移（Pull Up Method） 
			字段上移（Pull Up Field） 
			移除子类（Remove Subclass

		反向手法：

			函数下移（Push Down Method） 
			字段下移（Push Down Field） 
			以子类取代类型码（Replace Type Code with Subclasses） 

		继承关系调整：

			提炼超类（Extract Superclass） 

			折叠继承体系（Collapse Hierarchy） 

			以委托取代子类（Replace Subclass with Delegate）

			以委托取代超类（Replace Superclass with Delegate） 


		从上到下，从下到上拆分


	系统级重构：
		
		重构层级： L0 -- L4（功能正确--无漏洞风险 -- 代码整洁--架构整洁--持续演进）
		
		多了逆向工程和应用重构


