
参考：

https://refactoring.com/

https://refactoringguru.cn/


## 1  UML图 


### 1.1 绘图工具

[PlantUML,让你知道什么才是高效绘制流程图](https://zhuanlan.zhihu.com/p/76948461)

[软件工程各阶段的UML图](https://cloud.tencent.com/developer/article/1552210)

[OOAD与UML教学视频](https://www.bilibili.com/video/BV19x411L7HH?p=2)

[使用starUML绘制时序图 step by step](https://cloud.tencent.com/developer/article/1543471)

[StarUML之七、StarUML的Class Diagram(类图)示例](https://www.cnblogs.com/sun-null/p/12228234.html)

[软件工程常用文档](https://github.com/cuizhenjie/software-engineering-document)


### 1.2 常用图

需求（用例）-概要（类、对象、顺序合作、活动状态）--详细-编码-测试

#### 1.2.1 用例图

	参与者（角色）

	包含include，扩展extend，泛化（Generalization），箭头指小。


#### 1.2.2 类图

箭头指向被的

实现（---|> 虚线 三角, 类与接口）、泛化（-|> 实线 三角, 继承，子类继承父类，老师学生与借书者）的类。

依赖（---> 使用，虚箭头）、关联（-> 引用，属性字段，平等，实箭头）

聚合关系（<> -> 空菱剪头, 整体与个体，多个记录聚集）、组合关系（实菱形加箭头,整体与局部，如id），设计中先用空菱，后面根据需要涂黑成实菱


有箭头，那边箭头指向范围小的，三角指向父或者接口

强弱关系: 泛化 > 实现 > 组合 > 聚合 > 关联 > 依赖，虚线更弱，空心更弱。	
	
         泛化(继承) =  实现  > 组合 >  聚合  >  关联（拥有） >  依赖（使用  include）
	
	 实线三角 >  虚线三角 > 实菱形 > 空菱形 >  实线箭头 > 虚线箭头

强 -->弱： 实三 虚三 实菱 空菱 实箭 虚箭（实虚三菱箭 ）

关联（Association）：是一种拥有的关系，它使一个类知道另一个类的属性和方法

泛化（Generalization）：是一种继承关系 <----- > 实现（Realization）：是一种类与接口的关系

#### 1.2.3 动态图

动态模型是描述系统的功能是如何完成的。

顺序图: 消息时间顺序的交互图，角色 + 消息

	--> 横轴(各类角色轴) 纵轴(时间轴,类元角色生命线),消息(一个对象生命线到另一个对象生命线箭头),多个对象交互顺序。复杂场景下，可绘制多个典型场景顺序图。

活动图：目标对象计算流程和工作流程建模，流程图

	--> 活动 + 活动流（控制流和数据流）+ 控制符（分支(decision/merge)、并发（fork/join））+ 泳道（不同活动分组），多个对象复杂流程活动分支处理。

状态图: 系统元素的状态条件和响应,具有若干确定的状态，类的行为在这些状态下可以切换。

	--> 状态 + 事件 + 转换，初始态,结束态，特定对象不同状态。

		
## 2 设计模式

### 2.1 设计模式原则

正交四原则 ：最小化重复、分离变化、缩小依赖范围、向稳定方向依赖

solid 原则：

	单一职责原则（SRP) :一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中    
	开闭原则（OCP):	一个软件实体应当对扩展开放，对修改关闭。模块可以在不被修改的前提下被扩展    
	里氏替换原则（LSP）：派生的子类应该是可替换基类的    
	接口隔离原则（ISP）：类不应该被迫依赖他们不使用的方法，也就是说一个接口应该拥有尽可能少的行为，它是精简的，也是单一的    
	依赖倒转原则（DIP）：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象    

依赖倒转:底层应依赖抽象。


抽工单建原

带上适当的装备组合可以让外国侨胞享受

带(代理模式)上适(适配器模式)当的装(装饰模式)备组(组合模式)合可以让外(外观模式)国侨(桥接模式)胞享(享元模式)受（游戏）


多次命令和责备中，车模见状慌忙解开（衣服）

迭(迭：多次的意思，迭代模式)命(命令模式)令和责(职责链模式)备(备忘录模式)中(中介者模式)，车(策略模式)
模(模板方法模式)见(观察者模式)状(状态模式)慌(访问者模式)解(解释器模式)释。


### 2.2 创建型模式：

工厂模式：创建与使用分离    
抽象工厂：一类产品族    
	

类结构: 继承与实现    
对象结构:关联与组合    


单例模式  ===>懒汉模式和饿汉模式

懒汉模式在调用方法时创建对象，饿汉模式在类初始化时创建对象


特点：单一实例    自己创建自己的唯一实例（构造方法私有）    给所有其他对象提供这一实例（单例类自己提供单例)

1. Factory Method（工厂方法）：隔离创建对象的细节，使得创建对象的行为可扩展，即定义一个与创建产品的接口，由子类决定生产什么产品。

2. Abstract Factory（抽象工厂）：该模式抽象出创建一组相关对象的接口，其中每个方法即为factory method，提供一个创建产品组的接口，其每个子类可以生产一系列相关的产品

3. Builder（建造者）：该模式包含了对象构造的若干过程，把复杂对象分解成多个相对简单的部分，最后根据不同需要分别创建他们，最后构建对象。因此天然地与template结合

4. Prototype（原型）: 用于以某个对象为模子（原型）复制克隆多个与原型类似的新对象的场景，例如幻灯片中的母版与普通页、对象的克隆

5. Singleton（单例）：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例

6. 静态/简单工厂模式：工厂方法是静态的时候也成静态工厂。专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。


### 2.3 结构型模式：

适配器模式:wraper现有接口转为需要的接口    
外观模式:多个部件提供统一接口，简化对外接口    


适配器模式与外观模式对比：

1：二者都是对现有接口进行转换以满足需求    
2：适配器模式是将现有接口转变成需要的接口，外观模式是为各子系统的提供一个统一接口，简化系统对外接口    


6. Adapter Class/Object（适配器）：将一个类的接口转换成希望的另外一个接口。解决接口不兼容问题，处理遗留系统的不二法宝，也可以用空方法实现接口作为抽象父类。分为类的适配器和对象的适配器两种实现。其中类的适配器采用的是（继承）关系，而对象适配器采用的是（组合聚合）关系。

7. Bridge（桥接）: 将抽象和实现分离，使他们可以独立变化，使用组合关系代替继承，解决类多维度的扩展导致的类爆炸的问题

8. Composite（组合）：将对象组合成树形层次结构，使用户对单个对象和组合对象具有一致的访问性

9. Decorator（装饰）：动态的给对象增加一些职责，即增加其额外功能。常见于各种wrapper，常用于在原函数执行前后做一些额外的工作

10. Facade（外观/门面）：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。封装扇出，利用树状结构减少调用者的复杂度。是迪米特法则（最少知识原则）的典型运用

11. Flyweight（享元）：运用共享技术来有效的支持大量细颗粒对象的复用。复用变化少的对象

12. Proxy（代理）：为某对象提供一种代理以控制对该对象的访问。是原对象的一个完整的替代品


### 2.4 行为型模式：

类行为型（模板 解释器），对象行为型模式

观察者模式:一对多的依赖关系，一个对象变化，多个依赖他的对象得到通知并更新。降低耦合，建立触发机制。

责任链模式:所有请求处理者，记住前一对象对下一对象的处，新增行为拓展机制。

策略模式:一系列算法封装，彼此替换。

13. Interpreter（解释器）：提供如何定义语言的文法，一般用于解释执行自定义的某种语法，即解释器

14. Template Method（模板方法）：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中。框架与钩子

15. Chain of Responsibility（责任链）：一组对象按照既定的顺序关联起来（排列成链），依次处理请求，直到请求被响应为止，其中任一对象都有权停止调用传递

16. Command（命令）: 将一个请求封装为一个对象，将发出的请求的责任和执行请求的责任分隔开。将行为抽象和解耦

17. Iterator（迭代器）：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。封装数据的访问行为（顺序、可见性等）

18. Mediator（中介者）：用一个中介对象来封装一系列的交互，简化原有对象之间的交互关系，降低对象间的耦合度;新增一个模块处理两个模块的交互

19. Memento（备忘录）：在不破坏封装性的前提下，获取并保存一个对象的内部状态，便于恢复。将当前对象的状态信息保存为另一个对象，使得当前对象可以基于状态镜像快速恢复原状态

20. Observer（观察者）: 对个对象之间存在一对多关系，一个对象发生改变，通知其他对象。订阅/发布模型，用于事件驱动的设计

21. State（状态）：允许一个对象在其内部状态发生改变是改变其行为能力。封装FSM（有限状态机）的状态与状态迁移，每个状态定义了自身的输入与状态迁移

22. Strategy（策略）：定义一系列算法，将每个算法封装起来，使他们可以相互替换。使用接口即使用strategy，用于隔离变化

23. Visitor（访问者）：在不改变集合元素的前提下，为一个集合中的每一个元素提供多种访问方式。数据与行为分离方法。通过这种分离，可达到一个被访问者动态添加新的操作而无需做其他的修改的效果


## 3  重构

### 3.1 重构原则

重构粒度:架构 模块  函数

事不过三，三则重构

时机: 新增功能，修复缺陷，代码评审

随时进行，为了做的更好 

两顶帽子: 新增功能或重构

一次只做一件事

测试保护、识别味道、采用手法、小步前进

小步前进，随时可用，随时可停，随时回退，修改就测试

测试用例:构造工作量、覆盖率、执行速度

大型重构:逆向工程

### 3.2 代码坏味道

直观:风格、排版、函数、变量

微观:字段定义不合理，函数功能单一

宏观:类职责不单一，上帝类。

简单设计四原则

#### 3.2.2 冗余与重复:

重复代码：函数 extract method ，类 pullup method，差异部分用模板方法设计。

过多注释（comments）:注释why，代码自己说明how和what

夸夸其谈未来，过度设计:

#### 3.2.3 局部膨胀:

过长参数列表:

	--->查询代替

	--> 入参封装成一个对象,多个同样入参函数可以封装成类。注意全局变量，静态变量等隐形参数。 

	---> 可以合并相关参数成结构体或类，引入参数对象；拆分函数(控制标记)。

        ---> 构造函数有大量参数：生成器模式或将类分层为多个组成部分。

#### 3.2.4 耦合或结构不良：
	
发散式变化：功能过多

         --->按照不同变化方向进行拆分.

	 ---->如果按步骤进行，可以拆分成多个阶段。

霰弹修改：遇到变化，需要在多个模块做很多小修改。

	--->将功能集中在一起，搬移函数或字段

	---> 内联函数或类，合并模块


重复的switch：

	--->对象语言：多态，子类/状态/策略取代 类型码。

	--->过程：表驱动挂钩子；策略模式，控制和处理分离。

	N:1:N问题： 多个函数调 ————>1 个函数 ---> 多个分支。

	散布各处的相似switch问题:

	switch惊悚现身:以多态来代替。 Replace Type Code with Subclass （以子类取代类型码）或 Replace Type Code with State/Strategy （以状态/策略取代类型码）
		
临时字段：

	---> 特殊阶段，成员函数传参用。可以封装成小类。


代码静态检查：binscope等    
代码度量工具    

### 3.3 重构手法
	
重构手法---->基本手法--->基本操作（创建、替换）

五大手法：抽（抽取方法）、替（内联方法）、组（抽取类）、改（重命名）、移（移动方法）

	内联方法（变量）：

旧的不变，新的创建，一步替换，旧的再见
	
Inline: 为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。

内联可以调试，函数被内联后，编译器可以通过上下文相关的优化技术对结果代码进行更深入的优化。

内联： 消除间接性，将不合理的函数内联成大函数，再通过提炼函数方法重构

#### 3.3.2 简化语句

移动语句：让相关联的语句一起出现。    
合并条件表达式：合并之后，提炼函数    
卫语句取代嵌套条件表达式：    

什么是卫语句: https://blog.csdn.net/wangpaiblog/article/details/114909737

	---->函数入口: if（cost < 0） return -1;    
	---->卫语句（guard clauses）是一种改善嵌套代码的优化代码。将经过多级嵌套的代码使用卫语句优化之后，代码嵌套层数可以降低，因此改使用卫语句能降低代码的复杂程度。    
	卫语句是通过对原条件进行逻辑分析，将某些要害（guard）条件优先作判断，从而简化程序的流程走向，因此称为卫语句。   

#### 3.3.3 重组函数
	
内联函数：以函数实现代替调用函数的地方，消除间接性    
查询与修改分开：将有无副作用分开     
移除标记参数：直接调用对应函数项，各个分支对应的新函数。    


#### 3.3.4 重组数据
	
拆分变量：多次赋值的变量承担多个职责，需要进行拆分。

提炼类：不同职责代码拆分，或多个类合并。

内联类：消除间接性，先委托调用，再搬移。

类继承体系：

	成员搬移：

		函数上移（Pull Up Method） 
		字段上移（Pull Up Field） 
		移除子类（Remove Subclass

	反向手法：

		函数下移（Push Down Method） 
		字段下移（Push Down Field） 
		以子类取代类型码（Replace Type Code with Subclasses） 

	继承关系调整：

		提炼超类（Extract Superclass） 

		折叠继承体系（Collapse Hierarchy） 

		以委托取代子类（Replace Subclass with Delegate）

		以委托取代超类（Replace Superclass with Delegate） 


	从上到下，从下到上拆分


系统级重构：

	重构层级： L0 -- L4（功能正确--无漏洞风险 -- 代码整洁--架构整洁--持续演进）

	多了逆向工程和应用重构


