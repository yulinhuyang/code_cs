
# 上篇： 编程范式与编程语言

# 第1章 开班导言
======

## 初识范式

所谓编程范式(programming paradigm)，指计算机编程的基本风格或典范模式，是编程者在创造虚拟世界时采用的 __世界观__ 和 __方法论__，编程是为了解决问题，而解决问题可以有 __许多种视角和思路__，其中普适且行之有效的模式被归结为范式。由于着眼点和思维方式不同，相应的范式自然各有侧重和倾向。

- 世界观：体现在语言的 __核心概念__ 中
- 方法论：体现在语言的 __表达机制__ 中

## 开发技术

- 任何概念和技术都不是孤立的，需要在 __纵向的时间__ 和 __横向的联系__ 中找准坐标
- 学习编程范式能增强编程语言的语感，否则一个惯用C语言的人只会写出'C式C++'，而不具备OOP的语感

### 库和工具包 vs 框架
- 库和工具包是为程序员带来 __自由__ 的，框架是为程序员带来 __约束__ 的
- __宏观管理__ 上选取一些框架以控制整体的结构的流程。利用控制反转(IOC)等机制实现对各模块的统一调度
- __微观实现__ 上利用库和工具包来解决具体的细节问题

### 设计模式 vs 架构
- 设计模式是软件的 __战术__ 思想，架构是软件的 __战略__ 决策
- 设计模式是针对某些经常出现的问题而提出的行之有效的设计解决方案，它侧重 __思想重用__，因此比框架更抽象，更普适，但多限于局部解决方案，没有框架的整体性。
- __惯用法(idiom)__，也是针对常发问题的解决方案，但 __偏重实现__ 而非设计，__与实现语言密切相关__，是一种更底层更具体的编程技巧
- 架构指一个系统的最高层次的 __整体结构和规划__，一个架构可能包含多个框架，而一个框架可能包含多个设计模式。

#第2章  重要范式
=========

## 命令范式-一切行动听从指挥

### 命令式编程
命令式编程(imperative programming)是冯.诺伊谩机运行机制的抽象

- 世界观是：程序是由若干行动指令组成的有序列表
- 方法论是：用变量来存储 __数据__，用语句来执行 __指令__

> 语言的演化是渐进的，大多数语言追根溯源是汇编语言的升级，而作为与机器语言一一对应的汇编语言自然是命令式的，因而这种范式最为传统和普及。理论上说，完全可以有非命令式的机器语言存在，前提是计算机采用了特殊的硬件实现，比如非冯.诺伊谩结构的数据流机(dataflow machine)和规约机(reduction machine)，但这类计算机并未流行于市，相应的机器语言自然罕见

- 过程式编程(procedural programming)是指引入了过程、函数或子程序的命令式编程。现代语言命令式均具备此特征，故二者不加区分

### 结构化编程
结构化编程(structured programming，简称SP)，是在过程化编程的基础上发展起来的，本质是一种 __编程原则__，提倡代码应具有清晰的逻辑结构，以保证程序易于读写、测试、维护和优化。

> 在20世纪60年代首次软件危机中，它曾起中流砥柱。Pascal是遵循结构化编程原则设计而来的

- 微观上：主张 __循规守矩__，采用3种逻辑结构，限制goto使用
> goto语句可以跳到程序过程中的任一点，造成 _静态程序_ 与 _动态进程_ 之间的差异，影响程序可读性
- 宏观上：主张 __分而治之__，采用自项向下的设计
- 按结构化思想设计的流程图，每个模块大小适中、模块之间关系简明、模块内部线路清晰
- 根据结构化定理，任何程序都可以用顺序(concatenation)、选择(selection)和循环(repetition)等3种基本控制结构来表示。结构化编程就是在三种基本结构的基础上进行嵌套组合。

## 声明范式-目标决定行动
### 声明式与命令式区别
- 声明式编程由若干规范(specification)的声明组成，即一系列陈述句“已知这，求解那”，强调“__做什么__”，而非“怎么做”，声明式编程是人脑思维方式的抽象，利用数理逻辑或既定规范对已知条件进行推理或运算
> 声明式编程产生于人工智能的研究，主要包括 __函数式编程__(functional programming，简称FP)和 __逻辑式编程__(logic programming，简称LP)
- 命令式编程是 __行动导向__ 的，因而算法是显性而目标是隐性的；声明式编程(declarative programming)是 __目标驱动__ 的，因而目标是显性而算法是隐性的。

C(命令式)

<!--language: c-->

    int factorial(int n){
        int f = 1;
        for (; n > 0; --n) f *= n;
        return f;
    }

Lisp/Scheme(函数式)

<!--language: scheme-->

    (define (factorial n)
          (if (= n 0) 1
              (* n (factorial(- n 1)))))


Prolog(逻辑式)

<!--language: prolog-->

    // 0! 等于1
    factorial(0,1).
    // 若M等N-1且M!等于Fm且F等于N*Fm，则N!等于F
    factorial(N,F) :- M is N-1, factorial(M,Fm), F is N* Fm.

上述三种语言，C明确给出了阶乘的迭代算法，而Lisp仅描述了阶乘的递归定义，Prolog则陈述了两个关于阶乘的断言

> 当然C也可以递归实现，但 __命令式语言提倡迭代而不鼓励递归__，除尾递归(tail recursion)外，一般递归比迭代开销(overhead)大。相反 __声明式语言提供递归而不支持迭代__，迭代着眼微观过程，而递归放眼宏观规律

- 声明式编程让我们重回 __数学思维__：
    - 函数式编程类似代数的表达式变换和计算
    - 逻辑式编程则类似数理逻辑推理
    - 变量也如数学中一样，是抽象符号而非内存地址，没有赋值运算，不会产生变量被改写的副作用(side-effect)，也不存在内存分配和释放问题

- 声明式语言擅长于 __数理逻辑的应用__，如人工智能、符号处理、数据库、编译器等，对 __基于业务逻辑__ 的，尤其交互式或事件驱动型的应用，显然命令式语言更有用武之地

### 三种核心编程范式的比较

<!--language: table-->

    |范式  |程序    |输入    |输出    |程序设计|程序运行  |
    |------|--------|--------|--------|--------|----------|
    |命令式|自动机  |初始状态|最终状态|设计指令|命令执行  |
    |函数式|数学函数|自变量  |因变量  |设计函数|表达式变换|
    |逻辑式|逻辑证明|题设    |结论    |设计命题|逻辑推理  |

### 声明式的其它形式
- C#中attribute，java中annotation采用具有声明式特征的 __属性导向式__ 编程(Attribute-Oriented Programming，简称@OP)。
- 数据库语言SQL、样式语言XSLT、CSS、__标记语言__ HTML、XML、SVG、__规范语言__ IDL(Interface Description Language)等都是声明式的，它们大多是领域特定语言，且不少并非图灵完备。
- Prograph、SISAL等数据流语言，采用 __数据流编程__(Dataflow Programming)
- Oz、CHIP等支持与逻辑式编程相交的 __约束性编程__(Constraint Programming)

## 对象范式-民主制社会
OOP(Object-Oritented programming)是一种计算机编程模式，它将对象作为问题空间的基本元素，利用对象和对象间的相互作用来设计程序，所谓对象，是实际问题中实体的抽象，具有一定的属性和功能。

- OOP虽然是在命令式的基础上发展起来的，但其核心思想可泛化为：__以数据为中心组织逻辑__，将系统视为相互作用的对象集合，并利用继承与多态来增强可维护性、可扩展性和可重用性
- 命令式、函数式和逻辑式互相平行，__而OOP与它们正交__：Clos成为OO版的Lisp，Prolog也有融入OO特征的扩充，如visual prolog
- OOP最适用于大型复杂的、交互式的，与现实世界密切相关的系统，小型应用、数学计算、符号处理等方面并无优势。
- 将可维护性、可扩展性和可重用性与OOP划等号，是只见树木，不见森林，因为那是所有范式和语言的共同目标。
    - C语言中，信息隐藏可用 __static__ 来实现，继承可用 __合成__ 来代替，多态可用 __函数指针__ 来实现。

### 过程式编程与OOP区别
- 过程式编程的理念是以过程为中心，自顶向下、逐步求精，类似数学证明中分析法，执果索因的逆推法；OOP则相反，以数据为中心，自底向上、逐步合并，类似数学证明中的综合法，执因索果的正推法。
- 过程式编程，树干改变容易导致树枝相应改变，一旦 __用户需求发生变化__，维护起来不易，而OOP从树叶开始设计，离用户需求较远，__抽象程序较高__，受波及程序较小，更易维护和重用
- OOP以对象为基本模块，使设计更人性化，接近人类的 __认知模式__：`牛.吃(草)` vs `吃(牛,草)`
- 与其说OOP重用性，不如说更具 __易用性__，C函数不像Java对象，本身没有状态，只有依靠参数传递或外部变量来维持相关函数之间的联系，而OOP就是将 __相关函数用数据粘合__，重新包装后再贴上对象标签。
- 过程式编程的模块以函数为单位，而OOP的模块以对象为单位，函数是被动的实体，对象是主动的实体
    - 过程式程序的世界是君主制，等级分明，听命于上级，对下级发号施令，最终为国王服务。
    - OO程序是民主制，所有对象独立而平等，有权保护自己财产与隐私，向他人寻求服务，有义务为他人提供承诺的服务，公民间通过信息交流来协作完成任务

### OO三大特性
- 封装：使公民拥有 __个体__ 身份，须对自己负责
- 继承：使公民拥有 __家庭__ 身份，须对家庭负责
- 多态：使公民拥有 __社会__ 身份，须对社会负责

## 并发范式-合作与竞争
真正的并发式编程(concurrent programming)，不只是调用线程API，使用`synchronized`、`lock`之类那么简单，从宏观架构设计，到微观的数据结构、流程控制乃至算法，比串行式编程都可能发生变化

- 并发式编程以 __进程为导向__ 、以 __任务为中心__ 将系统模块化
- 以 __资源共享与竞争__ 为主线，意味着程序设计将围绕进程的划分与调度、进程间的通信与同步等来展开
> 同步(synchronization)只在采用 __共享内存__(shared memory)的并发模型中需要，采用 __消息传递__(message passing)的并发模型中(如Erlang)并不需要
- 它同OO一样，与3大核心范式正交，并发式进程个数为1即为传统串行式编程，对象个数为0即传统的数据类型。

### 合理并发式设计的考量
- 软件易于重用、维护、测试
- 公平有效地利用资源，优化程序性能如增大吞吐量、减少响应时间、提高效率等
- 保障进程安全，防止竞态条件(Race Condition)
- 保持进程活性，避免死锁、饥饿、活锁、资源枯竭
- 减少锁开销，上下文切换等带来的性能损失
- 妥善处理多进程在算法、调试方面带来的复杂性

### 编程语言对并发的支持
- Ada、Java、C#在 __语言级别__ 上支持并发，在语法上对并发编程有一定的支持
- C、C++选择交由操作系统处理，除关键字`volatile`外，主要靠 __库函数__ 支持
- 专门为并发式而设计的，如Erlang

### 与OO区别
- 并发式以任务为单位，而OO以对象为单位
- 子系统中交流与合作时，并发式以竞争为主题，而OO以服务为主题

## 五种范式小结

<!--language: table-->

    |范式    |体系      |模块    |模块关系    |
    |--------|----------|--------|------------|
    |过程式  |君主体系  |过程    |授命与听命  |
    |函数式  |数学体系  |函数    |替换与合成  |
    |逻辑式  |逻辑体系  |断言    |归纳与演绎  |
    |对象式  |民主体系  |对象    |交流与服务  |
    |并发式  |生产体系  |进程    |竞争与合作  |



# 第3章 常用范式
=========
## 泛型范式-抽象你的算法

- 泛型编程(Generic Programming，简称GP)是 __算法导向__ 的，即以算法为起点和中心点，逐渐将其所涉及的 __概念__(数据结构、类)内涵模糊化、外延扩大化，将其所涉及的 __运算__(函数、方法、接口)抽象化、一般化，从而 __扩展算法的适用范围__。

- 基本思想是：将算法与其作用的数据结构分离，并将 __后者__ 尽可能泛化，这种泛化是基于模板(template)的 __参数多态__(parametric polymorphism)，相比OOP的基于继承(inheritance)的 __子类型多态__(subtyping polymorphism)，普适性更强，效率也更高。但用法稍微复杂一些，可读性稍差一些。

### 泛型实现机制
- C++和D采用类型模板(template)，最著名代表是STL(Standard Template Library)
- Java采用类型擦除(type erasure)
- C#采用类型具化(reification)

C++(泛型编程)

<!--language: cpp-->

    template <typename T>
    T max(T a, T b){
        return (a > b) ? a : b;
    }

C(宏定义)

<!--language: c-->

    #define max(a,b) ((a) > (b) ? (a) : (b))

在C中可用宏定义(macro definition)来实现，但无法保证类型安全，而C++模板兼顾类型安全和代码重用，并且由于在编译期间展开，效率上也不损失，且由于C++支持运算符重载，一切定义了`>`运算的数据类型均可调用`max`函数

### STL三要素
- __算法__(algorithm)：一系列切实有效的步骤
- __容器__(container)：是数据的集合，可理解为抽象的数组
- __迭代器__(iterator)：是算法与容器之间的接口，可理解为抽象的指针或游标


### STL示例
- 请问它们共同之处，能否共享代码
    - 从一个整数数组中随机抽取十个数，对其中的素数求和
    - 将一个无序整数集中所有的完全平方数换成其平方根
    - 从学生成绩表中，列出门门都及格且平均分在70分以上的学生名单
    - 在一个着色二元树中，将所有红色结点涂成蓝色
    - 将一个字符串从倒数第3个字符开始反向拷贝到另一个字符串中
    - 每从标准输入读取一个非数字的字符X，于标准输出打印"X不是数字字符"

- 只有抽象出表面的数据，算法的脊梁才能显现，以上几题运算泛型思维，可发现它们共性：对指定集合中满足指定条件的元素进行指定处理

<!--language: cpp-->

    template <class Iterator, class Act, class Test>
    void process(Iterator begin, Iterator end, Act act, Test test){
        for (; begin != end; ++begin)
            if (test(*begin)) act(*begin);
    }

比起前面`max`模板，这里连元素的数据类型T都没有，因为元素被容器封装了，只需通过它的迭代器参与算法：

- 泛化了 __容器__，可以是数组、列表、集合、映射、队列、栈、字符串等
- 泛化了 __元素__，可以是任何数据类型
- 泛化了 __处理方法和限定条件__，可以是任何函数，甚至是函子(functor)－－自带状态的函数对象，即除了泛化概念，还能 __泛化行为__
- 泛化了 __迭代器__，可以从前往后移动，也可以从后往前移动，可以来回移动，可以随机移动，可以按任意预先定义规律移动

以下为第6题实现：

<!--language: cpp-->

    #include <iostream>
    #include <vector>
    #include <fstream>
    #include <iterator>

    using namespace std;

    template <class Iterator, class Act, class Test>
    void process(Iterator begin, Iterator end, Act act, Test test){
        for (; begin != end; ++begin)
            if (test(*begin)) act(*begin);
    }

    bool notDigit(char c){
        return (c<'0') || (c>'9');
    }

    void printNondigit(char c){
        cout << c << " not digit" <<endl;
    }

    int main() {
        process(istream_iterator<char>(cin), istream_iterator<char>(), printNondigit, notDigit);

        return 0;
    }

完全看不到IO读取的过程，也看不到迭代循环，让人摆脱了底层编码细节，在更高 __更抽象__ 的层次上进行编程设计，用一种新的视角去审视问题。

## 超级范式-提升语言级别
元程序 __将程序作为数据对待__，能自我发现、自我赋权和自我升级，有着其他程序所不具备的自觉性、自适应性和智能性，是一种更高级的程序。

> [程序的本质复杂性和元语言抽象](http://www.cnblogs.com/weidagang2046/p/the-nature-of-meta.html) 提到 `Program = Logic + Control`  程序的本质复杂性就是 __逻辑__，非本质复杂性就是 __控制__，绝大多数程序不够简洁优雅的根本原因：逻辑与控制耦合。

### 元编程
- 模板元编程(Template Metaprogramming)与泛型编程密切相关但自成一派，隶属于另一种编程范式－__元编程__(Metaprogramming，简称MP)

<!--language:!cpp-->

    #include <iostream>
    using namespace std;

    template <int N>
    struct factorial{
        enum { value = N * factorial<N-1>::value};
    };

    template <>
    struct factorial<0>{
        enum { value = 1};
    };

    int main(){
        cout << factorial<5>::value << endl;
        return 0;
    }

这里阶乘的值是在 __编译时__ 而非运行时计算出来的，是以模板形式通过编译器生成了新的代码，并在编译期间获得执行。

- Lex和Yacc编写编译器和解析器的工具
- 除上述在编译期间生成源代码的 __静态元编程__，还有在运行期间修改程序的 __动态元编程__，如JavaScript用字符串构建`Function`，Ruby提供了`define_method`、`instance_eval`等元编程方法


### DSL

- 领域特定语言DSL，灵活方便地处理客户逻辑，比通用语言更简单、更抽象、更专业、更接近自然语言和声明式语言，开发效率提高
- Hiberate中HQL就是典型的DSL，通过ANTLR来解析(ANother Tool for Language Recognition，能生成C,C++,Java,C#,Python等)
- 语言导向式编程(Language-Oriented Programming，简称LOP)，在建立一套DSL体系之后，直接用它们来编写软件

> [用流畅接口构造内部DSL](http://www.cnblogs.com/weidagang2046/archive/2011/10/30/fluent-interface.html)

### 代码生成
- 各种IDE通过向导、拖放控件等方式自动生成源代码；UML建模工具将类图转换为代码；Servlet引擎将JSP转换为Java代码等
- 生成的代码，不需要被管理（小操作造成生成上差异很大，削弱版本控制意义），而元程序数据需要版本化，简明而直观
> 同理，没法记录的东西，不方便自动化与重放，比如调试，用单元测试与log取而代之
- 自动生成源代码的编程也属于另一种编程范式－产生式编程(Generative Programming)，只是它更看重代码的生成，而元编程看重的是生成代码的可执行性。

## 切面范式-多角度看问题

### 抽象与分解
- 不良代码的病征：
    - __结构混乱__，或聚至纠缠打结、或散至七零八落
    - __代码重复__，叠床架屋、臃肿不堪
- 有效方式是 __抽象与分解__：从问题中抽象出一些关注点，再以此为基础进行分解。抽象是 __前提__，分解是 __方式__，模块化是 __结果__
    - 将程序分别抽象为过程、函数、断言、对象和进程，就依次成为过程式、函数式、逻辑式、对象式和并发式
    - 抽象出算法后与数据分离，就成了泛型式
    - 切面式的AOP将程序抽象分解为 __切面__，以切面为模块
- 抽象与分解原则：__单一化，正交化__。每个模块职责明确专一，模块间相互独立，高内聚低耦合(high cohesion & low coupling)。
    - 此原则相当普适，是分析复杂事物的一种基本方法，在数学和物理中应用广泛：质因式分解、正交分解、谱分解
    - 在数学中互为正交的两个向量在彼此方向上投影为零，意味着彼此独立、互不影响

### Soc与DRY
Soc(Separation of Concerns)即关注点分离，DRY(Don't Repeat Yourself)即尽量减少重复代码。

### Aspect
- 切面Aspect，描述的是横切关注点(cross-cutting concerns)，是与程序的 __纵向主流__ 执行方向 __横向正交__ 的关注焦点。
- 调用某些对象的方法、读写某些对象的域、抛出某些异常等前后需要用到统一的业务逻辑，诸如日志输出、代码跟踪、性能监控、异常处理、安全检查、事务管理等，难以实现Soc与DRY时
- AOP将每类横切关注点封装到单独的Aspect模块中，将程序中的一些执行点与相应的代码绑定起来
    - 单个的执行点称为 __接入点__(join poing)，如调用某个对象的方法前后；
    - 符合预先指定条件的 __接入点集合__ 称为 __切入点__(pointcut)，如所有以set为命令开头的方法；
    - 每段绑定的代码称为一个 __建议__(advice)
- __接入点 vs 切入点__
    - 接入点是点，切入点是面，advice定义了切入点上，执行于接入点处，共享一段附加代码的接入点组成了一个切入点
    - 切入点一般用条件表达式来描述，不仅有广泛性，还有预见性（以后新增的代码如果含有满足切入点条件的接入点，advice代码便自动附着其上）

### AOP与OOP
OOP只能沿着继承树的纵向方向重用，而AOP则弥补了该不足，可以在横向方向重用，AOP不是OOP的分支，也不能说超越了OOP，而是一种补充，尽管AOP并不局限于OOP语言

### AOP实现机理
如果一个程序是一个管道系统，AOP就是在管道上钻一些孔，在每个孔中注入新的代码流。因此AOP的实现关键是将advice的代码嵌入到主体程序中，术语称 __编织__(weaving)。

- 静态编织，通过修改源码或字节码(bytecode)在编译期(compile-time)、后编译期(post-compile)或加载期(load-time)嵌入代码，可能用到元编程和产生式编程
- 动态编织，通过代理(proxy)等技术在运行期(run-time)实现嵌入
- 工具：扩展性语言AspectJ、AspectC++、Aspect#；框架AspectWerkz、Spring等

## 事件驱动-有事叫你,没事别烦
侦查事件与响应事件两项任务进行了正交分解，降低了软件的耦合度和复杂度。

### 流程驱动 vs 事件驱动

采用主动去轮询(polling)，行为取决于自身的观察判断，是流程驱动的，符合常规的流程驱动式编程(Flow-Driven Programming)的模式，采用被动等通知(notification)，行为取决于外来的突发事件，是事件驱动的，符合常规的事件驱动式编程(Event-Driven Programming，简称EDP)的模式

### 事件的类型
- 基于事件驱动的系统一般提供两类的内建事件(built-in event)：
    - 底层事件(low-level event)或称原生事件(native event)，在GUI系统中，这类事件直接由鼠标、键盘等硬件设备触发
    - 语义事件(semantic event)，一般代表用户的行为逻辑，是若干底层事件的组合，比如鼠标拖放多表示移动被拖放的对象，由鼠标按下、鼠标移动、鼠标释放三个底层事件组成
- 除此之外，还有一类用户自定义事件(user-defined event)，可以是在原有的内建事件的基础上进行的包装，也可以是纯粹的虚拟事件(virtual event)
- 除外界激发的自然事件(natural event)，有时程序员需要主动激发一些事件，比如模拟用户鼠标点击或键盘输入(createEvent,trigerEvent)，称为合成事件(synthetic event)

### Windows消息机制

<!--language: c-->

    ...WinMain(...){
        // 第一步，注册窗口别
        ...;
        windowClass.lpfnWndProc = WndProc; // 指定该类窗口的回调函数

        windowClass.lpszClassName = windowClassName;
        RegisterClassEx(&windowClass);

        // 第二步，创建一个上述类别的窗口
        CreateWindowEx(..., windowClassName, ...);
        ...;

        // 第三步，消息循环
        while (GetMessage(&msg, NULL, 0, 0) > 0) { // 获取消息
            TranslateMessage(&msg); // 翻译消息
            DispatchMessage(&msg); // 分派消息
        }
    }

    // 第四步，窗口过程（处理消息）
    ...WndProc(..., msg, ...){
        switch (msg){
            case WM_SIZE: ...; // 用户改变窗口尺寸
            case WM_MOVE: ...;
            case WM_CLOSE: ...;
            ...;
        }
    }

- 消息是Windows内部最基本的通信方法，事件需要通过消息来传递，是消息的主要来源，每当用户触发一个事件，系统将其转化为消息并放入相应程序的消息队列(message queue)中，先入系统消息队列，再放入应用程序消息队列。
- `DispatchMessage`如何联系到`WinProc`？`DispatchMessage`的消息参数含有事发窗口的句柄(handle)，从而可以得到窗口过程`WinProc`，`(WNDPROC)GetWindowLong(msg.hwnd, GWL_WNDPROC)`，而当初创建窗口时指定了窗口类别，后者又绑定了窗口过程。
- 编程者自己写的应用层函数`WinProc`，却不直接调用它，而是通过库函数间接调用，这类函数称为：回调函数(callback)
- 消息循环不依赖于应用程序，完全可提炼出来作为library一部分，MFC就作了此处理
，假设窗口过程由应用程序直接调用，那么消息循环中代码将不具独立性，__无法作为公因子分解出来__

### 回调机制

- 函数指针是C和C++用来实现callback的一种方式，此外抽象类、接口、C++中的泛型函子(generic functor)和C#中的委托(delegate)都可以实现callback

![prog_paradigm_callback](../../pics/prog_paradigm_callback.png)

- 在软件模块分层中，低层模块为高层模块提供服务，并且不能依赖高层模块，以保证其可重用性；另一方面，通常被调用者(callee)为调用者(caller)提供服务，调用者依赖被调者，两者结合，决定了低层模块多为被调用者，高层模块为调用者，但并不总合适，低层模块为了追求更强的 __普适性和可扩展性__，有时也有调用高层模块的需求

<!--language: java-->

    String[] strings = {"Please", "sort", "the", "strings", "in", "REVERSE", "order"};
    Arrays.sort(string, new Comparator<String>(){
        public int compare(String a, String b){
            return -a.compareToIgnoreCase(b);
        }
    });

- callback使得Array.sort不再局限于自然排序，允许用户自行排序规则，大大提高了算法的重用性

### 同步回调 vs 异步回调
- 字符串数组排序中，callback作为参数传入低层的函数后，很快就在该函数体中被调用；而窗口程序中，callback则先被储存起来，至于何时被调用是未定之数。前者称为同步(synchronous)回调，后者称为异步(asynchronous)回调
- 都使用调用者，不再依赖调用者，将二者从 __代码上解耦__，异步调用更将二者从 __时间上解耦__

![prog_paradigm_asyn_callback](../../pics/prog_paradigm_asyn_callback.png)

- 图中处于低层的软件平台是在win32 API基础上的改增，主循环沉淀下来，而且将存储callback的过程封装在一个注册函数中，整个流程的 __控制权__ 已从应用程序的主程序 __转移到底层平台__ 的主循环中，符合好莱坞原则(Don't call us, we'll call you)

### 控制反转
好莱坞原则中，经纪公司处于主导地位，艺人们处于受控状态，这便是控制反转(Inversion of Control，简称IoC)

- 一般库中用callback只是局部的控制反转
- 框架则将IoC机制用到 __全局__，程序员牺牲了对应用程序流程的主导权，换来的是更简洁的代码和更高的生产效率。
- 框架的可扩展性，通过 __插件__(plugin)体系达到

![prog_paradigm_ioc](../../pics/prog_paradigm_ioc.png)

### 依赖反转与依赖注射
- __依赖反转__ 原则(Dependency-Inversion Principle，简称DIP)更加具体
    - 高层模块不应依赖低层模块，它们都应依赖于抽象
    - 抽象不应该依赖于细节，细节应依赖抽象

- __依赖注射__(Dependency Injection，简称DI)，动态地为一个软件组件提供外部依赖
- 控制反转、依赖反转和依赖注射的 __主题是控制与依赖，目的是解耦、方法是反转、而实现这一切的关键是抽象接口__
    - 为什么是抽象接口，而不是回调函数？
    - “回调”强调的是行为方式－低层反调高层，而“抽象接口”强调的是实现方式－正是由于接口具有抽象性，低层才能在调用时无须考虑高层的具体细节，从而实现控制反转

### 事件驱动式可伸缩性
可伸缩性(scalability)指从容应对工作量增长的能力，常与性能(performance)等指标一并被考量

- 控制反转的主要作用是降低模块之间的依赖性，从而降低模块的耦合度和复杂度，提高软件的可重用性、柔韧性和可扩展性，但对可伸缩性并无太大帮助

- 控制反转导致了事件驱动式编程的被动性(passivity)。事件驱动式还具有异步性(asynchrony)的特征，这是由事件的不可预测性与随机性决定的

- 一个应用中存在一些该类特质的因素，比如频繁出现堵塞呼叫(blocking call)，不妨考虑包装为事件，让堵塞呼叫暂时脱离主进程，事成之后再利用事件机制申请重返原进程，这种 __异步事件__ 式将连续的进程中 __独立且耗时__ 的部分抽取出来，从而减少随机因素造成的资源浪费，提高系统的 __性能和可伸缩性__

- __独立__ 是异步的前提，__耗时__ 是异步的理由，随机只是副产品，一个独立且耗时的子过程，通常结束时间也是不可预期的。

### 事件驱动式模型
- 三步曲
    - 事件处理器(event handler)或事件监听器(event listener)：负责处理事件，经注册方能在事发时收到通知
    - 注册事件处理器
    - 事件循环(event loop)：负责侦查事件、预处理事件、管理事件队列和分派事件，无事时默默等待，有事时立即响应

    > 许多IDE图形编辑器在程序员点击控件后，能自动生成事件处理器的骨架代码，还注册步骤也免除了

    > 自行设计事件系统时，需要决定采用事件驱动是否合适？如果合适，__如何设计事件机制__？包括事件定义、事件触发、事件侦查、事件转化、事件合并、事件调度、事件传播、事件处理、事件连带(event cascade 即处理过程中又产生新事件)等一系列问题


![prog_paradigm_event_driven](../../pics/prog_paradigm_event_driven.png)

- 典型模型
    - 事件处理器事先在关注的事件源上注册，后者不定期的发表事件对象，经过事件管理器的转化(translate)、合并(coalesce)、排队(enqueue)、分派(dispatch)等集中处理后，事件处理器接收到事件并对其进行相应处理
    - 事件处理器随时可注册或注销事件源，意味着二者之间的关系是 __动态__ 建立和解除的
    - 通过事件机制，事件源与事件处理器之间建立了 __松耦合__ 的多对多关系
    - 事件处理器与事件源是server-client模式，每个服务方与客户方会话是 __异步__ 的


- __发行订阅__ 模式(publish-subscribe pattern)正是 __观察者__ 模式(observer pattern)的别名，一方面可看作简化或退化的事件驱动式，另一方面可看作事件驱动式的核心思想
    - 该模式省略了事件管理器部分，由事件源直接调用事件处理器的接口，简明易用，但威力有限，缺少事件管理、事件连带等机制
    - MVC(Model-View-Controller)架构正是它在架构设计上的一个应用








#第4章   重温范式
=========
每种范式都代表一套独特而有效地解决问题的思想和方法，掌握范式对编程语感的提升：
    - 编程语言的语法、语义等都是从编程范式的树根衍生而出的树叶，把握了这种脉络和节奏，代码才会如音乐般韵律有致
    - 每个范式擅长的问题域不尽相同，只有博闻广知，方可扬长避短，程序才会如行云流水般流畅自然。

## 函数范式-精巧的数学思维
函数式的数学背景是 __λ-演算__(lambda calculus)，也是图灵完备的

### 函数是头等公民

快速排序java版本

<!--language: java-->

    public class Sorter{
        public static<T extends Comparable<? super T>> void qsort(T[] list){
            qsort(list, 0, list.length -1);
        }

        private static<T extends Comparable<? super T>> void qsort(T[] list,
         int low, int high){
            if (low >= high) return;

            int i = low -1, j = high + 1;
            T pivot = list[low];

            for (;;){
                do { ++i; } while (list[i].compareTo(pivot) < 0);
                do { --j; } while (list[j].compareTo(pivot) > 0);

                if (i >= j) break;

                T tmp = list[i]; list[i] = list[j]; list[j] = tmp;
            }

            qsort(list, low, j);
            qsort(list, j + 1, high);
        }
    }

快速排序Haskell版本

<!--language: haskell-->

    qsort :: (Ord a) => [a] -> [a]　　-- 函数声明
    qsort[] = []　　　　　　　　　　　-- 递归终点
    qsort(pivot : rest) =
        -- 对前现的子列递归
        qsort[x| x <- rest, x < pivot]
        ++ [pivot]
        -- 对后面的子列递归
        ++ qsort[x| x <- rest, x >= pivot]

- 上面java代码很难再精简了，但与Haskell相比还是太冗长了，后者省去了所有赋值、迭代的流程控制，只有单纯的递归，反映了典型的函数式特征。
> Hakell函数声明可以省略，但出于可读、性能、调试等原因，最好保留
- 前者须指定计算过程，后者只须指定计算的原则，一个重微观过程，一个重宏观的方向

<!--language: haskell-->

    (filter (< pivot) rest)

- filter是过虑，将列表rest中元素进行筛选，条件是小于基准元素
- `(<pivot)`也是一个函数，函数式一个重要特征：函数是头等公民(first-class citizen)，可作传递参数，可作为表达式的值，可嵌入数据结构，也可与某变量绑定，与普通的基本数据类型毫无二致。这类函数叫 __高阶函数__ (higher-order function)
> callback无非将函数作为参数来传递，本质是将代码当数据来使用，属于高阶函数

C# lambda版本

<!--language: csharp-->

    IEnumerable<T> qsort<T>(IEnmerable<T> list) where T :
    IComparable<T>{
        if (list.count() <=1) return list;
        var pivot = list.First();
        return qsort(list.Where(x=>x.CompareTo(pivot)<0))
            .Concat(list.Where(x=>x.CompareTo(pivot)==0))
            .Concat(qsort(list.Where(x=>x.CompareTo(pivot)>0)));
    }

总体思想还是函数式的

### 函数的无副作用
- 函数式还有一个重要特征：无副作用或尽量减少副作用，一个函数在被调用前后保持程序的状态不变，不会改变非局部变量的值，不会改变传入的参数，也没有IO操作
> 没有副作用的称为纯函数式(purely functional)，如Haskell、SISAL；有副作用的称为非纯函数式(impurely functional)，如Lisp、ML，不过Haskell等语言也可通过monad来实现包括IO在内的副作用

- 什么状态都不变，函数还有什么用？命令式程序比作状态自动机，其运行过程就是不断的修改机器的状态，而函数式程序则是进行 __表达式变化__，一般不会改变变量的值。其实函数式并非完全不改变内存，__只不过改变的是栈内存__(stack)而已，换言之，无副作用函数的作用关键在于其估值结果（返回值）

- 没有副作用的函数易于重构、调试和单元测试；代码有效性与函数顺序无关，方便并发处理和优化处理
> 比如`f(x)*g(y)`，由于无副作用，`f(x)`和`g(y)`估值过程是独立的，估值顺序也不重要，理论上可以并行计算

### 函数的惰性求值

- 另外还可利用惰性求值(lazy evaluation)：上例中如果`f(x)`为零，那么不用计算`g(y)`了

<!--language: bash-->

    grep the BigFile.txt | head
    grep the BigFile.txt > tmpfile; head tmpfile

- 第一行是unix管道(pipe)，grep的输出是head的输入，__后者不用等到前者执行完毕才启动，只要后者获得足够数据，前者便停止执__。如果没有管道只能使用第二行代码了
- 类似的，通常计算`f(g(x))`的值，须计算完`g(x)`后才能将所有值代入函数f，有了惰性求值机制，__`g(x)`的计算完全由函数`f`的需求来驱动__，避免做无用功，此为惰性之所在
- 惰性求值不仅能节省有限的时间，还能超越无限的时间`g(x)`甚至可以永不退出，从而可能产生无穷的输出结果集供函数`f`使用
- 没有副作用的函数是引用透明的(referntial transparency)，即一个表达式随时可以用它的值来替换，因为一个表达式同样的输入一定是相同的输出

## 逻辑范式-当算法失去了控制
算法=逻辑+控制，其中逻辑是算法的核心，控制主要用于改进算法的效率

快速排序Prolog版本

<!--language: prolog-->

    /* 定义划分法 */
    partition(_,[],[],[]).    /* 划分递归终点 */
    /* 比基准小的归入Small */
    partition(Pivot, [X|Rest], [X|Samll], Big) :-
       X < Pivot, partition(Pivot,Rest,Samll,Big).
    /* 比基准大的归入Big */
    partition(Pivot, [X|Rest], Samll, [X|Big]) :-
       X >= Pivot, partition(Pivot,Rest,Samll,Big).

    /* 定义排序法 */
    qsort([],[]).             /* 排序递归终点 */
    qsort([Pivot|Rest],Sorted) :-
    partition(Pivot,Rest,Samll,Big),  /* 按基准划分子列 */
          qsort(Samll,SortedSamll),   /* 对前面的子列递归 */
          qsort(Big,SortedBig),       /* 对后面的子列递归 */
          /* 子列合并 */
          append(SortedSamll,[Pivot|SortedBig],Sorted).

- Prolog代码由一系列 __事实__(fact)、__规则__(rule)和 __查询__(query)语句组成的，事实与规则是公理，查询就是待证的定理
- 大写字母或下划线开头的标识符是变量，其他的是常量或函数；`:-`等价于if，逗号`,`等价于and
- `bachelor(X) :- unmarried(X), male(X).`如果一个人未婚且为男士，就是光棍
- 过程式代码在描述规则时，会有许多嵌套与顺序要求，如果增加规则时，许多代码得改写，而Prolog只需 __引入新的规则和事实即可，不会影响原来的代码__。
- 逻辑式 __没有明显的输入、输出之分__，能倒过来去查询
- 逻辑式编程模拟人类的逻辑思维，在机器证明、专家系统、自然语言处理、博弈等人工智能领域，以及知识管理、智能决策分析方面大显身手，适合 __基于规则__(rule-based)，而不是基于状态(state-based)的应用
> Prolog cafe和P#分别将Prolog转化为java和C#代码

## 汇总范式
### 设计模式vs编程范式
- 设计模式一般针对某一特定场景的问题，而编程范式针对的是广泛得多的问题领域，通常有一整套的思想和理论体系，具有全局性、系统性和渗透性
- 同样的思想用在 __整体结构设计__ 上，则称为架构模式；用在 __局部模块的细节实现__ 上，则称设计模式；用在 __引导编程实践__ 上，则称为编程范式。
- 设计模式是遵循设计原则的一些具体技巧，以保证代码的可维护性、扩展性和可重用性为目的，它重在设计，对语言一般没有要求。但编程范式则不同，对语言往往有专门的要求，通常会所某某范式的语言，事实上，语言本来就是围绕其所倡导的核心范式来设计的。

### 常见的编程范式

![prog_paradigm_lang1](../../pics/prog_paradigm_lang1.png)

![prog_paradigm_lang2](../../pics/prog_paradigm_lang2.png)

![prog_paradigm_lang3](../../pics/prog_paradigm_lang3.png)

![prog_paradigm_lang4](../../pics/prog_paradigm_lang4.png)

- 一种编程范式之所以能独树一帜，__关键__ 在于它 __突破__ 了原有的编程方式的某些限制，带来革命性的新思维和新方法，进一步解放了程序员的劳动力，这便是范式的核心价值所在

## 情景编程

- 可以这么理解 __闭包__：所谓包，指函数与其周围的环境变量捆绑打包；所谓闭，指这些变量是封闭的，只能为该函数所专用

### 规则引擎
- 搜集餐馆的菜式、顾客口味、忌讳，以及各种菜与口味、忌讳之间的关系等一系列事实和规则，用 __规则语言__(Rule Language)来描述，通过 __规则引擎__(Rule Engine)来导出符合顾客需求的菜肴。
- 将业务规则与应用程序分离、将知识表示与逻辑实现分离，是SoC原理的一种应用，同时也是一种逻辑式编程
- 与Java兼容的Jess、Drools、JLisa、JRules等，Sun还发布了Javax.rules API以统一对各类引擎的访问接口。.Net平台上也有业务规则引擎，Microsoft BUsiness Rule Engine、WF Rules均提供了业务规则引擎。
- 上述规则引擎除WF Rules多是基于Rete算法(一种 __模式匹配__ 算法，用于实现规则生成系统 production rule system)，主要采用 __数据驱动__(data-driven)的正向推理(forward chaining)法，而Prolog引擎采用 __目标驱动__(goal-driven)的逆向推理(backward chaining)法。前者自底向上，利用推理规则从已有的事实数据推出更多的数据，直到达成目标；后者正好相反，自顶向下，从目标出发寻找满足结论的事实。




#第5章  语言小谈
=========

## 数据类型-规则与变通

![prog_paradigm_languages.png](../../pics/prog_paradigm_languages.png)


### 动态语言vs动态类型语言
- 动态语言不一定是动态类型语言，如Scala是动态语言，却是静态类型的；动态类型语言也不一定是动态语言，如VB支持动态类型，却是静态语言。
- 动态类型语言的动态体现在 __类型__ 上，动态语言的动态则体现在 __结构和功能__ 上，能在运行中增加或改变数据结构、函数定义、对象行为或指令流程等

### 数据类型两个要素
- __允许取值的集合__
- __允许参与的运算__
- 意义在于，限定一个变量的数据类型，就意味着限制了该变量的取值范围和所参与的运算，从一定程度上保证了代码的 __安全性__；用户自定义的数据类型，如结构、类、接口，赋予数据以逻辑内涵，提高了代码的 __抽象性__。
- 数据类型即有针对机器的 __物理意义__，又有针对人的 __逻辑意义__，前者用于底层的内存分配和数值运算等，后者用于表达高层的逻辑概念。

### 动态类型语言vs静态类型语言
- 动态类型语言(dynamic typing language)指类型检查发生在 __运行期间__(run-time)的语言
- 静态类型语言(static typing language)指类型检查发生在 __运行之前__ 的语言，不仅仅指 __编译期间__ 检查，否则容易误解为静态类型语言一定是编译型语言(一般情况下是)
- 静态类型语言一般 __需要__ 变量声明，而动态类型语言则 __不需要__，但一些静态类型语言有时也不需要，如ML、Haskell之类的函数式语言(以及C#3.0以后)，编译器可以通过上下文来进行 __类型推断__(type inference)
- 静态类型检查类似“疑罪从有”的推定，动态类型检查类似“疑罪从无”的推定

> 动态类型语言因不需要类型声明，参数、返回值等类型可以不需要import它们的类型（或者说本来类型就是动态的，也无从引入），而静态语言则必须引入依赖

### 鸭子类型
- 动态类型语言天然具有 __泛型__(generic)特征，具有一种被称为 __鸭子类型__(duck typing)的形式

<!--language: !ruby-->

    class Duck
        def shout;puts 'ga-ga-ga';end
        def swim;puts 'ya-swim';end
    end

    class Frog
        def shout;puts 'gua-gua-gua';end
        def swim;puts 'wa-swim';end
    end

    def shout_and_swim(duck)
        duck.shout
        duck.swim
    end

    shout_and_swim(Duck.new)
    shout_and_swim(Frog.new)

- 在Smalltalk,Python,Ruby等动态类型的OOP语言中，只要一个类型具有`shout`和`swim`的方法，就可为`shout_and_swim`所接受，这在C++,Java,C#等静态类型语言中是不可能的，除非`Duck`和`Frog`在同一继承树上，或均显式实现了一个包含`shout`和`swim`的公用接口

- C++还可以用模板实现类似功能，并不须引入继承关系，但下面的代码却无能为力

<!--language: !ruby-->

    class Cock
        def shout;puts 'wo-wo-wo';end
    end

    class Fish
        def swim;puts 'fish-swim';end
    end

    def shout_or_swim(duck, flag)
        flag ? duck.shout : duck.swim
    end

    shout_or_swim(Cock.new, true)
    shout_or_swim(Fish.new, false)

- 鸡没有`swim`方法，鱼没有`shout`方法，若采用C++模板，`shout_or_swim`是无法通过编译的，但支持Duck类型的语言中，只要在 __运行期间不让__ 鸡`swim`就平安无事
- Duck类型的哲学是：名义不重要，重要的是能力。这种 __非继承性多态__ 为软件 __重用__ 开启了新窗口
    - 类型的接口组织是隐性的，使用者必须要比普通interface更小心，以避免误用
    - 维护者也须更小心，以避免破坏客户代码

### 静态类型语言好处
虽然动态类型语言很灵活，但静态类型语言也有它的好处：

- 由于在运行之前进行了类型检查，一方面代码的 __可靠性__ 增强，符合“发现错误要尽早”原则；另一方面编译器有可能籍此 __优化机器代码__ 以提高 __运行效率__，同时相比动态类型语言，节省了运行期的耗费在类型检查上的时间和空间
- 变量类型的声明彰显了编程者的意图，有 __辅助文档__ 的功效

### 动态类型语言vs弱类型语言
它们常被混为一谈，但类型的动静与强弱完全是正交的两个概念

- 静态类型语言中，有强类型的Java，也有弱类型的C
- 动态类型语言中，有强类型的Python,Smalltalk，也有弱类型的JavaCcript
- 语言的动静以类型的 __绑定时间__ 来划分，而强弱以类型的 __约束强度__ 来划分
- 弱类型语言(weakly-typed language)允许一种类型的值 __隐式转化__ 为另一种类型
    - `1+"2"`在vb中等于3，在js中等于"12"，在C中则为一个不定的整数(第2个字符串作为地址来运算)
    - 隐式转换也称强制转换(coercion)，而显式的转换叫铸型(cast)
- 强类型语言(strongly-typed language)着意贯彻类型控制，为保障数据的完整性和代码的安全有效性，一般不允许隐式类型转换，如果一定需要类型转换，必须是 __显性转换__，一般通过铸型(cast)来完成。
    - 但许多强类型语言对于宽转换(widening conversion)还是允许隐性的，如int可自动转换为float

## 动态语言-脚本语言
### 脚本语言
- "A script is what you give the actors, a program is what you give the aduience"，程序是为终端用户服务的，而脚本是为程序员服务的。最常见的形式是shell script，用于系统程序的调度，是系统管理员的必备武器，后发展到用于应用程序的调度、连接、调试等，成为 __粘合__(glue)语言

- 脚本语言主要用于整合其他程序，本身并不占用太多资源，同时逻辑也不太复杂，更注重简洁、实用，语法求不那么严格，性能上要求也不高。

- 除了命令行程序外，脚本语言也在其他应用，如图形界面应用、多媒化、网络应用等：Perl用于网络服务器端的CGI编程；PHP专为动态网页而设计；JavaScript则是网页设计人员的语言

### 动态语言vs脚本语言
- 但并不是所有脚本语言都是动态语言，比如Bash，另一方面，也不是所有动态语言就是为脚本服务的，如Lisp。脚本语言以语言实际用途为标志，动态语言以语言的语法特征为标志。
- 脚本语言如果不再局限于命令行的粘合工具，从专用语言发展为通用语言，并能胜任复杂的应用开发，或更有资格归为动态语言
- 脚本语言一般 __面向字符__ 而非数值的，因为字符是最通用的接口，正好发挥其粘合作用，而数值运算对性能要求较高，多由 __核心程序__ 来完成。
- 动态语言能在运行中增加或改变数据结构、函数定义、对象行为或指令流程等。
    - 静态语言虽然也可能实现同样效果，但不方便也不自然，如通过设计模式(装饰者、职责链、状态模式等)为赋予静态语言一定动态特征
- 动态语言认为：__优化人的时间而不是机器的时间__，硬件相对于人件，一直在贬值。






#第6章   语言简评
========
## 系统语言-权力的双刃剑
- 它们的理念是：优化机器的时间而不是人的时间，优化机器的记忆而不是人的记忆，假设编译器是愚蠢的而程序员是聪明的，因此赋予程序员更多的权利、义务与责任
- C虽然没有直接支持OOP，但经过设计还是能实现OOP，以及泛型的
- C++开发效率相比Java与C#差距主要两个方面：标准库不够完善，须手工回收垃圾，对于后者，更好的办法是遵循`RAII`惯用法，通过智能指针(smart pointer)来解决内存释放问题（资源获取即初始化，资源释放即终结化），用户代码不再直接管理资源，只须控制相应的对象即可，而且还是异常安全(exception-safe)。
- Java不像C++，能在栈上创建对象（C#的struct可以，但class是不行的），栈对象有一个特点，超出其作用范围，但自动释放内存，在此之前会调用析构函数，后者继而调用释放资源的代码。
    - 由于不支持此，Java在处理文件、数据库连接等，不能被垃圾回收时，只能频繁使用try/catch/finally来包裹close的代码，C#还好一些，专门提供了using来简化释放资源的代码
- 由于自动垃圾回收的不定时性，在时间和空间上会有过多开销

## 平台语言
- Java目的是让一种语言在多种平台上运行，而.NET的目的是让多种语言在一种平台上运行
- Java与C#之所以能独立于硬件和操作系统平台，主要自带了 __运行环境__ 平台，Java运行于Java Virtual Machine，C#则运行于以Common Language Runtime为核心的.Net平台
- 它们区别于C++的共同之处：
    - 均编译成与机器无关的托管码(managed code)或字节码(bytecode)，运行于虚拟机(virtual machine)之上
    - 禁用或限用指针，并支持自动垃圾回收，当然C#留了一手，支持unsafe的代码包含指针操作
- Java通过JNI调用C/C++等程序，而C#通过P/Invoke访问系统API，加之保留了指针操作，用于系统编程更加方便
- C#重新捡起了C++中被Java抛弃的一些特征：
    - 值类型(value type)
    - 除了按值传递(pass-by-value)外，还可按引用传递(pass-by-reference);
    - 支持操作符重载(operator overloading)
    - 保留指针和指针运算
    - 所有方法默认是非虚的(non-virtual)
    - 访问权限默认是私有的
    - 支持预处理指令(preprocessor directive)
    - C#4.0引入可选参数(optional parameter)
