

第1章　用Pythonic方式来思考  

第1条：确认自己所用的Python版本 

第2条：遵循PEP 8风格指南  

第3条：了解bytes、str与unicode的区别  

第4条：用辅助函数来取代复杂的表达式 

第5条：了解切割序列的办法  

第6条：在单次切片操作内，不要同时指定start、end和stride  

第7条：用列表推导来取代map和filter  

第8条：不要使用含有两个以上表达式的列表推导  

第9条：用生成器表达式来改写数据量较大的列表推导  

第10条：尽量用enumerate取代range  

第11条：用zip函数同时遍历两个迭代器  

第12条：不要在for和while循环后面写else块  

第13条：合理利用try/except/else/finally结构中的每个代码块  

第2章　函数  

第14条：尽量用异常来表示特殊情况，而不要返回None  

第15条：了解如何在闭包里使用外围作用域中的变量  

第16条：考虑用生成器来改写直接返回列表的函数  

第17条：在参数上面迭代时，要多加小心  

第18条：用数量可变的位置参数减少视觉杂讯  

第19条：用关键字参数来表达可选的行为  

第20条：用None和文档字符串来描述具有动态默认值的参数  

第21条：用只能以关键字形式指定的参数来确保代码明晰  

第3章　类与继承  

第22条：尽量用辅助类来维护程序的状态，而不要用字典和元组  

第23条：简单的接口应该接受函数，而不是类的实例  

第24条：以@classmethod形式的多态去通用地构建对象  

第25条：用super初始化父类  

第26条：只在使用Mix-in组件制作工具类时进行多重继承  

第27条：多用public属性，少用private属性  

第28条：继承collections.abc以实现自定义的容器类型  

第4章　元类及属性  

第29条：用纯属性取代get和set方法  

第30条：考虑用@property来代替属性重构  

第31条：用描述符来改写需要复用的@property方法  

第32条：用__getattr__、__getattribute__和__setattr__实现按需生成的属性  

第33条：用元类来验证子类 

第34条：用元类来注册子类 

第35条：用元类来注解类的属性 

第5章　并发及并行 

第36条：用subprocess模块来管理子进程 

第37条：可以用线程来执行阻塞式I/O，但不要用它做平行计算 

第38条：在线程中使用Lock来防止数据竞争 

第39条：用Queue来协调各线程之间的工作 

第40条：考虑用协程来并发地运行多个函数 

第41条：考虑用concurrent.futures来实现真正的平行计算 

第6章　内置模块 

第42条：用functools.wraps定义函数修饰器 

第43条：考虑以contextlib和with语句来改写可复用的try/finally代码 

第44条：用copyreg实现可靠的pickle操作 

第45条：应该用datetime模块来处理本地时间，而不是用time模块 

第46条：使用内置算法与数据结构 

第47条：在重视精确度的场合，应该使用decimal 

第48条：学会安装由Python开发者社区所构建的模块 

第7章　协作开发 

第49条：为每个函数、类和模块编写文档字符串 

第50条：用包来安排模块，并提供稳固的API 

第51条：为自编的模块定义根异常，以便将调用者与API相隔离 

第52条：用适当的方式打破循环依赖关系 

第53条：用虚拟环境隔离项目，并重建其依赖关系 

第8章　部署 

第54条：考虑用模块级别的代码来配置不同的部署环境 

第55条：通过repr字符串来输出调试信息 

第56条：用unittest来测试全部代码 

第57条：考虑用pdb实现交互调试 

第58条：先分析性能，然后再优化 

第59条：用tracemalloc来掌握内存的使用及泄漏情况


