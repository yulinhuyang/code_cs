
校招总结：https://blog.csdn.net/qq_39503189/article/details/104718499

拓跋阿秀C++: https://www.zhihu.com/question/442382012/answer/2179390910

# 秋招总结------C++面试题总结一

本人2020届毕业，在学校搞机械，没有任何编程经验，没有项目，全靠死记用背这些C++知识点，在秋招中拿到5,6个互联网公司的开发岗位，虽然没有大厂，但是已经比搞机械强多了，最高offer 26W。现将自己所学的东西总结如下，希望能帮助到更多的人。

### 1. 引用和指针的区别

1. **指针是一个实体**，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。
2. 引用在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。（注：引用的值不能为NULL）
3. 有**多级指针**，但是没有多级引用，只能有一级引用。
4. 指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值加1）
5. **sizeof** 引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是**指针本身的大小。**
6. 引用访问一个变量是**直接**访问，而指针访问一个变量是间接访问。
7. 使用指针前最好做类型检查，防止野指针的出现；
8. **引用底层**是通过**指针**实现的；
9. 作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址。

### 2. C++中的值传递指针参数传递和引用参数传递

1.**值传递**是最常规的C语言传参方式。 
形参是实参的拷贝，改变形参的值并不会影响外部实参的值。 
从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，不能传出。 
当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。

2.指针参数传递本质上是**值传递**，它所传递的是一个**地址值**。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在**栈中开辟内存空间**以存放由主调函数传递进来的实参值，从而形成了**实参的一个副本**（替身）。 值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。

3.引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的**实参变量的地址**。被调函数对形参（本体）的任何操作都被处理成**间接寻址**，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。

### 3.  形参与实参的区别？

1.形参变量只有在**被调用时才分配内存单元**，在调用结束时，即刻释放所分配的内存单元。因此，**形参只有在函数内部有效**。 函数调用结束返回主调函数后则不能再使用该形参变量。
2.实参可以是**常量、变量、表达式、函数**等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 **因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量**。
3.实参和形参在**数量上，类型上，顺序上**应严格一致， 否则会发生“类型不匹配”的错误。
4.**函数调用中发生的数据传送是单向的**。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。
5.当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。

### 4. static的用法和作用？
1.先来介绍它的第一条也是最重要的一条：**隐藏**。（static函数，static变量均可）当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。
2. static的第二个作用是**保持变量内容的持久**。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：**全局变量和static变量**，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。
3. static的第三个作用是**默认初始化为0**（static变量）。

### 5. static的第四个作用：C++中的类成员声明static
1.函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
2.在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；
3.在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；
4.在类中的**static成员变量属于整个类所拥有**，对类的所有对象只有一份拷贝；
5.在类中的**static成员函数属于整个类所拥有**，这个函数不接收this指针，因而只能访问类的static成员变量。

类内：

1.static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以**static修饰的变量要在类外初始化**；
2.由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员；
3.**static成员函数不能被virtual修饰**，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this->vptr->ctable->virtual function

### 6. 静态变量什么时候初始化

1.**初始化只有一次，但是可以多次赋值**，在主程序之前，编译器已经为其分配好了内存。
2.静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，**编译器已经为其分配好了内存**，但在C和C++中静态局部变量的初始化节点又有点不太一样。在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。
3.而在C++中，**初始化时在执行相关代码时才会进行初始化**，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在C++中是可以使用变量对静态局部变量进行初始化的。

### 7.  const 的作用

1. **阻止一个变量被改变**，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
2. 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
3. 在一个函数声明中，**const可以修饰形参**，表明它是一个输入参数，在函数内部不能改变其值；
4. 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量，**类的常对象只能访问类的常成员函数**；
5. 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。
6. const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；
7. 非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；
8. 一个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。因此const对象只能调用const成员函数。
9. const类型变量可以通过类型转换符**const_cast**将const类型转换为非const类型；
10. **const类型变量必须定义的时候进行初始化**，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化；
11.对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响。但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，只有引用传递和指针传递可以用是否加const来重载。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。

### 8.const成员函数的理解和应用

①const Stock &amp; Stock::topval   (②const Stock &amp; s)   ③const
1. 处const：确保返回的Stock对象在以后的使用中不能被修改   
2. 处const：确保此方法不修改传递的参数 S
3. 处const：保证此方法不修改调用它的对象，**const对象只能调用const成员函数,不能调用非const函数**

### 9. 指针和const的用法

当const修饰指针时，由于const的位置不同，它的修饰对象会有所不同。

1. int  * const p2中const修饰p2的值,所以理解为p2的值不可以改变，即p2只能指向固定的一个变量地址，但可以通过*p2读写这个变量的值。顶层指针表示指针本身是一个常量。
2. int const * p1或者const int * p1两种情况中const修饰* p1，所以理解为* p1的值不可以改变，即不可以给*p1赋值改变p1指向变量的值，但可以通过给p赋值不同的地址改变这个指针指向。底层指针表示指针所指向的变量是一个常量。
3. int const * const p;  *p指向的值和p指向的地址都不能改变。

### 10. mutable
1. 如果需要在const成员方法中**修改一个成员变量的值**，那么需要将这个成员变量修饰为mutable。即用**mutable修饰的成员变量不受const成员方法的限**制;
2. 可以认为mutable的变量是类的辅助状态，但是只是起到类的一些方面表述的功能，修改他的内容我们可以认为对象的状态本身并没有改变的。实际上由于const_cast的存在，这个概念很多时候用处不是很到了。

### 11. extern用法

1. extern修饰变量的声明： 如果文件**a.c需要引用b.c中变量int v**，就可以在a.c中声明**extern int v**，然后就可以引用变量v。
2. extern修饰函数的声明： 如果文件a.c需要引用b.c中的函数，比如在b.c中原型是int fun(int mu)，那么就可以在a.c中声明extern int fun（int mu），然后就能使用fun来做任何事情。就像变量的声明一样，extern int fun（int mu）可以放在a.c中任何地方，而不一定非要放在a.c的文件作用域的范围中。
3. extern修饰符可用于指示C或者C＋＋函数的调用规范。   比如在C＋＋中调用C库函数，就需要在C＋＋程序中用**extern “C”**声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同。
### 12. 深拷贝与浅拷贝
1.**浅复制** —-只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，**浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。**

2.**深复制** —-在计算机中开辟了一块新的内存地址用于存放复制的对象。
<img alt="" height="691" src="https://img-blog.csdnimg.cn/20200308100741817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTAzMTg5,size_16,color_FFFFFF,t_70" width="850">

### 13. C++模板是什么，底层怎么实现的
1.编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过**具体类型**产生不同的函数；**编译器会对函数模板进行两次编译**：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。

2.这是因为函数模板要**被实例化后才能成为真正的函数**，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中**只有声明，没有定义**，那编译器无法实例化该模板，最终导致链接错误。

### 14. C语言struct和C++struct区别

1. C语言中：struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义，（C++中的struct能继承，能实现多态）。
2. C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以**封装数据却不可以隐藏数据，而且成员不可以是函数**。
3. **C++中，struct的成员默认访问说明符为public**（为了与C兼容），class中的默认访问限定符为private，struct增加了访问权限，且可以和类一样有成员函数。
4. struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名。

### 15.  虚函数可以声明为inline吗

1.虚函数用于**实现运行时的多态**，或者称为晚绑定或动态绑定。而**内联函数用于提高效率**。内联函数的原理是，在编译期间，对调用内联函数的地方的代码替换成函数代码。内联函数对于程序中需要**频繁使用**和调用的**小函数**非常有用。
2.虚函数要求在运行时进行类型确定，而内敛函数要求在编译期完成相关的函数替换；

### 16. 类成员初始化方构造函数的执行顺序 ？为什么用成员初始化列表会快一些？

1.赋值初始化，通过在函数体内进行赋值初始化；
列表初始化，在冒号后使用初始化列表进行初始化。这两种方式的主要区别在于： 
**函数体中初始化**：是在所有的数据成员被分配内存空间后才进行的。  
**列表初始化**：是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。

2.一个派生类构造函数的执行顺序如下：
虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。 
基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。  
类类型的成员对象的构造函数（按照初始化顺序）                                                                                                                     
派生类自己的构造函数。

3.方法一是在构造函数当中做赋值的操作，而方法二是做纯粹的初始化操作。我们都知道，**C++的赋值操作是会产生临时对象的。临时对象的出现会降低程序的效率。**

### 17. 成员列表初始化

1.必须使用成员初始化的四种情况：
当初始化一个引用成员时；
当初始化一个常量成员时；
当调用一个基类的构造函数，而它拥有一组参数时；
当调用一个成员类的构造函数，而它拥有一组参数时；

2. 成员初始化列表做了什么：     
编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前； 
list中的项目顺序是**由类中的成员声明顺序决**定的，不是由初始化列表的顺序决定的；

### 18. 构造函数为什么不能为虚函数？析构函数为什么要虚函数？
1.构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。
2.直接的讲，C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。

### 19. 析构函数的作用，如何起作用？

1.构造函数只是起**初始化值**的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。规则，只要你一实例化对象，系统自动回调用一个，就是你不写，编译器也自动调用一次。
2.析构函数与的作用相反，用于撤销对象的一些特殊任务处理，可以是**释放对象分配的内存空间**；特点：析构函数与构造函数同名，但该函数前面加~。 **析构函数没有参数，也没有返回值，而且不能重载**，在一个类中只能有一个析构函数。 当撤销对象时，编译器也会自动调用析构函数。 每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。

### 20. 构造函数和析构函数可以调用虚函数吗，为什么

1.在C++中，**提倡不在构造函数和析构函数中调用虚函数**；
2.构造函数和析构函数调用虚函数时都**不使用动态联编**，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；
3.因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；
4.析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。


# 秋招总结------C++面试题总结二

### 1.构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？

- 构造函数顺序
1. 基类构造函数。如果有多个基类，则构造函数的调用顺序是**某类在类派生表中出现的顺序**，而不是它们在成员初始化表中的顺序。
2. 成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是**对象在类中被声明的顺序**，而不是它们出现在成员初始化表中的顺序。
3. 派生类构造函数。

- 析构函数顺序
1. 调用派生类的析构函数；
2. 调用成员类对象的析构函数；
3. 调用基类的析构函数。

### 2.虚析构函数的作用，父类的析构函数是否要设置为虚函数？

1.C++中基类采用**virtual虚析构函数**是为了防止内存泄漏。具体地说，如果**派生类中申请了内存空间**，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。
2.纯虚析构函数一定得定义，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。因此，缺乏任何一个基类析构函数的定义，就会导致链接失败。因此，最好不要把虚析构函数定义为纯虚析构函数。

### 3.构造函数和析构函数可以调用虚函数吗？

1.在**构造函数和析构函数中最好不要调用虚函数**；
2.构造函数或者析构函数调用虚函数并不会发挥虚函数动态绑定的特性，跟普通函数没区别；
3.即使构造函数或者析构函数如果能成功调用虚函数， 程序的运行结果也是不可控的。

### 4.构造函数析构函数可否抛出异常

1.C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。
2.用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源；
3.如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束；
4.如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。

### 5. 类如何实现只能静态分配和只能动态分配

1. 前者是把**new、delete运算符重载为private属性**。后者是把构造、析构函数设为**protected属性**，再用子类来动态创建

- 建立类的对象有两种方式：
1. 静态建立，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；
2. 动态建立，**A *p = new A();**动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；
3. 只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上。可以将new运算符设为私有。

### 6. 如果想将某个类用作基类，为什么该类必须定义而非声明？

1.派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。

### 7. 什么情况会自动生成默认构造函数？

1.带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。不过这个合成操作只有在构造函数真正被需要的时候才会发生；如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；
2.带有默认构造函数的基类，如果一个没有任务构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；
3.带有一个虚函数的类
4.带有一个虚基类的类

- 合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。

### 8.什么是类的继承？

- 类与类之间的关系
1. **has-A**包含关系，用以描述一个类由多个部件类构成，实现has-A关系用类的成员属性表示，即一个类的成员属性是另一个已经定义好的类；
2. **use-A**，一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现；
3. **is-A**，继承关系，关系具有传递性；

- 继承的相关概念

1. 所谓的继承就是**一个类继承了另一个类的属性和方法**，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类称为父类或者基类；

- 继承的特点

- 子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当做父类对象使用；
1. 继承中的访问控制  public、protected、private
2. 继承中的构造和析构函数
3. 继承中的兼容性原则

### 9. 什么是组合？

1.一个**类里面的数据成员是另一个类的对象**，即内嵌其他类的对象作为自己的成员；创建组合类的对象：首先创建各个内嵌对象，难点在于构造函数的设计。创建对象时既要对基本类型的成员进行初始化，又要对内嵌对象进行初始化。
2.创建组合类对象，构造函数的执行顺序：**先调用内嵌对象的构造函数**，然后按照**内嵌对象成员在组合类中的定义顺序**，与组合类构造函数的初始化列表顺序无关。然后执行组合类构造函数的函数体，析构函数调用顺序相反。

### 10 抽象基类为什么不能创建对象？
- 抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。

（1）抽象类的定义：称带有纯虚函数的类为抽象类。 
（2）抽象类的作用：抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以抽象类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。 
（3）使用抽象类时注意： 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。

抽象类是不能定义对象的。一个纯虚函数不需要（但是可以）被定义。 

### 11.纯虚函数

纯虚函数定义：纯虚函数是一种特殊的虚函数，它的一般格式如下：
```cpp
class <类名>
{
virtual <类型><函数名>(<参数表>)=0;
…
};
```

在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。 　　

纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。

纯虚函数引入原因：　 

1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 
2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔 雀等子类，但动物本身生成对象明显不合常理。 　　

为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;）。若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。同时含有纯虚函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。 
例如，绘画程序中，shape作为一个基类可以派生出圆形、矩形、正方形、梯形等， 如果我要求面积总和的话，那么会可以使用一个 shape * 的数组，只要依次调用派生类的area()函数了。如果不用接口就没法定义成数组，因为既可以是circle ,也可以是square ,而且以后还可能加上rectangle，等等.

三、相似概念 

1、多态性

指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。

a.编译时多态性：通过重载函数实现 
b.运行时多态性：通过虚函数实现。 

2、虚函数 　　

虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态重载。 

3、抽象类 　　

包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。

### 12 类什么时候会析构？

1. 对象生命周期结束，被销毁时；
2. delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；
3. 对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。

### 13 为什么友元函数必须在类内部声明？

1. 因为编译器必须能够读取这个结构的声明以理解这个数据类型的大、行为等方面的所有规则。有一条规则在任何关系中都很重要，那就是谁可以访问我的私有部分。

### 14. 介绍一下C++里面的多态？

1.静态多态（重载，模板）:是在编译的时候，就确定调用函数的类型。

2.动态多态（覆盖，虚函数实现）:在运行的时候，才确定调用的是哪个函数，动态绑定。运行基类指针指向派生类的对象，并调用派生类的函数。

虚函数实现原理：虚函数表和虚函数指针。

纯虚函数： virtual int fun() = 0;

函数的运行版本由实参决定，在运行时选择函数的版本，所以动态绑定又称为运行时绑定。

当编译器遇到一个模板定义时，它并不生成代码。只有当实例化出模板的一个特定版本时，编译器才会生成代码。

### 15. 继承机制中对象之间如何转换？指针和引用之间如何转换？

1. 向上类型转换：将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。

2. 向下类型转换：将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI技术，用dynamic_cast  进行向下类型转换。

### 16.  组合与继承优缺点？

一：继承

继承是Is a 的关系，比如说Student继承Person,则说明Student is a Person。继承的优点是子类可以重写父类的方法来方便地实现对父类的**扩展。**

继承的缺点有以下几点：

①：父类的内部细节对子类是可见的。

②：子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。

③：如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。

二：组合

组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。

组合指的是，在一个类中以另外一个类的对象（也就是实例）作为数据属性，称为类的组合也就是说：一个类的属性是另一个类的对象，就是组合。

组合的优点：

①：当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。

②：当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。

③：当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。

组合的缺点：①：容易产生过多的对象。②：为了能组合多个对象，必须仔细对接口进行定义。

### 17. 移动构造函数

1. 我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；

2. 拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a-&gt;value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a-&gt;value指向的空间；

3. 移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。

### 18. C语言的编译链接过程？

**源代码－－>预处理－－>编译－－>优化－－>汇编－－>链接-->可执行文件**

1. **预处理**：读取c源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理。包括宏定义替换、条件编译指令、头文件包含指令、特殊符号。 预编译程序所完成的基本上是对源程序的“替代”工作。经过此种替代，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。i预处理后的c文件，.ii预处理后的C++文件。

2. **编译阶段**：编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。.s文件

3. **汇编过程**：汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。.o目标文件

4. **链接阶段**：链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够诶操作系统装入执行的统一整体。

### 19. 函数指针？

1. 什么是函数指针? 

- 函数指针指向的是特殊的数据类型，函数的类型是由其返回的数据类型和其参数列表共同决定的，而函数的名称则不是其类型的一部分。

- 一个具体函数的名字，如果后面不跟调用符号(即括号)，则该名字就是该函数的指针(注意：大部分情况下，可以这么认为，但这种说法并不很严格)。

2.函数指针的声明方法

int (*pf)(const int&, const int&); (1)

上面的pf就是一个函数指针，指向所有返回类型为int，并带有两个const int&amp;参数的函数。注意*pf两边的括号是必须的，否则上面的定义就变成了：

int *pf(const int&, const int&); (2)

而这声明了一个函数pf，其返回类型为int *， 带有两个const int&amp;参数。

3.为什么有函数指针

函数与数据项相似，函数也有地址。我们希望在同一个函数中通过使用相同的形参在不同的时间使用产生不同的效果。

4.一个函数名就是一个指针，它指向函数的代码。一个函数地址是该函数的进入点，也就是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数；

5.两种方法赋值：指针名 = 函数名；  指针名 = &amp;函数名

### 20. c/c++的内存分配，详细说一下栈、堆、静态存储区？

1.栈区（stack）由编译器自动分配释放，存放函数的参数值，局部变量的值等其操作方式类似于数据结构中的栈。
2.**堆区（heap）** —  一般由程序员分配释放，若程序员不释放，程序结束时可能由OS（操作系统）回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。  
3.**全局区（静态区）**（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。  
4.**文字常量区**  —常量字符串就是放在这里的。程序结束后由系统释放。
5.**程序代码区**  —存放函数体的二进制代码。


# 秋招总结------C++面试题总结三

### 1. 说说你对c和c++的看法，c和c++的区别？

1. 第一点就应该想到C是面向过程的语言，而C++是面向对象的语言，一般简历上第一条都是熟悉C/C++基本语法，了解C++面向对象思想，那么，请问什么是面向对象？
2. C和C++**动态管理内存的方法不一样**，C是使用malloc/free函数，而C++除此之外还有new/delete关键字；（关于malooc/free与new/delete的不同又可以说一大堆，最后的扩展_1部分列出十大区别）；
3. 接下来就不得不谈到**C中的struct和C++的类**，C++的类是C所没有的，但是C中的struct是可以在C++中正常使用的，并且C++对struct进行了进一步的扩展，使struct在C++中可以和class一样当做类使用，而唯一和class不同的地方在于struct的成员默认访问修饰符是public,而class默认的是private;
4. **C++支持函数重载，而C不支持函数重载**，而C++支持重载的依仗就在于C++的名字修饰与C不同，例如在C++中函数int fun(int ,int)经过名字修饰之后变为 _fun_int_int ,而C是  _fun，一般是这样的，所以C++才会支持不同的参数调用不同的函数；
5. **C++中有引用，而C没有**；这样就不得不提一下引用和指针的区别（文后扩展_2）;
6. 当然还有C++全部变量的默认链接属性是外链接，而C是内连接；
7. C 中用const修饰的变量不可以用在定义数组时的大小，但是C++用const修饰的变量可以（如果不进行&amp;,解引用的操作的话，是存放在符号表的，不开辟内存）；

### 2. 堆与栈的区别？

1. **管理方式**：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。 
2. **空间大小**：一般来讲在32位系统下，**堆内存可以达到4G的空间**，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，**默认的栈空间大小是1M**（好像是，记不清楚了）。当然，我们可以修改： 打开工程，依次操作菜单如下：Project-&gt;Setting-&gt;Link，在Category 中选中Output，然后在Reserve中设定堆栈的最大值和commit。 注意：reserve最小值为4Byte；commit是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。 
3. **碎片问题**：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。
4. **生长方向**：对于堆来讲，**生长方向是向上的，也就是向着内存地址增加的方向**；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。 
5. **分配方式**：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。
6. **分配效率**：栈是机器系统提供的数据结构，**计算机会在底层对栈提供支持**：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，**例如为了分配一块内存**，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）**在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间**（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。

### 3. 野指针是什么？如何检测内存泄漏？

1. **野指针**：指向**内存被释放的内存**或者**没有访问权限**的内存的指针。

- “野指针”的成因主要有3种：

1. **指针变量没有被初始化**。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。例如 char *p = NULL; char *str = new char(100);
2. 指针p被free或者delete之后，没有置为NULL；
3. 指针操作超越了变量的**作用范围**。

- 如何避免野指针：

1. 对**指针进行初始化**

   ①将指针初始化为NULL。  char *   p  = NULL;

   ②用malloc分配内存。char * p = (char * )malloc(sizeof(char));

   ③用已有合法的可访问的内存地址对指针初始化。char num[ 30] = {0}; char *p = num;

  2.指针用完后释放内存，将指针赋NULL。

​    delete(p);   p = NULL;

### 4. ​​​​​​​悬空指针和野指针有什么区别？

1. 野指针：野指针指，访问一个已删除或访问受限的内存区域的指针，野指针不能判断是否为NULL来避免。指针没有初始化，释放后没有置空，越界
2. 悬空指针：**一个指针的指向对象已被删除，那么就成了悬空指针**。是那些未初始化的指针。 

### 5. 内存泄漏

1. **内存泄漏**：内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制；

2. **后果：**只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会出现各种证照：性能下降到内存逐渐用完，导致另一个程序失败；

3. **如何排除：**- 使用工具软件**BoundsChecker**，BoundsChecker是一个运行时错误检测工具，它主要定位程序运行时期发生的各种错误；调试运行DEBUG版程序，运用以下技术：CRT(C run-time libraries)、运行时函数调用堆栈、内存泄漏时提示的内存分配序号(集成开发环境OUTPUT窗口)，综合分析内存泄漏的原因，排除内存泄漏。

**解决办法：**

1. 智能指针。

**检查、定位内存泄漏**
1. 检查方法：在main函数最后面一行，加上一句_CrtDumpMemoryLeaks()。调试程序，自然关闭程序让其退出，查看输出： 

   输出这样的格式{453}normal block at 0x02432CA8,868 bytes long

   被{}包围的453就是我们需要的内存泄漏定位值，868 bytes long就是说这个地方有868比特内存没有释放。 _

   定位代码位置 

   在main函数第一行加上_CrtSetBreakAlloc(453);意思就是在申请453这块内存的位置中断。然后调试程序，程序中断了，查看调用堆栈。加上头文件#include &lt;crtdbg.h&gt; 

### 6 new和malloc的区别？

1. <img alt="" height="608" src="https://img-blog.csdnimg.cn/20200316171158457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTAzMTg5,size_16,color_FFFFFF,t_70" width="792">

### 7. delete p;与delete[]p，allocator

1. 动态数组管理new一个数组时，[]中必须是一个整数，但是不一定是常量整数，普通数组必须是一个常量整数；

2. new动态数组返回的**并不是数组类型，而是一个元素类型的指针**；

3. delete[]时，数组中的元素按逆序的顺序进行销毁；

4. new在内存分配上面有一些局限性，new的机制是将内存分配和对象构造组合在一起，同样的，delete也是将对象析构和内存释放组合在一起的。allocator将这两部分分开进行，allocator申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作。

### 8. malloc申请的存储空间能用delete释放吗

1. 不能，malloc /free主要为了兼容C，new和delete 完全可以取代malloc /free的。malloc /free的操作对象都是必须明确大小的。而且不能用在动态类上。**new 和delete会自动进行类型检查和大小，malloc/free不能执行与析构函数**，所以动态对象它是不行的。当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。

### 9.  malloc、realloc、calloc的区别

1. malloc函数
   - void* malloc(unsigned int num_size);
   - int *p = malloc(20*sizeof(int));申请20个int类型的空间； 
2. calloc函数
-  void* calloc(size_t n,size_t size); 
int *p = calloc(20, sizeof(int)); 
省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的； 

  3.realloc函数
-  void realloc(void *p, size_t new_size);  给动态分配的空间分配额外的空间，用于扩充容量。

### 10.  使用智能指针管理内存资源，RAII

1. RAII全称是“Resource Acquisition is Initialization”，直译过来是“**资源获取即初始化**”，也就是说**在构造函数中申请分配资源，在析构函数中释放资源**。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。

2. **智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针**，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。

### 11 手写实现智能指针类

1. 智能指针是一个数据类型，一般用**模板实现**，模拟指针行为的同时还提供自动垃圾回收机制。它会自动记录SmartPointer&lt;T*&gt;对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象。除了指针对象外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数。新增对象还需要一个**构造函数，析构函数负责引用计数减少和释放内存。通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1**
2. 一个构造函数、拷贝构造函数、复制构造函数、析构函数、移走函数；

### 12.  内存对齐？位域？
1. 分配内存的顺序是**按照声明的顺序**。
2.  每个变量相对于起始位置的偏移量必须是**该变量类型大小的整数倍**，不是整数倍空出内存，**直到偏移量是整数倍为止**。
3.  最后整个结构体的大小必须是里面变量类型最大值的整数倍。

-添加了**#pragma pack(n)**后规则就变成了下面这样：

1. 偏移量要是n和当前变量大小中较小值的整数倍
2. 整体大小要是n和最大变量大小中较小值的整数倍
3. n值必须为1,2,4,8…，为其他值时就按照默认的分配规则

### 13. 结构体变量比较是否相等

1.重载了 “==” 操作符

2.
```cpp
struct foo {
    int a;
    int b;
    bool operator==(const foo& rhs) // 操作运算符重载
    {
        return( a == rhs.a) && (b == rhs.b);

    }
};
```
3. 元素的话，一个个比；

4. 指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真；

### 14. 为什么内存对齐

1. 平台原因(移植原因)

- 不是所有的硬件平台都能访问任意地址上的任意数据的；
- 某些硬件平台**只能在某些地址处取某些特定类型的数据**，否则抛出硬件异

2. 性能原因
- 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。
- 原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

### 15. 怎样判断两个浮点数是否相等？

1. 对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！
2. 对于两个浮点数比较只能**通过相减并与预先设定的精度比较，记得要取绝对值**！浮点数与0的比较也应该注意。与浮点数的表示方式有关。

### 16.  define、const、typedef、inline使用方法？

- const与#define的区别：
1. const定义的常量是变量带类型，而#define定义的只是个常数**不带类型**；
2. define只在**预处理阶段**起作用，简单的文本替换，而const在编译、链接过程中起作用；
3. define只是简单的字符串替换没有类型检查。而const是有数据类型的，是要进行判断的，可以避免一些低级错误；
4. define预处理后，占用**代码段**空间，const占用**数据段空间**；
5. const不能重定义，而**define可以通过#undef取消某个符号的定**义，进行重定义；
6. define独特功能，比如可以用来防止文件重复引用。

- #define**和别名**typedef**的区别**
1. 执行时间不同，typedef在编译阶段有效，**typedef有类型检查的功能**；#define是宏定义，发生在预处理阶段，不进行类型检查；
2. 功能差异，typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。
3. 作用域不同，#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而typedef有自己的作用域。

- define**与**inline**的区别**

1. #define是关键字，inline是函数；
2. 宏定义在预处理阶段进行文本替换，inline函数在编译阶段进行替换；
3. inline函数有类型检查，相比宏定义比较安全；

### 17. #include 的顺序以及尖叫括号和双引号的区别

1.  表示编译器只在**系统默认目录或尖括号内的工作目录下**搜索头文件，并不去用户的工作目录下寻找，所以一般尖括号用于包含标准库文件； 
2.  表示编译器**先在用户的工作目录下搜索头文**件，如果搜索不到则到系统默认目录下去寻找，所以双引号一般用于包含用户自己编写的头文件。 

### 18. lambda 函数

[capture] （parameters） mutable -&gt;return-type {statement};

1.  利用lambda表达式可以**编写内嵌的匿名函数**，用以替换独立函数或者函数对象； 

2. 每当你定义一个lambda表达式后，编译器会**自动生成一个匿名类**（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。

3. lambda表达式的语法定义如下：

4. lambda必须使用**尾置返回**来指定返回类型，可以**忽略参数列表和返回值**，但必须永远包含**捕获列表和函数体**；

### 19. 模板类和模板函数的区别是什么？

1. **函数模板的实例化**是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。即函数模板允许隐式调用和显式调用而类模板只能显示调用。在使用时类模板必须加&lt;T&gt;，而函数模板不必

### 20. 为什么模板类一般都是放在一个h文件中

1. 模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着**编译器在当时不为它分配存储空间**，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。
2. 在**分离式编译**的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为**模板仅在需要的时候才会实例化**出来，所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。然而当**实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化**，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。



# 秋招总结------C++面试题总结四

### 1. C++中类成员的访问权限和继承权限问题

- 三种访问权限
1. public:用该关键字修饰的成员表示公有成员，该成员不仅可以在类内可以被访问，**在类外也是可以被访问的**，是类对外提供的可访问接口；
2. private:用该关键字修饰的成员表示私有成员，该成员仅在类内可以被访问，在类体外是隐藏状态；
3. protected:用该关键字修饰的成员表示保护成员，保护成员在类体外同样是隐藏状态，但是对于该类的派生类来说，**相当于公有成员**，在派生类中可以被访问。

- 三种继承方式
1. 若继承方式是public，基类成员在派生类中的访问权限保持不变，也就是说，基类中的成员访问权限，在派生类中仍然保持原来的访问权限；
2. 若继承方式是private，基类所有成员在派生类中的访问权限都会变为私有(private)权限；
3. 若继承方式是protected，基类的共有成员和保护成员在派生类中的访问权限都会变为保护(protected)权限，私有成员在派生类中的访问权限仍然是私有(private)权限。

### 2. cout和printf有什么区别？
1. cout<<是一个函数，cout<<后可以跟不同的类型是因为cout<<已存在针对各种类型数据的重载，所以会自动识别数据的类型。输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。

cout是有缓冲输出:
cout < < "abc " < <endl;   或cout < < "abc\n ";cout < <flush; 这两个才是一样的.  endl相当于输出回车后，再强迫缓冲输出。
flush立即强迫缓冲输出。

2. printf是无缓冲输出。有输出时立即输出

### 3. 重载运算符？

 **类属"."、成员指针运算符".*"、作用域分辨符"::"、sizeof运算符和三目运算符"?:"**


1. 我们**只能重载已有的运算符**，而无权发明新的运算符；对于一个重载的运算符，其优先级和结合律与内置类型一致才可以；**不能改变运算符操作数个数**；
2. .    ：：   ？：  sizeof   typeid  **不能重载；
3. 两种重载方式，成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数；下标运算符、箭头运算符必须是成员运算符；
4. 引入运算符重载，是为了实现类的多态性；
5. 当重载的运算符是成员函数时，this绑定到左侧运算符对象。成员运算符函数的参数数量比运算符对象的数量少一个；至少含有一个类类型的参数；
6. 从参数的个数推断到底定义的是哪种运算符，当运算符既是一元运算符又是二元运算符（+，-，*，&amp;）；
7. 下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；
8. 箭头运算符必须是类的成员，解引用通常也是类的成员；重载的箭头运算符必须返回类的指针；

### 4. 定义和声明的区别

1. 如果是指变量的声明和定义 从上来说，**声明是仅仅告诉编译器，有个某类型的变量会被使用**，但是编译器并不会为它分配任何内存。而定义就是分配了内存。
2. 如果是指函数的声明和定义 声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在。 定义：一般在源文件里，具体就是函数的实现过程 写明函数体。

### 5. C++类型转换有四种

- static_cast能进行**基础类型之间的转换**，也是最常看到的类型转换。它主要有如下几种用法：
1.  用于类层次结构中父类和子类之间指针或引用的转换。进行上行转换（把子类的指针或引用转换成父类表示）是安全的； 
	2 . 进行下行转换（把父类指针或引用转换成子类指针或引用）时，由于没有动态类型检查，所以是不安全的； 
	3 . 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。 
	4 . 把void指针转换成目标类型的指针（不安全！！） 
	5 . 把任何类型的表达式转换成void类型。 
	
2. const_cast运算符用来**修改类型的const或volatile属性**。除了去掉const 或volatile修饰之外， type_id和expression得到的类型是一样的。但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。
3. reinterpret_cast它可以**把一个指针转换成一个整数，也可以把一个整数转换成一个指针**（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。
4. dynamic_cast 主要用在继承体系中的**安全向下转型**。它能安全地将指向**基类的指针转型为指向子类的指针或引用**，并获知转型动作成功是否。转型失败会返回null（转型对象为指针时）或抛出异常bad_cast（转型对象为引用时）。 dynamic_cast 会动用运行时信息（RTTI）来进行**类型安全检查**，因此 dynamic_cast 存在一定的效率损失。当使用dynamic_cast时，该类型必须含有虚函数，这是因为dynamic_cast使用了存储在**VTABLE**中的信息来判断实际的类型，RTTI运行时类型识别用于判断类型。typeid表达式的形式是typeid(e)，typeid操作的结果是一个常量对象的引用，该对象的类型是type_info或type_info的派生。

### 6. 静态成员与普通成员的区别

1. **生命周期：**静态成员变量从类被加载开始到类被卸载，一直存在；普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束；
2. **共享方式：**静态成员变量是全类共享；普通成员变量是每个对象单独享用的；
3. **定义位置：**普通成员变量存储在栈或堆中，而静态成员变量存储在静态全局区；
4. **初始化位置：**普通成员变量在类中初始化；静态成员变量在类外初始化；
5. **默认实参：**可以使用静态成员变量作为默认实参，

### 7. 多继承的优缺点，作为一个开发者怎么看待多继承

1. C++允许为**一个派生类指定多个基类**，这样的继承结构被称做多重继承。
2. 多重继承的优点很明显，就是对象可以调用多个基类中的接口；
3. 如果派生类所继承的多个基类有相同的基类，而派生类对象需要调用这个祖先类的接口方法，就会容易出现二义性
4. 加上全局符确定调用哪一份拷贝。比如pa.Author::eat()调用属于Author的拷贝。
5. 使用虚拟继承，使得多重继承类Programmer_Author只拥有Person类的一份拷贝。

### 8. 迭代器++it,it++哪个好，为什么
1. 前置返回一个引用，后置返回一个对象
```cpp
// ++i实现代码为：
int& operator++()
{
    *this += 1;
    return *this;
}

```

1. 前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低
```cpp
//i++实现代码为：                                 

int operator++(int)                                 

{

int temp = *this;                                    

       ++*this;                                            

       return temp;                                    
}
```

### 9. 模板和实现可不可以不写在一个文件里面？为什么？
1. 因为在**编译时模板**并不能生成真正的二进制代码，**而是在编译调用模板类或函数的**CPP文件时才会去找对应的模板声明和实现，在这种情况下编**译器是不知道实现模板类或函数的CPP文件的存在，**所以它只能找到模板类或函数的**声明**而找不到实现，而只好创建一个符号寄希望于链接程序找地址。但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。
2. 《C++编程思想》第15章(第300页)说明了原因：模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。

### 10. class、union、struct的区别？

1. C语言中，**struct只是一个聚合数据类型，没有权限设置，无法添加成员函数**，无法实现面向对象编程，且如果没有typedef结构名，声明结构变量必须添加关键字struct。
2. C++中，struct功能大大扩展，可以有**权限设置**（默认权限为public），可以像class一样有成员函数，继承（默认public继承），可以实现面对对象编程，允许在声明结构变量时省略关键字struct。
3. C与C++中的union:一种数据格式，能够存储不同的数据类型，但只能同时存储其中的一种类型。C++ union结构式一种特殊的类。它能够包含访问权限、成员变量、成员函数（可以包含构造函数和析构函数）。它不能包含虚函数和静态数据变量。它也不能被用作其他类的基类，它本身也不能有从某个基类派生而来。Union中得默认访问权限是public。**union类型是共享内存的，以size最大的结构作为自己的大小**。每个数据成员在内存中的起始地址是相同的。
4. 在C/C++程序的编写中，当多个基本数据类型或复合数据结构要占用同一片内存时，我们要使用联合体；当多种类型，多个对象，多个事物只取其一时（我们姑且通俗地称其为“n 选1”），我们也可以使用联合体来发挥其长处。在某一时刻，一个union中只能有一个值是有效的。union的一个用法就是可以用来测试CPU是大端模式还是小端模式。

### 11. 动态联编与静态联编

1. 在C++中，联编是指一个计算机程序的不**同部分彼此关联**的过程。按照联编所进行的阶段不同，可以分为静态联编和动态联编；
2. 静态联编是指联编工作在编译阶段完成的，这种联编过程是在程序运行之前完成的，又称为早期联编。要实现静态联编，在编译阶段就必须确定程序中的操作调用（如函数调用）与执行该操作代码间的关系，确定这种关系称为束定，在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引用的类型。其优点是效率高，但灵活性差。
3. 动态联编是指联编在程序运行时动态地进行，根据当时的情况来确定调用哪个同名函数，实际上是在运行时虚函数的实现。这种联编又称为晚期联编，或动态束定。动态联编对**成员函数的选择是基于对象的类型**，针对不同的对象类型将做出不同的编译结果。C++中一般情况下的联编是静态联编，但是当涉及到多态性和虚函数时应该使用动态联编。动态联编的优点是灵活性强，但效率低。动态联编规定，只能通过指向基类的指针或基类对象的引用来调用虚函数，其格式为：指向基类的指针变量名-&gt;虚函数名（实参表）或基类对象的引用名.虚函数名（实参表）
4. 实现动态联编三个条件：
5. 必须把动态联编的行为定义为类的虚函数；
6. 类之间应满足子类型关系，通常表现为一个类从另一个类公有派生而来；
7.  必须先使用基类指针指向子类型的对象，然后直接或间接使用基类指针调用虚函数；

### 12. 动态编译与静态编译

1. 静态编译，编译器在编译可执行文件时，把需要用到的对应**动态链接库中的部分**提取出来，连接到可执行文件中去，使可执行文件在运行时**不需要依赖于动态链接库**；
2. 动态编译的可执行文件需要**附带一个动态链接库**，在执行时，需要调用其对应动态链接库的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点是哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。

### 13. 讲讲大端小端，如何检测（三种方法）

1. 大端模式：是指数据的高字节保存在内存的**低地址**中，而数据的低字节保存在内存的高地址端。 

2. 小端模式，是指数据的高字节保存在内存的**高地址**中，低位字节保存在在内存的低地址端。 

3. 直接读取存放在内存中的十六进制数值，取低位进行值判断

4. int a = 0x12345678; 

   int *c = &amp;a;

   c[0] == 0x12   大端模式 

   c[0] == 0x78   小段模式 

5. 用共同体来进行判断

6. union共同体所有数据成员是共享一段内存的，后写入的成员数据将覆盖之前的成员数据，成员数据都有相同的首地址。Union的大小为最大数据成员的大小。 union的成员数据共用内存，并且首地址都是低地址首字节。Int i= 1时：**大端存储1放在最高位，小端存储1放在最低位。当读取char ch时，是最低地址首字节**，大小端会显示不同的值。 

   union w    w p; 

   {      p.i = 1; 

   ​       int i; 

   ​       if(ch == 1)      char ch;

   } 

### 14. 查看内存的方法

1. 首先打开vs编译器，创建好项目，并且将代码写进去，这里就不贴代码了，你可以随便的写个做个测试;

2. 调试的时候做好相应的**断点**，然后点击**开始调试;**

3. 程序调试之后会在你设置断点的地方暂停，然后选择然后选择调试->窗口->内存，就打开了内存数据查看的窗口了。

### 15. 空类会默认添加哪些东西？怎么写？

1. Empty(); // 缺省构造函数//

2. Empty( const Empty&amp; ); // 拷贝构造函数//

3. ~Empty(); // 析构函数//

4. Empty&amp; operator=( const Empty&amp; ); // 赋值运算符//

### 16.  为什么拷贝构造函数必须传引用不能传值？

1.  拷贝构造函数的作用就是用来**复制对象**的，在使用这个对象的实例来初始化这个对象的一个新的实例。 

2) 参数传递过程到底发生了什么？   将地址传递和值传递统一起来，归根结底还是传递的是"值"(地址也是值，只不过通过它可以找到另一个值)！ 

i)值传递:   对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)；   对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；如void foo(class_type obj_local){}, 如果调用foo(obj);  首先class_type obj_local(obj) ,这样就定义了局部变量obj_local供函数内部使用 

ii)引用传递:     无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型). 

上述1) 2)回答了为什么拷贝构造函数使用值传递会产生无限递归调用，内存溢出。 拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归 

### 17. 空类的大小是多少？为什么？

1. C++空类的大小不为0，不同编译器设置不一样，vs设置为1；
2. C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；
3. 带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；
4. C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。

### 18. 你什么情况用指针当参数，什么时候用引用，为什么？

1. 使用引用参数的主要原因有两个：
-  程序员能修改调用函数中的数据对象 通过传递引用而不是整个数据–对象，可以提高程序的运行速度  
1. 一般的原则：  对于使用引用的值而不做修改的函数：
- 如果数据对象很小，如内置数据类型或者小型结构，则按照值传递； 

  如果数据对象是**数组**，则使用指针（**唯一的选择**），并且指针声明为指向const的指针； 

  如果数据对象是**较大的结构**，则使用const指针或者引用，已提高程序的效率。这样可以节省结构所需的时间和空间；

   如果数据对象是类对象，则使用const引用（传递类对象参数的标准方式是按照引用传递）； 

1. 对于修改函数中数据的函数：
- 如果数据是内置数据类型，则使用指针 

  如果数据对象是数组，则只能使用指针 

  如果数据对象是结构，则使用引用或者指针 

  如果数据是类对象，则使用引用
 
### 19. 大内存申请时候选用哪种？C++变量存在哪？变量的大小存在哪？符号表存在哪？

1. 大内存申请时，采用堆申请空间，用new申请；
2. 不同的变量存储在不同的地方，局部变量、全局变量、静态变量；
3. C++对变量名不作存储，在汇编以后不会出现变量名，变量名作用只是用于方便编译成汇编代码，是给编译器看的，是方便人阅读的
### 20. 静态函数能定义为虚函数吗？常函数?
1. static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。
2. 静态与非静态成员函数之间有一个主要的区别。那就是**静态成员函数没有this指针**。虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.对于静态成员函数，它没有this指针，所以无法访问vptr. 这就是为何static函数不能为virtual.虚函数的调用关系：this -> vptr -> vtable ->virtual function


# 秋招总结------C++面试题总结五

### 1.​this指针调用成员变量时，堆栈会发生什么变化？

1. 当在类的非静态成员函数访问类的**非静态成员**时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个**隐含参数就是this指针**。即使你并没有写this指针，编译器在链接时也会加上this的，对各成员的访问都是通过this的。例如你建立了类的多个对象时，在调用类的成员函数时，你并不知道具体是哪个对象在调用，此时你可以通过查看this指针来查看具体是哪个对象在调用。This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。

### 2. 静态绑定和动态绑定的介绍

1. 对象的静态类型：对象在声明时采用的类型。是在编译期确定的。

2. 对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。

3. 静态绑定：绑定的是对象的静态类型，某特性（比如）依赖于对象的静态类型，发生在编译期。

4. 动态绑定：绑定的是对象的动态类型，某特性（比如）依赖于对象的动态类型，发生在运行期。

### 3. 虚函数的代价？

1. 带有虚函数的类，每一个类会产生一个**虚函数表**，用来存储指向虚成员函数的指针，增大类；

2. 带有虚函数的类的每一个对象，都会有**有一个指向虚表的指针**，会增加对象的空间大小；

3. **不能再是内敛的函数**，因为内敛函数在编译阶段进行替代，而虚函数表示等待，在运行阶段才能确定到低是采用哪种函数，虚函数不能是内敛函数。

### 4. 类对象的大小

1. 类的**非静态成员变量大小**，静态成员不占据类的空间，成员函数也不占据类的空间大小；

2. **内存对齐另外分配的空间大小**，类内的数据也是需要进行内存对齐操作的；

3. 虚函数的话，会在类对象插入vptr指针，加上指针大小；

4. 当该该类是某类的派生类，那么派生类继承的**基类部分的数据成员**也会存在在派生类中的空间中，也会对派生类进行扩展。

### 5. ​​​​​​​移动构造函数

1. 有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把**a对象的内容复制一份到b**中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；

2. **拷贝构造函数**中，对于指针，我们一定要采用**深层复制**，而**移动构造函数**中，对于指针，我们采用**浅层复制**；

3. C++引入了移动构造函数，专门处理这种，用a初始化b后，就将a析构的情况；

4. 与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是**函数的返回值或者类型转换的对象**。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对象进行构造初始化的时候，调用移动构造函数。类似的，**使用未命名的变量的值赋给一个对象时，调用移动赋值操作**；

5.

```cpp
Example6 (Example6&& x) : ptr(x.ptr)
    {
        x.ptr = nullptr;
    }
    // move assignment
    Example6& operator= (Example6&& x)
    {
        delete ptr;
        ptr = x.ptr;
        x.ptr=nullptr;
        return *this;
}
```

### 6. 何时需要合成构造函数

1. 如果一个类没有任何构造函数，但他含有一个成员对象，该成员对象含有**默认构造函数**，那么编译器就为该类合成一个默认构造函数，因为不合成一个默认构造函数那么该成员对象的构造函数不能调用；
2. 没有任何构造函数的类派生自一个带有默认构造函数的基类，那么需要为该派生类合成一个构造函数，只有**这样基类的构造函数才能被调用**；
3. **带有虚函数的类**，虚函数的引入需要进入**虚表，指向虚表的指针**，该指针是在构造函数中初始化的，所以没有构造函数的话该指针无法被初始化；
4. **带有一个虚基类的类**
- 并不是任何没有构造函数的类都会合成一个构造函数
- 编译器合成出来的构造函数并不会显示设定类内的每一个成员变量

### 7.  何时需要合成复制构造函数
- 有三种情况会以一个对象的内容作为另一个对象的初值：
1. 对一个对象做显示的初始化操作，X xx = x;
2. 当**对象被当做参数**交给某个函数时；
3. 当函数传回一个类对象时；
- 
1. 如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时编译器会为该类合成一个拷贝构造函数；
2. 如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数；
3. 如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝构造函数；
4. 如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数；
### 8. 何时需要成员初始化列表？过程是什么？
1. 当初始化一个**引用**成员变量时；
2. 初始化一个**const**成员变量时；
3. 当调用一个基类的构造函数，而构造函数拥有一组参数时；
4. 当调用一个成员类的构造函数，而他拥有一组参数；
5. 编译器会一一操作初始化列表，以适当顺序在构造函数之内安插初始化操作，并且在任何显示用户代码前。list中的项目顺序是由类中的成员声明顺序决定的，不是初始化列表中的排列顺序决定的。

### 9. 程序员定义的析构函数被扩展的过程？
1. 析构函数**函数体被执行**；
2. 如果class拥有**成员类对象**，而后者拥有析构函数，那么它们会以其声明顺序的相反顺序被调用；
3. 如果对象有一个vptr，现在被重新定义
4. 如果有任何直接的上一层非虚基类拥有析构函数，则它们会以声明顺序被调用；
5. 如果任何虚基类拥有析构函数

### 10. 哪些函数不能是虚函数

1. 构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；
2. 内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；
3. 静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。
4. 友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。
5. 普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。

### 11. sizeof 和strlen 的区别

1. strlen计算字**符串的具体长度**（只能是字符串），不包括字符串结束符。返回的是字符个数。
2. sizeof计算声明后所占的**内存数**（字节大小），不是实际长度。
3. sizeof是一个取字节运算符，而strlen是个函数。
4. sizeof的返回值=**字符个数*字符所占的字节数**，字符实际长度小于定义的长度，此时字符个数就等于定义的长度。若未给出定义的大小，分类讨论，对于字符串数组，字符大 小等于实际的字符个数+1；对于整型数组，字符个数为实际的字符个数。字符串每个字符占1个字节，整型数据每个字符占的字节数需根据系统的位数类确定，32位占4个字节。
5. sizeof可以用类型做参数，**strlen只能用char*做参数**，且必须以‘\0’结尾，sizeof还可以用函数做参数；
6.  数组做sizeof的参数不退化，传递给strlen就退化为指针；

### 12. 将“引用”作为函数参数有哪些特点？

1. **传递引用给函数与传递指针的效果是一样的**。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。
2. 使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。
3. 使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。

### 13. 局部变量全局变量的问题？

1. 局部会屏蔽全局。要用全局变量，需要使用"::"局部变量可以与全局变量同名，在函数内引用这个变量时，**会用到同名的局部变量**，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内。
2. 如何引用一个已经定义过的全局变量，可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。
3. 全局变量可不可以定义在可被多个.C文件包含的头文件中，在不同的C文件中以static形式来声明同名全局变量。可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错。

### 14. 数组和指针的区别？

1. 数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：sizeof（数组名）；数组大小：sizeof(数组名)/sizeof(数组元素数据类型)；
2. 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。
3. 编译器为了简化对数组的支持，实际上是利用**指针实现了对数组的支持**。具体来说，就是将表达式中的数组元素引用转换为指针加偏移量的引用。
4. 在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是传递过去是数组的首地址而不是整个数组，能够提高效率；
5. 在使用下标的时候，两者的用法相同，都是**原地址加上下标值**，不过数组的原地址就是数组首元素的地址是固定的，指针的原地址就不是固定的。

### 15. 如何禁止自动生成拷贝构造函数？

1. 为了阻止编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况﻿下，为了避免调用拷贝构造函数和﻿拷贝赋值函数，我们需要将他们**设置成private**，防止被调用。
2. 类的成员函数和friend函数还是可以调用private函数，如果这个private函数只声明不定义，则会产生一个连接错误。
3. 针对上述两种情况，我们可以定一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成private,那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作。

### 16. 虚函数与纯虚函数的区别在于

1. 纯虚函数只有定义没有实现，虚函数既有定义又有实现；
2. 含有纯虚函数的类不能定义对象，含有虚函数的类能定义对象；

### 17. 智能指针怎么用？智能指针出现循环引用怎么解决？

1. shared_ptr

- 调用一个名为make_shared的标准库函数，shared_ptr&lt;int&gt; p = make_shared&lt;int&gt;(42);

  通常用auto更方便，auto p = …;shared_ptr&lt;int&gt; p2(new int(2)); 

每个shared_ptr都有一个关联的计数器，通常称为引用计数，一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象；shared_ptr的析构函数就会递减它所指的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它占用的内存。 

2. unique_ptr

-  一个unique_ptr拥有它所指向的对象。某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。

3. weak_ptr

- weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个**shared_ptr管理的对象**，将一个weak_ptr绑定到一个shared_ptr不会改变引用计数，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向对象，对象还是会被释放。 

  1  弱指针用于专门解决**shared_ptr循环引用**的问题，weak_ptr不会修改引用计数，即其存在与否并不影响对象的引用计数器。循环引用就是：两个对象互相使用一个shared_ptr成员变量指向对方。弱引用并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。

### 18 回调函数的作用

1. 当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；
2. 回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此，你需要做三件事：1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；
3. 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；
4. 因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。​​​​​​​

